{"version":3,"file":"dep-graph-releaser-gui.js","sources":["../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/actions/Downloader.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/actions/Publisher.kt","kotlin/promise.kt","generated/_Strings.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/actions/Releaser.kt","collections/Maps.kt","generated/_Collections.kt","collections/Collections.kt","kotlin/collections.kt","generated/_Sequences.kt","util/Preconditions.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/documentUtils.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/App.kt","kotlin/string.kt","../../../../../../../dummy.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/ContextMenu.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/formComponents.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/Loader.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/Menu.kt","generated/_Arrays.kt","collections/Iterators.kt","org.w3c/org.w3c.dom.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/Pipeline.kt","collections/Sets.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/components/Toggler.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/ContentContainer.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/htmlExtensions.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/BaseJobExecutionDataFactory.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/BuilderNumberExtractor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/BuildHistoryBasedBuildNumberExtractor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/DryRunJobExecutionDataFactory.kt","util/Standard.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/http.kt","org.w3c/org.w3c.fetch.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/httpDataClasses.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/issueCrumb.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/JenkinsJobExecutor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/jenkinsUtils.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/JobExecutionData.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/JobExecutor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/LocationBasedQueuedItemUrlExtractor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/Poller.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/PollTimeoutException.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/QueuedItemBasedBuildNumberExtractor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/ReleaseJobExecutionDataFactory.kt","text/Strings.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/appendToString.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/RestApiBasedQueuedItemUrlExtractor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/SimulatingJobExecutor.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/UrlWithSlashAtTheEnd.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/UsernameTokenRegistry.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/popups.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/recovery/recover.kt","util/Lazy.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/serialization/ChangeApplier.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/serialization/deserialize.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/serialization/ModifiableState.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/utils.kt","../../../../src/main/kotlin/main.kt","../../../../src/main/kotlin/ch.loewenfels.depgraph/gui/jobexecution/urlConstants.kt"],"sourcesContent":["package ch.loewenfels.depgraph.gui.actions\r\n\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.gui.components.encodeURIComponent\r\nimport org.w3c.dom.HTMLElement\r\nimport kotlin.browser.document\r\n\r\nclass Downloader(private val modifiableState: ModifiableState) {\r\n\r\n    fun download() {\r\n        val json = modifiableState.getJsonWithAppliedChanges()\r\n        download(\"release.json\", json)\r\n    }\r\n\r\n    companion object {\r\n        fun download(fileName: String, content: String){\r\n            val a = document.createElement(\"a\") as HTMLElement\r\n            a.setAttribute(\"href\", \"data:text/plain;charset=utf-8,${encodeURIComponent(content)}\")\r\n            a.setAttribute(\"download\", fileName)\r\n            a.style.display = \"none\"\r\n            document.body!!.appendChild(a)\r\n            a.click()\r\n            document.body!!.removeChild(a)\r\n        }\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.actions\r\n\r\nimport ch.loewenfels.depgraph.gui.*\r\nimport ch.loewenfels.depgraph.gui.jobexecution.*\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nclass Publisher(\r\n    private val publishJobUrl: String,\r\n    private var modifiableState: ModifiableState\r\n) {\r\n\r\n    fun publish(fileName: String, verbose: Boolean, jobExecutor: JobExecutor): Promise<*> {\r\n        changeCursorToProgress()\r\n        val doNothingPromise: (Any?) -> Promise<*> = { Promise.resolve(1) }\r\n        val parameters = mapOf(\r\n            \"fileName\" to fileName,\r\n            \"json\" to modifiableState.json\r\n        )\r\n        val jobExecutionData = JobExecutionData.buildWithParameters(\r\n            \"publish $fileName.json\",\r\n            publishJobUrl,\r\n            toQueryParameters(parameters),\r\n            parameters\r\n        )\r\n        return jobExecutor.trigger(\r\n            jobExecutionData,\r\n            doNothingPromise,\r\n            doNothingPromise,\r\n            pollEverySecond = 2,\r\n            maxWaitingTimeForCompletenessInSeconds = 60,\r\n            verbose = verbose\r\n        ).then { (authData, buildNumber) ->\r\n            extractResultJsonUrl(jobExecutor, authData, publishJobUrl, buildNumber).then {\r\n                buildNumber to it\r\n            }\r\n        }.then { (buildNumber, releaseJsonUrl) ->\r\n            changeUrlAndReloadOrAddHint(publishJobUrl, buildNumber, releaseJsonUrl, verbose)\r\n        }.finally {\r\n            changeCursorBackToNormal()\r\n        }\r\n    }\r\n\r\n    private fun extractResultJsonUrl(\r\n        jobExecutor: JobExecutor,\r\n        authData: AuthData,\r\n        jobUrl: String,\r\n        buildNumber: Int\r\n    ): Promise<String> {\r\n        val xpathUrl = \"$jobUrl$buildNumber/api/xml?xpath=//artifact/fileName\"\r\n        return jobExecutor.pollAndExtract(\r\n            authData,\r\n            xpathUrl,\r\n            resultRegex,\r\n            pollEverySecond = 2,\r\n            maxWaitingTimeInSeconds = 20,\r\n            errorHandler = { e ->\r\n            throw IllegalStateException(\r\n                \"Could not find the published release.json as artifact of the publish job.\" +\r\n                    \"\\nJob URL: $jobUrl\" +\r\n                    \"\\nRegex used: ${resultRegex.pattern}\" +\r\n                    \"\\nContent: ${e.body}\"\r\n            )\r\n        }).then { fileName ->\r\n            \"$jobUrl$buildNumber/artifact/$fileName\"\r\n        }\r\n    }\r\n\r\n    private fun changeUrlAndReloadOrAddHint(\r\n        jobUrl: String,\r\n        buildNumber: Int,\r\n        releaseJsonUrl: String,\r\n        verbose: Boolean\r\n    ) {\r\n        val prefix = window.location.protocol + \"//\" + window.location.hostname + \"/\"\r\n        val isOnSameHost = jobUrl.startsWith(prefix)\r\n        if (isOnSameHost) {\r\n            val pipelineUrl = window.location.href.substringBefore('#')\r\n            val relativeJobUrl = jobUrl.substringAfter(prefix)\r\n            val numOfChars = pipelineUrl.substringAfter(prefix).count { it == '/' }\r\n            val relativeJsonUrl = \"../\".repeat(numOfChars) + releaseJsonUrl.substringAfter(prefix)\r\n            val url = \"$pipelineUrl#$relativeJsonUrl${App.PUBLISH_JOB}$relativeJobUrl\"\r\n            if (verbose) {\r\n                val successMsg = showSuccess(\r\n                    \"Publishing successful, going to change to the new location.\" +\r\n                        \"\\nIf this message does not disappear, then it means the switch failed. Please visit the following url manually:\" +\r\n                        \"\\n$url\"\r\n                )\r\n                sleep(2000) {\r\n                    window.location.href = url\r\n                    successMsg.remove()\r\n                }\r\n            } else {\r\n                window.location.href = url\r\n            }\r\n        } else if (verbose) {\r\n            showWarning(\r\n                \"Remote publish server detected. We currently do not support to consume remote release.json.\" +\r\n                    \"\\nYou can save changes and it gets published on the remote server, but we will not change the url accordingly. Thus, please do not reload the page after a save because you would load the old state of the release.json\" +\r\n                    \"\\nAlternatively you can download the published release.json from here: $jobUrl$buildNumber and adjust the url manually.\"\r\n            )\r\n        }\r\n    }\r\n\r\n    fun applyChanges(): Boolean {\r\n        return modifiableState.applyChanges()\r\n    }\r\n\r\n    companion object {\r\n        private val resultRegex = Regex(\"<fileName>([^<]+)</fileName>\")\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport kotlin.internal.LowPriorityInOverloadResolution\n\n/**\n * Exposes the JavaScript [Promise object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic open external class Promise<out T>(executor: (resolve: (T) -> Unit, reject: (Throwable) -> Unit) -> Unit) {\n    @LowPriorityInOverloadResolution\n    public open fun <S> then(onFulfilled: ((T) -> S)?): Promise<S>\n\n    @LowPriorityInOverloadResolution\n    public open fun <S> then(onFulfilled: ((T) -> S)?, onRejected: ((Throwable) -> S)?): Promise<S>\n\n    public open fun <S> catch(onRejected: (Throwable) -> S): Promise<S>\n\n    companion object {\n        public fun <S> all(promise: Array<out Promise<S>>): Promise<Array<out S>>\n\n        public fun <S> race(promise: Array<out Promise<S>>): Promise<S>\n\n        public fun reject(e: Throwable): Promise<Nothing>\n\n        public fun <S> resolve(e: S): Promise<S>\n        public fun <S> resolve(e: Promise<S>): Promise<S>\n    }\n}\n\n// It's workaround for KT-19672 since we can fix it properly until KT-11265 isn't fixed.\ninline fun <T, S> Promise<Promise<T>>.then(\n    noinline onFulfilled: ((T) -> S)?\n): Promise<S> {\n    return this.unsafeCast<Promise<T>>().then(onFulfilled)\n}\n\ninline fun <T, S> Promise<Promise<T>>.then(\n    noinline onFulfilled: ((T) -> S)?,\n    noinline onRejected: ((Throwable) -> S)?\n): Promise<S> {\n    return this.unsafeCast<Promise<T>>().then(onFulfilled, onRejected)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAt(index: Int): Char {\n    return get(index)\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length)))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each character of the original char sequence.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the desired action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\npublic fun CharSequence.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\npublic fun CharSequence.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val result = ArrayList<R>((thisSize + step - 1) / step)\n    var index = 0\n    while (index < thisSize) {\n        val end = index + size\n        val coercedEnd = if (end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index -> transform(subSequence(index, (index + size).coerceAtMost(length))) }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","package ch.loewenfels.depgraph.gui.actions\r\n\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsCommand\r\nimport ch.loewenfels.depgraph.gui.*\r\nimport ch.loewenfels.depgraph.gui.components.Menu\r\nimport ch.loewenfels.depgraph.gui.components.Pipeline\r\nimport ch.loewenfels.depgraph.gui.jobexecution.*\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.tutteli.kbox.mapWithIndex\r\nimport org.w3c.dom.HTMLAnchorElement\r\nimport kotlin.browser.window\r\nimport kotlin.collections.set\r\nimport kotlin.js.Promise\r\n\r\nclass Releaser(\r\n    defaultJenkinsBaseUrl: String,\r\n    private val modifiableState: ModifiableState,\r\n    private val menu: Menu\r\n) {\r\n\r\n    private val isOnSameHost: Boolean\r\n\r\n    init {\r\n        val prefix = window.location.protocol + \"//\" + window.location.hostname\r\n        isOnSameHost = defaultJenkinsBaseUrl.startsWith(prefix)\r\n    }\r\n\r\n    fun release(jobExecutor: JobExecutor, jobExecutionDataFactory: JobExecutionDataFactory): Promise<Boolean> {\r\n        warnIfNotOnSameHost()\r\n        val rootProject = modifiableState.releasePlan.getRootProject()\r\n        val paramObject = ParamObject(\r\n            modifiableState.releasePlan, jobExecutor, jobExecutionDataFactory, rootProject, hashMapOf(), hashMapOf()\r\n        )\r\n        changeCursorToProgress()\r\n        return release(paramObject)\r\n            .finally {\r\n                changeCursorBackToNormal()\r\n                it ?: false\r\n            }\r\n    }\r\n\r\n    private fun warnIfNotOnSameHost() {\r\n        if (!isOnSameHost) {\r\n            showWarning(\r\n                \"Remote publish server detected. We currently do not support to consume remote release.json.\" +\r\n                    \"\\nThis means that we publish changes during the release process but will not change the location. Thus, please do not reload the page during the release process.\"\r\n                , 8000\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun release(paramObject: ParamObject): Promise<Boolean> {\r\n        if (modifiableState.releasePlan.state != ReleaseState.IN_PROGRESS) {\r\n            Pipeline.changeReleaseState(ReleaseState.IN_PROGRESS)\r\n        }\r\n        return releaseProject(paramObject)\r\n            .then {\r\n                val (result, newState) = checkProjectStates(paramObject)\r\n                Pipeline.changeReleaseState(newState)\r\n                quietSave(paramObject, verbose = false)\r\n                    .catch { t ->\r\n                        showThrowable(\r\n                            Error(\r\n                                \"Could not save the release state (changed to $newState).\" +\r\n                                    \"\\nDo not reload if you want to continue using this pipeline and make sure the publisher works as expected.\" +\r\n                                    \"\\nMake a change (e.g. change a Release Version) and try to save (will save the changed release state as well) -- do not forget to revert your change and save again.\",\r\n                                t\r\n                            )\r\n                        )\r\n                    }\r\n                result\r\n            }\r\n    }\r\n\r\n    private fun checkProjectStates(paramObject: ParamObject): Pair<Boolean, ReleaseState> {\r\n        val result = paramObject.projectResults.values.all {\r\n            it === CommandState.Succeeded || it is CommandState.Deactivated || it === CommandState.Disabled\r\n        }\r\n        val newState = if (result) {\r\n            ReleaseState.SUCCEEDED\r\n        } else {\r\n            checkForNoneFailedBug(paramObject)\r\n            ReleaseState.FAILED\r\n        }\r\n        return result to newState\r\n    }\r\n\r\n    private fun checkForNoneFailedBug(paramObject: ParamObject) {\r\n        if (paramObject.projectResults.values.none { it === CommandState.Failed }) {\r\n            val erroneousProjects = paramObject.projectResults.entries\r\n                .filter {\r\n                    it.value !== CommandState.Failed && it.value !== CommandState.Succeeded &&\r\n                        it.value !is CommandState.Deactivated && it.value !== CommandState.Disabled\r\n                }\r\n            if (erroneousProjects.isNotEmpty()) {\r\n                showError(\r\n                    \"\"\"\r\n                        |Seems like there is a bug since no command failed but not all commands are in status Succeeded.\r\n                        |Please report a bug at $GITHUB_NEW_ISSUE - the following projects where affected:\r\n                        |${erroneousProjects.joinToString(\"\\n\") { it.key.identifier }}\r\n                    \"\"\".trimMargin()\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun releaseProject(paramObject: ParamObject): Promise<*> {\r\n        return paramObject.withLockForProject {\r\n            triggerNonReleaseCommandsInclSubmoduleCommands(paramObject).then { jobResult ->\r\n                if (jobResult !== CommandState.Succeeded) return@then jobResult\r\n\r\n                triggerReleaseCommands(paramObject).unsafeCast<CommandState>()\r\n            }.then { jobResult ->\r\n                paramObject.projectResults[paramObject.project.id] = jobResult\r\n                if (jobResult !== CommandState.Succeeded) return@then jobResult\r\n\r\n                val releasePlan = paramObject.releasePlan\r\n                val allDependents = releasePlan.collectDependentsInclDependentsOfAllSubmodules(paramObject.project.id)\r\n                updateStateWaiting(releasePlan, allDependents)\r\n                releaseDependentProjects(allDependents, releasePlan, paramObject)\r\n            }.catch { t ->\r\n                paramObject.projectResults[paramObject.project.id] = CommandState.Failed\r\n                if (t !== ReleaseFailure) throw t\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun updateStateWaiting(releasePlan: ReleasePlan, allDependents: Set<Pair<ProjectId, ProjectId>>) {\r\n        allDependents.forEach { (multiOrSubmoduleId, dependentId) ->\r\n            val dependentProject = releasePlan.getProject(dependentId)\r\n            dependentProject.commands.forEachIndexed { index, _ ->\r\n                val state = Pipeline.getCommandState(dependentId, index)\r\n                if (state is CommandState.Waiting && state.dependencies.contains(multiOrSubmoduleId)) {\r\n                    (state.dependencies as MutableSet).remove(multiOrSubmoduleId)\r\n                    if (state.dependencies.isEmpty()) {\r\n                        Pipeline.changeStateOfCommand(\r\n                            dependentProject, index, CommandState.Ready, Pipeline.STATE_READY\r\n                        )\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun releaseDependentProjects(\r\n        allDependents: HashSet<Pair<ProjectId, ProjectId>>,\r\n        releasePlan: ReleasePlan,\r\n        paramObject: ParamObject\r\n    ): Promise<*> {\r\n        val promises: List<Promise<*>> = allDependents\r\n            .asSequence()\r\n            .map { (_, dependentId) -> releasePlan.getProject(dependentId) }\r\n            .filter { !it.isSubmodule }\r\n            .toHashSet()\r\n            .map { dependentProject ->\r\n                releaseProject(ParamObject(paramObject, dependentProject))\r\n            }\r\n        // Stops as soon as a bug occurs in the execution of one job (not the same as a job-failure)\r\n        // I think this is fine because we do not know if this bug has other consequences and thus it\r\n        // might be better if we stop as early as possible in such cases.\r\n        return Promise.all(promises.toTypedArray())\r\n    }\r\n\r\n    private fun triggerNonReleaseCommandsInclSubmoduleCommands(paramObject: ParamObject): Promise<CommandState> {\r\n        return paramObject.project.commands\r\n            .asSequence()\r\n            .mapWithIndex()\r\n            .filter { it.value !is ReleaseCommand }\r\n            .doSequentially(mutableListOf()) { (index, command) ->\r\n                createCommandPromise(paramObject, command, index)\r\n            }.then { jobsResults ->\r\n                paramObject.releasePlan.getSubmodules(paramObject.project.id)\r\n                    .asSequence()\r\n                    .doSequentially(jobsResults as MutableList<CommandState>) { submoduleId ->\r\n                        triggerNonReleaseCommandsInclSubmoduleCommands(ParamObject(paramObject, submoduleId))\r\n                    }\r\n            }.then { jobsResults ->\r\n                jobsResults.firstOrNull { it !== CommandState.Succeeded } ?: CommandState.Succeeded\r\n            }\r\n    }\r\n\r\n    private fun <T> Sequence<T>.doSequentially(\r\n        initial: MutableList<CommandState>,\r\n        action: (T) -> Promise<CommandState>\r\n    ): Promise<List<CommandState>> {\r\n        return this.fold(Promise.resolve(initial)) { acc, element ->\r\n            acc.then { list ->\r\n                action(element).then { jobResult ->\r\n                    //do not continue with next command if a previous was not successful\r\n                    if (jobResult === CommandState.Failed) throw ReleaseFailure\r\n                    list.add(jobResult)\r\n                    list\r\n                }\r\n            }.unwrapPromise()\r\n        }\r\n    }\r\n\r\n    private fun triggerReleaseCommands(paramObject: ParamObject): Promise<CommandState> {\r\n        return paramObject.project.commands\r\n            .asSequence()\r\n            .mapWithIndex()\r\n            .filter { it.value is ReleaseCommand }\r\n            .doSequentially(mutableListOf()) { (index, command) ->\r\n                createCommandPromise(paramObject, command, index)\r\n            }.then { jobsResults ->\r\n                jobsResults.firstOrNull { it !== CommandState.Succeeded } ?: CommandState.Succeeded\r\n            }\r\n    }\r\n\r\n    private fun createCommandPromise(paramObject: ParamObject, command: Command, index: Int): Promise<CommandState> {\r\n        val state = Pipeline.getCommandState(paramObject.project.id, index)\r\n        return when (state) {\r\n            is CommandState.Ready, is CommandState.ReadyToReTrigger -> triggerCommand(paramObject, command, index)\r\n            is CommandState.StillQueueing -> rePollQueueing(paramObject, command, index)\r\n            is CommandState.RePolling -> rePollCommand(paramObject, command, index)\r\n\r\n            is CommandState.Waiting,\r\n            is CommandState.Queueing,\r\n            is CommandState.InProgress,\r\n            is CommandState.Succeeded,\r\n            is CommandState.Failed,\r\n            is CommandState.Deactivated,\r\n            is CommandState.Disabled -> Promise.resolve(state)\r\n        }\r\n    }\r\n\r\n    private fun triggerCommand(paramObject: ParamObject, command: Command, index: Int): Promise<CommandState> {\r\n        val jobExecutionData = paramObject.jobExecutionDataFactory.create(paramObject.project, command)\r\n        return triggerJob(paramObject, index, jobExecutionData)\r\n    }\r\n\r\n\r\n    private fun rePollQueueing(paramObject: ParamObject, command: Command, index: Int): Promise<CommandState> {\r\n        if (command !is JenkinsCommand) {\r\n            throw IllegalStateException(\"We do not know how to re-poll a non Jenkins command.\\nGiven Command: $command\")\r\n        }\r\n        val queuedItemUrl = command.buildUrl\r\n            ?: throw IllegalStateException(\"We do not know how to re-poll a queued Jenkins job if it does not have a specified build url.\\nGiven Command: $command\")\r\n\r\n        val jobExecutionData = paramObject.jobExecutionDataFactory.create(paramObject.project, command)\r\n        return paramObject.jobExecutor.rePollQueueing(\r\n            jobExecutionData,\r\n            queuedItemUrl,\r\n            jobStartedHookHandler(paramObject, jobExecutionData, index),\r\n            POLL_EVERY_SECOND,\r\n            MAX_WAIT_FOR_COMPLETION\r\n        ).finalizeJob(paramObject, jobExecutionData, index)\r\n    }\r\n\r\n    private fun rePollCommand(paramObject: ParamObject, command: Command, index: Int): Promise<CommandState> {\r\n        if (command !is JenkinsCommand) {\r\n            throw IllegalStateException(\"We do not know how to re-poll a non Jenkins command.\\nGiven Command: $command\")\r\n        }\r\n        val buildUrl = command.buildUrl\r\n            ?: throw IllegalStateException(\"We do not know how to re-poll a Jenkins command if it does not have a specified build url.\\nGiven Command: $command\")\r\n\r\n        val jobExecutionData = paramObject.jobExecutionDataFactory.create(paramObject.project, command)\r\n        val buildNumber = extractBuildNumberFromUrl(buildUrl, jobExecutionData, paramObject.project, index)\r\n        return paramObject.jobExecutor.rePoll(\r\n            jobExecutionData,\r\n            buildNumber,\r\n            POLL_EVERY_SECOND,\r\n            MAX_WAIT_FOR_COMPLETION\r\n        ).finalizeJob(paramObject, jobExecutionData, index)\r\n    }\r\n\r\n    private fun extractBuildNumberFromUrl(\r\n        buildUrl: String,\r\n        jobExecutionData: JobExecutionData,\r\n        project: Project,\r\n        index: Int\r\n    ): Int {\r\n        return try {\r\n            buildUrl.substringAfter(jobExecutionData.jobBaseUrl).substringBefore(\"/\").toInt()\r\n        } catch (e: NumberFormatException) {\r\n            val commandTitle = elementById(Pipeline.getCommandId(project, index) + Pipeline.TITLE_SUFFIX).innerText\r\n            throw IllegalStateException(\r\n                \"Could not extract the buildNumber from the buildUrl, either a corrupt or outdated release.json.\" +\r\n                    \"\\nbuildUrl: $buildUrl\" +\r\n                    \"\\njobBaseUrl: ${jobExecutionData.jobBaseUrl}\" +\r\n                    \"\\nProject: ${project.id.identifier}\" +\r\n                    \"\\nCommand: $commandTitle (${index + 1}. command)\"\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun triggerJob(\r\n        paramObject: ParamObject,\r\n        index: Int,\r\n        jobExecutionData: JobExecutionData\r\n    ): Promise<CommandState> {\r\n        return paramObject.jobExecutor.trigger(\r\n            jobExecutionData,\r\n            jobQueuedHookHandler(paramObject, index),\r\n            jobStartedHookHandler(paramObject, jobExecutionData, index),\r\n            POLL_EVERY_SECOND,\r\n            MAX_WAIT_FOR_COMPLETION,\r\n            verbose = false\r\n        ).finalizeJob(paramObject, jobExecutionData, index)\r\n    }\r\n\r\n    private fun jobQueuedHookHandler(paramObject: ParamObject, index: Int): (String?) -> Promise<Unit> {\r\n        return { queuedItemUrl ->\r\n            Pipeline.changeStateOfCommandAndAddBuildUrlIfSet(\r\n                paramObject.project,\r\n                index,\r\n                CommandState.Queueing,\r\n                Pipeline.STATE_QUEUEING,\r\n                queuedItemUrl\r\n            )\r\n            quietSave(paramObject)\r\n        }\r\n    }\r\n\r\n    private fun jobStartedHookHandler(\r\n        paramObject: ParamObject,\r\n        jobExecutionData: JobExecutionData,\r\n        index: Int\r\n    ): (Int) -> Promise<Int> {\r\n        return { buildNumber ->\r\n            Pipeline.changeStateOfCommandAndAddBuildUrl(\r\n                paramObject.project,\r\n                index,\r\n                CommandState.InProgress,\r\n                Pipeline.STATE_IN_PROGRESS,\r\n                \"${jobExecutionData.jobBaseUrl}$buildNumber/\"\r\n            )\r\n            Promise.resolve(1)\r\n        }\r\n    }\r\n\r\n\r\n    private fun Promise<*>.finalizeJob(\r\n        paramObject: ParamObject,\r\n        jobExecutionData: JobExecutionData,\r\n        index: Int\r\n    ): Promise<CommandState> {\r\n        return this.then(\r\n            onFulfilled = { onJobEndedSuccessFully(paramObject.project, index) },\r\n            onRejected = { t -> onJobEndedWithFailure(t, jobExecutionData, paramObject.project, index) }\r\n        )\r\n    }\r\n\r\n    private fun onJobEndedSuccessFully(project: Project, index: Int): CommandState {\r\n        Pipeline.changeStateOfCommand(project, index, CommandState.Succeeded, Pipeline.STATE_SUCCEEDED)\r\n        return CommandState.Succeeded\r\n    }\r\n\r\n    private fun onJobEndedWithFailure(\r\n        t: Throwable,\r\n        jobExecutionData: JobExecutionData,\r\n        project: Project,\r\n        index: Int\r\n    ): CommandState {\r\n        showThrowable(Error(\"Job ${jobExecutionData.jobName} failed\", t))\r\n        val state = elementById<HTMLAnchorElement>(\r\n            \"${Pipeline.getCommandId(project, index)}${Pipeline.STATE_SUFFIX}\"\r\n        )\r\n        val href = if (!state.href.endsWith(endOfConsoleUrlSuffix)) {\r\n            state.href + \"/\" + endOfConsoleUrlSuffix\r\n        } else {\r\n            state.href\r\n        }\r\n        Pipeline.changeStateOfCommandAndAddBuildUrl(\r\n            project,\r\n            index,\r\n            CommandState.Failed,\r\n            Pipeline.STATE_FAILED,\r\n            href\r\n        )\r\n        return CommandState.Failed\r\n    }\r\n\r\n    private fun quietSave(paramObject: ParamObject, verbose: Boolean = false): Promise<Unit> {\r\n        return menu.save(paramObject.jobExecutor, verbose)\r\n            .then { hadChanges ->\r\n                if (!hadChanges) {\r\n                    showWarning(\r\n                        \"Could not save changes for project ${paramObject.project.id.identifier}.\" +\r\n                            \"\\nPlease report a bug: $GITHUB_NEW_ISSUE\"\r\n                    )\r\n                }\r\n            }.catch {\r\n                console.error(\"save failed for ${paramObject.project}\", it)\r\n                // we ignore if a save fails at this point,\r\n                // the next command performs a save as well and we track if the final save fails\r\n            }\r\n    }\r\n\r\n    companion object {\r\n        const val POLL_EVERY_SECOND = 5\r\n        const val MAX_WAIT_FOR_COMPLETION = 60 * 15\r\n    }\r\n\r\n    private data class ParamObject(\r\n        val releasePlan: ReleasePlan,\r\n        val jobExecutor: JobExecutor,\r\n        val jobExecutionDataFactory: JobExecutionDataFactory,\r\n        val project: Project,\r\n        private val locks: HashMap<ProjectId, Promise<*>>,\r\n        val projectResults: HashMap<ProjectId, CommandState>\r\n    ) {\r\n\r\n        constructor(paramObject: ParamObject, newProjectId: ProjectId)\r\n            : this(paramObject, paramObject.releasePlan.getProject(newProjectId))\r\n\r\n        constructor(paramObject: ParamObject, newProject: Project)\r\n            : this(\r\n            paramObject.releasePlan,\r\n            paramObject.jobExecutor,\r\n            paramObject.jobExecutionDataFactory,\r\n            newProject,\r\n            paramObject.locks,\r\n            paramObject.projectResults\r\n        )\r\n\r\n        fun <T> withLockForProject(act: () -> Promise<T>): Promise<T> {\r\n            val projectId = project.id\r\n            val lock = locks[projectId]\r\n            return if (lock == null) {\r\n                val promise = act()\r\n                locks[projectId] = promise\r\n                promise.then { result ->\r\n                    locks.remove(projectId)\r\n                    result\r\n                }\r\n            } else {\r\n                lock.then { withLockForProject(act) }.unwrapPromise()\r\n            }\r\n        }\r\n    }\r\n\r\n    private object ReleaseFailure : RuntimeException()\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) count++\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.math.floor\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n@library(\"arrayToString\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun arrayToString(array: Array<*>): String = definedExternally\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = rand(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\nprivate fun rand(upperBound: Int) = floor(kotlin.js.Math.random() * upperBound).toInt()\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n\n    array.asDynamic().sort(comparator.asDynamic().compare.bind(comparator))\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.coroutines.experimental.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, { it.iterator() })\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence of [IndexedValue] for each element of the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return buildSequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T = checkNotNull(value) { \"Required value was null.\" }\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package ch.loewenfels.depgraph.gui\r\n\r\nimport org.w3c.dom.HTMLElement\r\nimport org.w3c.dom.HTMLInputElement\r\nimport kotlin.browser.document\r\n\r\nfun elementById(id: String): HTMLElement = elementById<HTMLElement>(id)\r\n\r\ninline fun <reified T : HTMLElement> elementById(id: String): T = elementByIdOrNull(id)\r\n    ?: throw IllegalStateException(\"no element found for id $id (expected type ${T::class.js.name})\")\r\n\r\ninline fun <reified T : HTMLElement> elementByIdOrNull(id: String): T? {\r\n    val element = document.getElementById(id) ?: return null\r\n    require(element is T) {\r\n        \"element with $id found but was wrong type.<br/>Expected type ${T::class.js.name}<br/>Found $element\"\r\n    }\r\n    return element as T\r\n}\r\n\r\nfun display(id: String, what: String) {\r\n    elementById(id).style.display = what\r\n}\r\n\r\nfun getCheckbox(id: String): HTMLInputElement\r\n    = getCheckboxOrNull(id) ?: throw IllegalStateException(\"no checkbox found for id $id\")\r\n\r\nfun getCheckboxOrNull(id: String) = getInputElementOrNull(id, \"checkbox\")\r\n\r\nfun getTextField(id: String): HTMLInputElement\r\n    = getTextFieldOrNull(id) ?: throw IllegalStateException(\"no text field found for id $id\")\r\n\r\nfun getTextFieldOrNull(id: String) = getInputElementOrNull(id, \"text\")\r\n\r\nfun getInputElementOrNull(id: String, type: String): HTMLInputElement? {\r\n    val element = elementByIdOrNull<HTMLInputElement>(id) ?: return null\r\n    require(element.type == type) {\r\n        \"$id was either not an input element or did not have type $type: $element\"\r\n    }\r\n    return element\r\n}\r\n","package ch.loewenfels.depgraph.gui\r\n\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.gui.actions.Downloader\r\nimport ch.loewenfels.depgraph.gui.actions.Publisher\r\nimport ch.loewenfels.depgraph.gui.actions.Releaser\r\nimport ch.loewenfels.depgraph.gui.components.Loader\r\nimport ch.loewenfels.depgraph.gui.components.Menu\r\nimport ch.loewenfels.depgraph.gui.jobexecution.*\r\nimport ch.loewenfels.depgraph.gui.recovery.recover\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.parseRemoteRegex\r\nimport org.w3c.fetch.Response\r\nimport kotlin.browser.window\r\nimport kotlin.js.*\r\n\r\nclass App {\r\n    private val publishJobUrl: String?\r\n    private val defaultJenkinsBaseUrl: String?\r\n    private val menu: Menu\r\n\r\n    init {\r\n        Loader.updateLoaderToLoadApiToken()\r\n\r\n        val jsonUrl = determineJsonUrlOrThrow()\r\n        publishJobUrl = determinePublishJob()\r\n        defaultJenkinsBaseUrl = publishJobUrl?.substringBefore(\"/job/\")\r\n        menu = Menu(UsernameTokenRegistry, defaultJenkinsBaseUrl)\r\n        start(jsonUrl)\r\n    }\r\n\r\n    private fun determinePublishJob(): String? {\r\n        return if (window.location.hash.contains(PUBLISH_JOB)) {\r\n            getJobUrl(window.location.hash.substringAfter(PUBLISH_JOB))\r\n        } else {\r\n            null\r\n        }\r\n    }\r\n\r\n    private fun getJobUrl(possiblyRelativePublishJobUrl: String): String {\r\n        require(!possiblyRelativePublishJobUrl.contains(\"://\") || possiblyRelativePublishJobUrl.startsWith(\"http\")) {\r\n            \"The publish job URL does not start with http but contains ://\"\r\n        }\r\n\r\n        val prefix = window.location.protocol + \"//\" + window.location.hostname + \"/\"\r\n        val tmpUrl = if (possiblyRelativePublishJobUrl.contains(\"://\")) {\r\n            possiblyRelativePublishJobUrl\r\n        } else {\r\n            prefix + possiblyRelativePublishJobUrl\r\n        }\r\n        return if (tmpUrl.endsWith(\"/\")) tmpUrl else \"$tmpUrl/\"\r\n    }\r\n\r\n    private fun start(jsonUrl: String) {\r\n        retrieveUserAndApiToken().then { usernameAndApiToken ->\r\n            display(\"gui\", \"block\")\r\n            Loader.updateToLoadingJson()\r\n\r\n            loadJsonAndCheckStatus(jsonUrl, usernameAndApiToken)\r\n                .then { (_, body) ->\r\n                    val modifiableState = ModifiableState(defaultJenkinsBaseUrl, body)\r\n                    val releasePlan = modifiableState.releasePlan\r\n                    val promise = if (usernameAndApiToken != null) {\r\n                        Loader.updateToLoadOtherTokens()\r\n                        loadOtherApiTokens(releasePlan)\r\n                    } else {\r\n                        Promise.resolve(Unit)\r\n                    }\r\n                    promise.then { modifiableState }\r\n                }.then { modifiableState ->\r\n                    val promise = if (modifiableState.releasePlan.state == ReleaseState.IN_PROGRESS) {\r\n                        Loader.updateToRecoverOngoingProcess()\r\n                        recover(modifiableState, defaultJenkinsBaseUrl)\r\n                    } else {\r\n                        Promise.resolve(modifiableState)\r\n                    }\r\n                    promise\r\n                }.then { modifiableState ->\r\n                    Loader.updateToLoadPipeline()\r\n                    ContentContainer(modifiableState, menu)\r\n                    val dependencies = createDependencies(\r\n                        defaultJenkinsBaseUrl, publishJobUrl, modifiableState, menu\r\n                    )\r\n                    menu.initDependencies(Downloader(modifiableState), dependencies, modifiableState)\r\n                    switchLoaderWithPipeline()\r\n                }\r\n                .catch {\r\n                    showThrowableAndThrow(it)\r\n                }\r\n        }\r\n    }\r\n\r\n    private fun loadOtherApiTokens(releasePlan: ReleasePlan): Promise<*> {\r\n        val remoteRegex = parseRemoteRegex(releasePlan)\r\n        val mutableList = ArrayList<Promise<*>>(remoteRegex.size)\r\n\r\n        remoteRegex.forEach { (_, remoteJenkinsBaseUrl) ->\r\n            val promise = if (isUrlAndNotYetRegistered(remoteJenkinsBaseUrl)) {\r\n                UsernameTokenRegistry.register(remoteJenkinsBaseUrl).then { pair ->\r\n                    updateUserToolTip(remoteJenkinsBaseUrl, pair)\r\n                    if (pair == null) {\r\n                        menu.setHalfVerified(defaultJenkinsBaseUrl, remoteJenkinsBaseUrl)\r\n                    }\r\n                }\r\n            } else {\r\n                Promise.resolve(Unit)\r\n            }\r\n            mutableList.add(promise)\r\n        }\r\n        return Promise.all(mutableList.toTypedArray())\r\n    }\r\n\r\n    private fun isUrlAndNotYetRegistered(remoteJenkinsBaseUrl: String) =\r\n        remoteJenkinsBaseUrl.startsWith(\"http\") && UsernameTokenRegistry.forHost(remoteJenkinsBaseUrl) == null\r\n\r\n    private fun retrieveUserAndApiToken(): Promise<UsernameAndApiToken?> {\r\n        return if (defaultJenkinsBaseUrl == null) {\r\n            menu.disableButtonsDueToNoPublishUrl()\r\n            Promise.resolve(null as UsernameAndApiToken?)\r\n        } else {\r\n            UsernameTokenRegistry.register(defaultJenkinsBaseUrl).then { pair ->\r\n                if (pair == null) {\r\n                    val info = \"You need to log in if you want to use other functionality than Download.\"\r\n                    menu.disableButtonsDueToNoAuth(info, \"$info\\n$defaultJenkinsBaseUrl/login?from=\" + window.location)\r\n                    null\r\n                } else {\r\n                    val (name, usernameToken) = pair\r\n                    menu.setVerifiedUser(name)\r\n                    updateUserToolTip(defaultJenkinsBaseUrl, pair)\r\n                    usernameToken\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun updateUserToolTip(url: String, pair: Pair<String, UsernameAndApiToken>?) {\r\n        menu.appendToUserButtonToolTip(url, pair?.second?.username ?: \"Anonymous\", pair?.first)\r\n    }\r\n\r\n    private fun switchLoaderWithPipeline() {\r\n        display(\"loader\", \"none\")\r\n        display(\"pipeline\", \"table\")\r\n    }\r\n\r\n\r\n    companion object {\r\n        const val PUBLISH_JOB = \"&publishJob=\"\r\n\r\n        fun determineJsonUrlOrThrow(): String {\r\n            return determineJsonUrl() ?: showThrowableAndThrow(\r\n                IllegalStateException(\r\n                    \"You need to specify a release.json.\" +\r\n                        \"\\nAppend the path with preceding # to the url, e.g., ${window.location}#release.json\"\r\n                )\r\n            )\r\n        }\r\n\r\n\r\n        fun determineJsonUrl(): String? {\r\n            return if (window.location.hash != \"\") {\r\n                window.location.hash.substring(1).substringBefore(\"&\")\r\n            } else {\r\n                null\r\n            }\r\n        }\r\n\r\n        fun loadJsonAndCheckStatus(\r\n            jsonUrl: String,\r\n            usernameAndApiToken: UsernameAndApiToken?\r\n        ): Promise<Pair<Response, String>> {\r\n            return loadJson(jsonUrl, usernameAndApiToken)\r\n                .then(::checkStatusOk)\r\n                .catch<Pair<Response, String>> {\r\n                    throw Error(\"Could not load json from url $jsonUrl.\", it)\r\n                }\r\n        }\r\n\r\n        private fun loadJson(jsonUrl: String, usernameAndApiToken: UsernameAndApiToken?): Promise<Response> {\r\n            val init = createFetchInitWithCredentials()\r\n            val headers = js(\"({})\")\r\n            // if &publishJob is not specified, then we don't have usernameAndApiToken but we can still\r\n            // load the json and display it as pipeline\r\n            if (usernameAndApiToken != null) {\r\n                addAuthentication(headers, usernameAndApiToken)\r\n            }\r\n            init.headers = headers\r\n            return window.fetch(jsonUrl, init)\r\n        }\r\n\r\n        internal fun createDependencies(\r\n            defaultJenkinsBaseUrl: String?,\r\n            publishJobUrl: String?,\r\n            modifiableState: ModifiableState,\r\n            menu: Menu\r\n        ): Menu.Dependencies? {\r\n            return if (publishJobUrl != null && defaultJenkinsBaseUrl != null) {\r\n                val publisher = Publisher(publishJobUrl, modifiableState)\r\n                val releaser = Releaser(defaultJenkinsBaseUrl, modifiableState, menu)\r\n\r\n                val jenkinsJobExecutor = JenkinsJobExecutor(UsernameTokenRegistry)\r\n                val simulatingJobExecutor = SimulatingJobExecutor()\r\n                Menu.Dependencies(\r\n                    publisher,\r\n                    releaser,\r\n                    jenkinsJobExecutor,\r\n                    simulatingJobExecutor\r\n                )\r\n            } else {\r\n                null\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    return String(chars.copyOfRange(offset, offset + length))\n}\n\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@Deprecated(\"Use length property instead.\", ReplaceWith(\"length\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline val CharSequence.size: Int get() = length\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n",null,"package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.CommandState\r\nimport ch.loewenfels.depgraph.data.Project\r\nimport ch.loewenfels.depgraph.data.ReleaseCommand\r\nimport ch.loewenfels.depgraph.data.ReleaseState\r\nimport ch.loewenfels.depgraph.generateGitCloneCommands\r\nimport ch.loewenfels.depgraph.gui.*\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.tutteli.kbox.forEachIn\r\nimport ch.tutteli.kbox.mapWithIndex\r\nimport kotlinx.html.*\r\nimport org.w3c.dom.HTMLAnchorElement\r\nimport org.w3c.dom.HTMLElement\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.dom.asList\r\nimport org.w3c.dom.events.Event\r\nimport org.w3c.dom.events.MouseEvent\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.hasClass\r\nimport kotlin.dom.removeClass\r\nimport kotlin.reflect.KClass\r\n\r\nclass ContextMenu(private val modifiableState: ModifiableState, private val menu: Menu) {\r\n\r\n    fun createProjectContextMenu(div: DIV, project: Project) {\r\n        div.div(\"contextMenu\") {\r\n            val idPrefix = project.id.identifier\r\n            id = \"$idPrefix$CONTEXT_MENU_SUFFIX\"\r\n            contextMenuEntry(idPrefix, \"gitClone\", \"Git clone\", \"Show the git clone command for this project\",\r\n                iconCreator = { i(\"material-icons char\") { +\"G\" } }\r\n            ) {\r\n                val releasePlan = modifiableState.releasePlan\r\n                val gitCloneCommand = generateGitCloneCommands(\r\n                    sequenceOf(project),\r\n                    Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_EXCLUDE_PROJECT_REGEX)),\r\n                    Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REGEX)),\r\n                    releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REPLACEMENT)\r\n                )\r\n                showOutput(\"git clone command\", gitCloneCommand)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun createCommandContextMenu(div: DIV, idPrefix: String, project: Project, index: Int) {\r\n        div.div(\"contextMenu\") {\r\n            id = \"$idPrefix$CONTEXT_MENU_SUFFIX\"\r\n            commandContextMenuEntry(idPrefix, CONTEXT_MENU_COMMAND_DEACTIVATED, CommandState.Deactivated::class) {\r\n                transitionToDeactivatedIfOk(project, index)\r\n            }\r\n            commandContextMenuEntry(idPrefix, CONTEXT_MENU_COMMAND_SUCCEEDED, CommandState.Succeeded::class) {\r\n                transitionToSucceededIfOk(project, index)\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private fun DIV.commandContextMenuEntry(\r\n        idPrefix: String,\r\n        cssClass: String,\r\n        commandClass: KClass<out CommandState>,\r\n        action: (Event) -> Unit\r\n    ) = contextMenuEntry(\r\n        idPrefix, cssClass,\r\n        text = \"Set Command to ${commandClass.simpleName}\",\r\n        title = \"Forcibly sets the state of this command to ${commandClass.simpleName}, to be used with care.\",\r\n        iconCreator = { i(\"material-icons\") { span() /* done via css */ } },\r\n        action = action\r\n    )\r\n\r\n    private fun DIV.contextMenuEntry(\r\n        idPrefix: String,\r\n        cssClass: String,\r\n        text: String,\r\n        title: String,\r\n        iconCreator: DIV.() -> Unit,\r\n        action: (Event) -> Unit\r\n    ) {\r\n        div(cssClass) {\r\n            id = \"$idPrefix$cssClass\"\r\n            this.title = title\r\n            iconCreator()\r\n            span { +text }\r\n            val div = getUnderlyingHtmlElement()\r\n            div.addClickEventListener { e ->\r\n                if (!div.hasClass(CSS_DISABLED)) {\r\n                    action(e)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun transitionToDeactivatedIfOk(project: Project, index: Int) {\r\n        val commandState = Pipeline.getCommandState(project.id, index)\r\n        if (isNotInStateToDeactivate(commandState)) return\r\n\r\n        Pipeline.getToggle(project, index).click()\r\n    }\r\n\r\n    private fun isNotInStateToDeactivate(commandState: CommandState): Boolean {\r\n        return commandState is CommandState.Deactivated ||\r\n            commandState === CommandState.Succeeded ||\r\n            commandState === CommandState.Disabled\r\n    }\r\n\r\n    private fun transitionToSucceededIfOk(project: Project, index: Int) {\r\n        if (project.commands[index] is ReleaseCommand) {\r\n            if (notAllOtherCommandsSucceeded(project, index)) {\r\n                val succeeded = CommandState.Succeeded::class.simpleName\r\n                showDialog(\r\n                    \"You cannot set this command to the state $succeeded because not all other commands of this project have $succeeded yet.\" +\r\n                        \"\\n\\n\" +\r\n                        \"Do you want to set all other commands forcibly to $succeeded as well?\"\r\n                ).then { setAllToSucceeded ->\r\n                    if (setAllToSucceeded) {\r\n                        transitionAllCommandsToSucceeded(project)\r\n                        menu.activateSaveButton()\r\n                    }\r\n                }\r\n                return\r\n            }\r\n        }\r\n        transitionToSucceeded(project, index)\r\n        menu.activateSaveButton()\r\n    }\r\n\r\n    private fun transitionAllCommandsToSucceeded(project: Project) {\r\n        project.commands.forEachIndexed { index, _ ->\r\n            transitionToSucceeded(project, index)\r\n        }\r\n        val releasePlan = modifiableState.releasePlan\r\n        releasePlan.getSubmodules(project.id).forEach {\r\n            transitionAllCommandsToSucceeded(releasePlan.getProject(it))\r\n        }\r\n    }\r\n\r\n    private fun transitionToSucceeded(project: Project, index: Int) {\r\n        Pipeline.changeStateOfCommand(\r\n            project,\r\n            index,\r\n            CommandState.Succeeded,\r\n            Pipeline.stateToTitle(CommandState.Succeeded)\r\n        ) { _, _ ->\r\n            // we do not check transition here, the user has to know what she does (at least for now)\r\n            CommandState.Succeeded\r\n        }\r\n    }\r\n\r\n    private fun notAllOtherCommandsSucceeded(project: Project, index: Int?): Boolean {\r\n        return project.commands.asSequence()\r\n            .mapWithIndex()\r\n            .any { (i, _) ->\r\n                (index == null || i != index) && Pipeline.getCommandState(project.id, i) !== CommandState.Succeeded\r\n            }\r\n            || modifiableState.releasePlan.getSubmodules(project.id)\r\n            .any { notAllOtherCommandsSucceeded(modifiableState.releasePlan.getProject(it), null) }\r\n    }\r\n\r\n    fun setUpOnContextMenuForProjectsAndCommands() {\r\n        val projects = document.querySelectorAll(\".project\")\r\n            .asList()\r\n            .map { project ->\r\n                Triple(project, (project as HTMLElement).id, { _: String -> })\r\n            }\r\n        val toggleLabels = document.querySelectorAll(\".command > .fields > .toggle\")\r\n            .asList()\r\n            .map { label ->\r\n                val toggle = label.firstChild as HTMLInputElement\r\n                val idPrefix = toggle.id.substringBefore(Pipeline.DEACTIVATE_SUFFIX)\r\n                Triple(label, idPrefix, ::disableCommandContextEntriesIfNecessary)\r\n            }\r\n        val stateIcons = document.querySelectorAll(\".state\")\r\n            .asList()\r\n            .map { aNode ->\r\n                val a = aNode as HTMLAnchorElement\r\n                val idPrefix = a.id.substringBefore(Pipeline.STATE_SUFFIX)\r\n                Triple(a, idPrefix, ::disableCommandContextEntriesIfNecessary)\r\n            }\r\n        forEachIn(projects, toggleLabels, stateIcons) { (element, idPrefix, disableContextEntriesIfNecessary) ->\r\n            element.addEventListener(\"contextmenu\", { event ->\r\n                hideAllContextMenus()\r\n                disableContextEntriesIfNecessary(idPrefix)\r\n                val contextMenu = elementById(\"$idPrefix$CONTEXT_MENU_SUFFIX\")\r\n                moveContextMenuPosition(event as MouseEvent, contextMenu)\r\n                contextMenu.style.visibility = \"visible\"\r\n                window.addEventListener(\"click\", { hideAllContextMenus() }, js(\"({once: true})\"))\r\n                event.preventDefault()\r\n                event.stopPropagation()\r\n            })\r\n        }\r\n        window.addEventListener(\"contextmenu\", { hideAllContextMenus() })\r\n    }\r\n\r\n    private fun disableCommandContextEntriesIfNecessary(idPrefix: String) {\r\n        val state = Pipeline.getReleaseState()\r\n        val commandState = Pipeline.getCommandState(idPrefix)\r\n        disableOrEnableContextMenuEntry(\r\n            \"$idPrefix$CONTEXT_MENU_COMMAND_DEACTIVATED\",\r\n            state == ReleaseState.IN_PROGRESS ||\r\n                state == ReleaseState.WATCHING ||\r\n                isNotInStateToDeactivate(commandState)\r\n        )\r\n        disableOrEnableContextMenuEntry(\r\n            \"$idPrefix$CONTEXT_MENU_COMMAND_SUCCEEDED\",\r\n            state == ReleaseState.IN_PROGRESS ||\r\n                state == ReleaseState.WATCHING ||\r\n                commandState === CommandState.Succeeded\r\n        )\r\n    }\r\n\r\n    private fun disableOrEnableContextMenuEntry(id: String, disable: Boolean) {\r\n        val entry = elementById(id)\r\n        if (disable) {\r\n            entry.setTitleSaveOld(\"Cannot apply this action.\")\r\n            entry.addClass(CSS_DISABLED)\r\n\r\n        } else {\r\n            val title = entry.getOldTitleOrNull()\r\n            if (title != null) {\r\n                entry.title = title\r\n            }\r\n            entry.removeClass(CSS_DISABLED)\r\n        }\r\n    }\r\n\r\n    private fun hideAllContextMenus() {\r\n        document.querySelectorAll(\".contextMenu\").asList().forEach {\r\n            (it as HTMLElement).style.visibility = \"hidden\"\r\n        }\r\n    }\r\n\r\n    private fun moveContextMenuPosition(event: MouseEvent, contextMenu: HTMLElement) {\r\n        val menuWidth = contextMenu.offsetWidth\r\n        val menuHeight = contextMenu.offsetHeight\r\n        val mouseX = event.pageX\r\n        val mouseY = event.pageY\r\n\r\n        val x = if (mouseX + menuWidth > document.body!!.clientWidth + window.scrollX) {\r\n            mouseX - menuWidth\r\n        } else {\r\n            mouseX\r\n        }\r\n        val y = if (mouseY + menuHeight > document.body!!.clientHeight + window.scrollY) {\r\n            mouseY - menuHeight\r\n        } else {\r\n            mouseY\r\n        }\r\n        contextMenu.style.left = \"${x}px\"\r\n        contextMenu.style.top = \"${y}px\"\r\n    }\r\n\r\n    companion object {\r\n        const val CONTEXT_MENU_SUFFIX = \":contextMenu\"\r\n        const val CONTEXT_MENU_COMMAND_DEACTIVATED = \"deactivated\"\r\n        const val CONTEXT_MENU_COMMAND_SUCCEEDED = \"succeeded\"\r\n        const val CSS_DISABLED = \"disabled\"\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.gui.getUnderlyingHtmlElement\r\nimport kotlinx.html.*\r\nimport kotlinx.html.js.onKeyUpFunction\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.dom.HTMLTextAreaElement\r\n\r\nfun DIV.textFieldWithLabel(id: String, label: String, value: String, menu: Menu) {\r\n    textFieldWithLabel(id, label, value, menu, {})\r\n}\r\n\r\nfun DIV.textFieldReadOnlyWithLabel(\r\n    id: String,\r\n    label: String,\r\n    value: String,\r\n    menu: Menu,\r\n    inputAct: INPUT.() -> Unit = {}\r\n) {\r\n    textFieldWithLabel(id, label, value, menu) { readonly = true; inputAct() }\r\n}\r\n\r\nfun DIV.textFieldWithLabel(id: String, label: String, value: String, menu: Menu, inputAct: INPUT.() -> Unit) {\r\n    div {\r\n        label(\"fields\") {\r\n            htmlFor = id\r\n            +label\r\n        }\r\n        textInput {\r\n            this.id = id\r\n            this.value = value\r\n            inputAct()\r\n            onKeyUpFunction = { menu.activateSaveButton() }\r\n            val input = getUnderlyingHtmlElement() as HTMLInputElement\r\n            Menu.disableUnDisableForProcessStartAndEnd(input, input)\r\n            Menu.unDisableForProcessContinueAndReset(input, input)\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfun DIV.textAreaWithLabel(id: String, label: String, value: String, menu: Menu) {\r\n    div {\r\n        label(\"fields\") {\r\n            htmlFor = id\r\n            +label\r\n        }\r\n        textArea {\r\n            this.id = id\r\n            +value\r\n            onKeyUpFunction = { menu.activateSaveButton() }\r\n            val htmlTextAreaElement = getUnderlyingHtmlElement() as HTMLTextAreaElement\r\n            //for what disableUnDisableForProcessStartAndEnd needs, title and disabled, it is ok to make the unsafe cast\r\n            //TODO change in case https://github.com/Kotlin/kotlinx.html/issues/87 is implemented\r\n            val input = htmlTextAreaElement.unsafeCast<HTMLInputElement>()\r\n            Menu.disableUnDisableForProcessStartAndEnd(input, htmlTextAreaElement)\r\n            Menu.unDisableForProcessContinueAndReset(input, htmlTextAreaElement)\r\n        }\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.gui.elementById\r\nimport kotlinx.html.DIV\r\nimport kotlinx.html.br\r\nimport kotlinx.html.code\r\nimport kotlinx.html.dom.append\r\nimport kotlinx.html.js.div\r\nimport kotlinx.html.js.i\r\nimport kotlinx.html.js.p\r\nimport kotlinx.html.js.span\r\nimport kotlinx.html.p\r\nimport org.w3c.dom.HTMLElement\r\nimport org.w3c.dom.asList\r\nimport kotlin.dom.removeClass\r\n\r\nobject Loader {\r\n\r\n    init{\r\n        val loader = elementById(\"loader\")\r\n        loader.childNodes.asList().forEach {\r\n            if (it.nodeType == 3.toShort()) {\r\n                loader.removeChild(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun updateLoaderToLoadApiToken() {\r\n        updateLoader(\"Retrieving API Token\") {\r\n            p {\r\n                +\"If you keep seeing this after a few seconds, then either an error occurred (see bottom of the page) and if not then most probably CORS was not successful and a request was blocked by the server.\"\r\n                br\r\n                +\"You can verify it by opening the developer console(F12 in many browsers)\"\r\n            }\r\n            p {\r\n                +\"In case you only want to see the resulting pipeline without release functionality, then please remove \"\r\n                code { +\"&publishUrl = ...\" }\r\n                +\"from the current URL.\"\r\n            }\r\n        }\r\n    }\r\n\r\n    fun updateToLoadingJson() {\r\n        updateLoader(\"Loading release.json\") {\r\n            getDefaultLoadingMessage()\r\n        }\r\n    }\r\n\r\n\r\n    fun updateToLoadOtherTokens() {\r\n        updateLoader(\"Loading other API Tokens (from remote Jenkins servers)\") {\r\n            getDefaultLoadingMessage()\r\n        }\r\n    }\r\n\r\n    fun updateToRecoverOngoingProcess() {\r\n        updateLoader(\"Recovering ongoing process\") {\r\n            p { +\"Should disappear after half a minute or so; otherwise most likely an error occurred (see bottom of the page).\" }\r\n        }\r\n    }\r\n\r\n    fun updateToLoadPipeline() {\r\n        updateLoader(\"Loading Pipeline\") {\r\n            getDefaultLoadingMessage()\r\n        }\r\n    }\r\n\r\n    private fun DIV.getDefaultLoadingMessage() {\r\n        p {\r\n            +\"Should disappear after a few seconds; otherwise either an error occurred (see bottom of the page) and if not then most likely the request silently failed.\"\r\n            br\r\n            +\"You can verify it by opening the developer console (F12 in many browsers)\"\r\n        }\r\n    }\r\n\r\n    private fun updateLoader(newItem: String, divContent: DIV.() -> Unit) {\r\n        val loader = elementById(\"loader\")\r\n        loader.removeChild(loader.lastChild!!)\r\n        val lastItem = loader.lastChild!!\r\n        val icon = lastItem.firstChild as HTMLElement\r\n        icon.removeClass(\"waiting\")\r\n        icon.innerText = \"check_box\"\r\n        val text = lastItem.lastChild as HTMLElement\r\n        text.innerText = text.innerText.substringBefore(\"...\") + \" successful\"\r\n        loader.append {\r\n            p {\r\n                i(\"material-icons waiting\") { +\"check_box_outline_blank\" }\r\n                span { +newItem; +\"...\" }\r\n            }\r\n            div { divContent() }\r\n        }\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.generateEclipsePsf\r\nimport ch.loewenfels.depgraph.generateGitCloneCommands\r\nimport ch.loewenfels.depgraph.generateListOfDependentsWithoutSubmoduleAndExcluded\r\nimport ch.loewenfels.depgraph.gui.*\r\nimport ch.loewenfels.depgraph.gui.ContentContainer.Companion.RELEASE_ID_HTML_ID\r\nimport ch.loewenfels.depgraph.gui.actions.Downloader\r\nimport ch.loewenfels.depgraph.gui.actions.Publisher\r\nimport ch.loewenfels.depgraph.gui.actions.Releaser\r\nimport ch.loewenfels.depgraph.gui.components.Pipeline.Companion.stateToTitle\r\nimport ch.loewenfels.depgraph.gui.jobexecution.*\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.gui.serialization.deserialize\r\nimport ch.tutteli.kbox.mapWithIndex\r\nimport org.w3c.dom.CustomEvent\r\nimport org.w3c.dom.CustomEventInit\r\nimport org.w3c.dom.HTMLElement\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.dom.events.Event\r\nimport kotlin.browser.window\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.hasClass\r\nimport kotlin.dom.removeClass\r\nimport kotlin.js.Promise\r\n\r\nexternal fun encodeURIComponent(encodedURI: String): String\r\n\r\nclass Menu(\r\n    private val usernameTokenRegistry: UsernameTokenRegistry,\r\n    private val defaultJenkinsBaseUrl: String?\r\n) {\r\n    private var publisher: Publisher? = null\r\n\r\n    init {\r\n        setUpMenuLayers(\r\n            Triple(toolsButton, \"toolbox\", TOOLS_INACTIVE_TITLE to \"Close the toolbox.\"),\r\n            Triple(settingsButton, \"config\", SETTINGS_INACTIVE_TITLE to \"Close Settings.\")\r\n        )\r\n    }\r\n\r\n    private fun setUpMenuLayers(vararg pairs: Triple<HTMLElement, String, Pair<String, String>>) {\r\n        pairs.forEach { (button, id, inactiveAndActiveTitle) ->\r\n            button.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n                //close the others\r\n                pairs.forEach { (_, otherId) ->\r\n                    if (id != otherId) {\r\n                        elementById(otherId).removeClass(\"active\")\r\n                    }\r\n                }\r\n\r\n                val layer = elementById(id)\r\n                if (layer.hasClass(\"active\")) {\r\n                    button.title = inactiveAndActiveTitle.first\r\n                } else {\r\n                    button.title = inactiveAndActiveTitle.second\r\n                }\r\n                layer.toggleClass(\"active\")\r\n            }\r\n            elementById(\"$id:close\").addClickEventListener {\r\n                elementById(id).removeClass(\"active\")\r\n            }\r\n        }\r\n    }\r\n\r\n    fun disableButtonsDueToNoPublishUrl() {\r\n        val titleButtons =\r\n            \"You need to specify &publishJob if you want to use other functionality than Download and Explore Release Order.\"\r\n        disableButtonsDueToNoAuth(\r\n            titleButtons, titleButtons +\r\n                \"\\nAn example: ${window.location}&publishJob=jobUrl\" +\r\n                \"\\nwhere you need to replace jobUrl accordingly.\"\r\n        )\r\n    }\r\n\r\n    fun disableButtonsDueToNoAuth(titleButtons: String, info: String) {\r\n        showInfo(info)\r\n        userButton.title = titleButtons\r\n        userButton.addClass(DEACTIVATED)\r\n        userName.innerText = \"Anonymous\"\r\n        userIcon.innerText = \"error\"\r\n        listOf(saveButton, dryRunButton, releaseButton).forEach { it.disable(titleButtons) }\r\n    }\r\n\r\n    fun setVerifiedUser(name: String) {\r\n        userName.innerText = name\r\n        userIcon.innerText = \"verified_user\"\r\n        userButton.removeClass(DEACTIVATED)\r\n    }\r\n\r\n    fun setHalfVerified(defaultJenkinsBaseUrl: String?, remoteJenkinsBaseUrl: String) {\r\n        if (!userButton.hasClass(DEACTIVATED)) {\r\n            userIcon.innerText = \"error\"\r\n            userButton.addClass(\"warning\")\r\n            showWarning(\r\n                \"You are not logged in at $remoteJenkinsBaseUrl.\\n\" +\r\n                    \"You can perform a Dry Run (runs on $defaultJenkinsBaseUrl) but a release involving the remote jenkins will most likely fail.\\n\\n\" +\r\n                    \"Go to the log in: $remoteJenkinsBaseUrl/login?from=\" + window.location\r\n            )\r\n        }\r\n    }\r\n\r\n    fun appendToUserButtonToolTip(url: String, username: String, name: String?) {\r\n        val nameSuffix = if (name != null) \" ($name)\" else \"\"\r\n        userButton.title += \"\\nLogged in as $username$nameSuffix @ $url\"\r\n    }\r\n\r\n    internal fun initDependencies(\r\n        downloader: Downloader,\r\n        dependencies: Dependencies?,\r\n        modifiableState: ModifiableState\r\n    ) {\r\n        Companion.modifiableState = modifiableState\r\n        if (dependencies != null) {\r\n            publisher = dependencies.publisher\r\n        }\r\n\r\n        window.onbeforeunload = {\r\n            if (!saveButton.hasClass(DEACTIVATED)) {\r\n                \"Your changes will be lost, sure you want to leave the page?\"\r\n            } else if (Pipeline.getReleaseState() === ReleaseState.IN_PROGRESS) {\r\n                \"You might lose state changes if you navigate away from this page, sure you want to proceed?\"\r\n            } else {\r\n                null\r\n            }\r\n        }\r\n\r\n        initSaveAndDownloadButton(downloader, dependencies)\r\n        initRunButtons(dependencies, modifiableState)\r\n        activateToolsButton()\r\n        activateSettingsButton()\r\n        initStartOverButton(dependencies)\r\n        initExportButtons(modifiableState)\r\n\r\n        val releasePlan = modifiableState.releasePlan\r\n        return when (releasePlan.state) {\r\n            ReleaseState.READY -> Unit /* nothing to do */\r\n            ReleaseState.IN_PROGRESS -> restartProcess(modifiableState, dependencies)\r\n            ReleaseState.FAILED, ReleaseState.SUCCEEDED -> {\r\n                dispatchProcessStart()\r\n                dispatchProcessEnd(success = releasePlan.state == ReleaseState.SUCCEEDED)\r\n            }\r\n            ReleaseState.WATCHING -> dispatchProcessStart()\r\n        }\r\n    }\r\n\r\n    private fun restartProcess(modifiableState: ModifiableState, dependencies: Dependencies?) {\r\n        if (dependencies != null) {\r\n            when (modifiableState.releasePlan.typeOfRun) {\r\n                TypeOfRun.EXPLORE -> startExploration(modifiableState, dependencies)\r\n                TypeOfRun.DRY_RUN -> startDryRun(modifiableState, dependencies)\r\n                TypeOfRun.RELEASE -> startRelease(modifiableState, dependencies)\r\n            }\r\n        } else if (modifiableState.releasePlan.typeOfRun == TypeOfRun.EXPLORE) {\r\n            startExploration(modifiableState, null)\r\n        }\r\n    }\r\n\r\n    private fun initSaveAndDownloadButton(downloader: Downloader, dependencies: Dependencies?) {\r\n        deactivateSaveButton()\r\n        if (dependencies != null) {\r\n            saveButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n                save(dependencies.jenkinsJobExecutor, verbose = true).then {\r\n                    deactivateSaveButton()\r\n                }\r\n            }\r\n        }\r\n        downloadButton.title = \"Download the release.json\"\r\n        downloadButton.removeClass(DEACTIVATED)\r\n        downloadButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n            downloader.download()\r\n        }\r\n    }\r\n\r\n    private fun initRunButtons(dependencies: Dependencies?, modifiableState: ModifiableState) {\r\n        if (dependencies != null) {\r\n\r\n            activateDryRunButton()\r\n            dryRunButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n                startDryRun(modifiableState, dependencies)\r\n            }\r\n            activateReleaseButton()\r\n            releaseButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n                startRelease(modifiableState, dependencies)\r\n            }\r\n        }\r\n\r\n        activateExploreButton()\r\n        exploreButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n            startExploration(modifiableState, dependencies)\r\n        }\r\n\r\n        registerForProcessStartEvent {\r\n            listOf(dryRunButton, releaseButton, exploreButton).forEach {\r\n                it.addClass(DISABLED)\r\n                it.title = getDisabledMessage()\r\n            }\r\n        }\r\n        registerForProcessEndEvent { success ->\r\n            val (processName, button, buttonText) = getCurrentRunData()\r\n            button.removeClass(DISABLED)\r\n\r\n            if (success) {\r\n                listOf(dryRunButton, releaseButton, exploreButton).forEach {\r\n                    if (button != releaseButton) {\r\n                        it.title =\r\n                            \"Current process is '$processName' - click on 'Start Over' to start over with a new process.\"\r\n                    } else {\r\n                        it.title = \"Release successful, use a new pipeline for a new release \" +\r\n                            \"or make changes and continue with the release process.\"\r\n                    }\r\n                }\r\n                val hintIfNotRelease = if (dependencies != null && button != releaseButton) {\r\n                    startOverButton.style.display = \"inline-block\"\r\n                    \"Click on the 'Start Over' button if you want to start over with a new process.\\n\"\r\n                } else {\r\n                    \"\"\r\n                }\r\n                showSuccess(\r\n                    \"\"\"\r\n                    |Process '$processName' ended successfully :) you can now close the window or continue with the process.\r\n                    |$hintIfNotRelease\r\n                    |Please report a bug at $GITHUB_NEW_ISSUE in case some job failed without us noticing it.\r\n                    |Do not forget to star the repository if you like dep-graph-releaser ;-) $GITHUB_REPO\r\n                    |Last but not least, you might want to visit $LOEWENFELS_URL to get to know the company pushing this project forward.\r\n                    \"\"\".trimMargin()\r\n                )\r\n                buttonText.innerText = \"Continue: $processName\"\r\n                button.title = \"Continue with the process '$processName'.\"\r\n                button.addClass(DEACTIVATED)\r\n            } else {\r\n                showError(\r\n                    \"\"\"\r\n                    |Process '$processName' ended with failure :(\r\n                    |At least one job failed. Check errors, fix them and then you can re-trigger the failed jobs, the pipeline respectively, by clicking on the release button (you might have to delete git tags and remove artifacts if they have already been created).\r\n                    |\r\n                    |Please report a bug at $GITHUB_NEW_ISSUE in case a job failed due to an error in dep-graph-releaser.\r\n                    \"\"\".trimMargin()\r\n                )\r\n                buttonText.innerText = \"Re-trigger failed Jobs\"\r\n                button.title = \"Continue with the process '$processName' by re-processing previously failed projects.\"\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun startDryRun(\r\n        modifiableState: ModifiableState,\r\n        dependencies: Dependencies\r\n    ): Promise<*> {\r\n        return triggerProcess(\r\n            modifiableState.releasePlan,\r\n            dependencies,\r\n            dependencies.jenkinsJobExecutor,\r\n            modifiableState.dryRunExecutionDataFactory,\r\n            TypeOfRun.DRY_RUN\r\n        )\r\n    }\r\n\r\n    private fun startRelease(\r\n        modifiableState: ModifiableState,\r\n        dependencies: Dependencies\r\n    ): Promise<*> {\r\n        return triggerProcess(\r\n            modifiableState.releasePlan,\r\n            dependencies,\r\n            dependencies.jenkinsJobExecutor,\r\n            modifiableState.releaseJobExecutionDataFactory,\r\n            TypeOfRun.RELEASE\r\n        )\r\n    }\r\n\r\n    private fun startExploration(\r\n        modifiableState: ModifiableState,\r\n        dependencies: Dependencies?\r\n    ): Promise<Unit> {\r\n        val fakeJenkinsBaseUrl = \"https://github.com/loewenfels/\"\r\n        val nonNullDependencies = dependencies ?: App.createDependencies(\r\n            fakeJenkinsBaseUrl,\r\n            \"${fakeJenkinsBaseUrl}dgr-publisher/\",\r\n            modifiableState,\r\n            this\r\n        )!!\r\n        publisher = nonNullDependencies.publisher\r\n        return triggerProcess(\r\n            modifiableState.releasePlan,\r\n            nonNullDependencies,\r\n            nonNullDependencies.simulatingJobExecutor,\r\n            modifiableState.releaseJobExecutionDataFactory,\r\n            TypeOfRun.EXPLORE\r\n        ).finally {\r\n            //reset to null in case it was not defined previously\r\n            publisher = dependencies?.publisher\r\n        }\r\n    }\r\n\r\n    private fun initStartOverButton(dependencies: Dependencies?) {\r\n        if (dependencies != null) {\r\n            activateStartOverButton()\r\n            startOverButton.addClickEventListener { resetForNewProcess(dependencies) }\r\n        }\r\n    }\r\n\r\n    private fun resetForNewProcess(dependencies: Dependencies) {\r\n        val currentReleasePlan = modifiableState.releasePlan\r\n        val initialJson = currentReleasePlan.config[ConfigKey.INITIAL_RELEASE_JSON]\r\n            ?: App.determineJsonUrlOrThrow()\r\n        val usernameAndApiToken = if (defaultJenkinsBaseUrl != null) {\r\n            usernameTokenRegistry.forHost(defaultJenkinsBaseUrl)\r\n        } else {\r\n            null\r\n        }\r\n        App.loadJsonAndCheckStatus(initialJson, usernameAndApiToken).then { (_, body) ->\r\n            val initialReleasePlan = deserialize(body)\r\n            initialReleasePlan.getProjects().forEach { project ->\r\n                project.commands.forEachIndexed { index, command ->\r\n                    val newState = determineNewState(project, index, command)\r\n                    Pipeline.changeBuildUrlOfCommand(project, index, \"\")\r\n                    Pipeline.changeStateOfCommand(project, index, newState, stateToTitle(newState)) { _, _ ->\r\n                        // we do not check if the transition is allowed since we reset the command\r\n                        newState\r\n                    }\r\n                }\r\n            }\r\n            Pipeline.changeReleaseState(ReleaseState.READY)\r\n            dispatchProcessReset()\r\n            elementById<HTMLInputElement>(ContentContainer.RELEASE_ID_HTML_ID).value = randomPublishId()\r\n            resetButtons()\r\n            startOverButton.style.display = \"none\"\r\n            save(dependencies.jenkinsJobExecutor, verbose = true).then {\r\n                deactivateSaveButton()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun resetButtons() {\r\n        val (processName, _, buttonText) = getCurrentRunData()\r\n        listOf(dryRunButton, releaseButton, exploreButton).forEach {\r\n            it.removeClass(DISABLED)\r\n        }\r\n        buttonText.innerText = processName //currently it is 'Continue:...'\r\n        activateDryRunButton()\r\n        activateReleaseButton()\r\n        activateExploreButton()\r\n    }\r\n\r\n    private fun determineNewState(project: Project, index: Int, command: Command): CommandState {\r\n        val currentState = Pipeline.getCommandState(project.id, index)\r\n        return if (currentState is CommandState.Deactivated && command.state !is CommandState.Deactivated) {\r\n            CommandState.Deactivated(command.state)\r\n        } else {\r\n            command.state\r\n        }\r\n    }\r\n\r\n    private fun initExportButtons(modifiableState: ModifiableState) {\r\n        activateButton(eclipsePsfButton, \"Download an eclipse psf-file to import all projects into eclipse.\")\r\n        activateButton(gitCloneCommandsButton, \"Show git clone commands to clone the involved projects.\")\r\n        activateButton(\r\n            listDependentsButton, \"List direct and indirect dependent projects (identifiers) of the root project.\"\r\n        )\r\n\r\n        eclipsePsfButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n            val releasePlan = modifiableState.releasePlan\r\n            val psfContent = generateEclipsePsf(\r\n                releasePlan,\r\n                Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_EXCLUDE_PROJECT_REGEX)),\r\n                Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REGEX)),\r\n                releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REPLACEMENT)\r\n            )\r\n            Downloader.download(\"customImport.psf\", psfContent)\r\n        }\r\n\r\n        gitCloneCommandsButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n            val releasePlan = modifiableState.releasePlan\r\n            val gitCloneCommands = generateGitCloneCommands(\r\n                releasePlan,\r\n                Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_EXCLUDE_PROJECT_REGEX)),\r\n                Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REGEX)),\r\n                releasePlan.getConfig(ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REPLACEMENT)\r\n            )\r\n            val title = \"Copy the following git clone commands and paste them into a terminal/command prompt\"\r\n            showOutput(title, gitCloneCommands)\r\n        }\r\n\r\n        listDependentsButton.addClickEventListenerIfNotDeactivatedNorDisabled {\r\n            val releasePlan = modifiableState.releasePlan\r\n            val list = generateListOfDependentsWithoutSubmoduleAndExcluded(\r\n                releasePlan,\r\n                Regex(releasePlan.getConfig(ConfigKey.RELATIVE_PATH_EXCLUDE_PROJECT_REGEX))\r\n            )\r\n            val title = \"The following projects are (indirect) dependents of ${releasePlan.rootProjectId.identifier}\"\r\n            showOutput(title, list)\r\n        }\r\n    }\r\n\r\n    private fun triggerProcess(\r\n        releasePlan: ReleasePlan,\r\n        dependencies: Dependencies,\r\n        jobExecutor: JobExecutor,\r\n        jobExecutionDataFactory: JobExecutionDataFactory,\r\n        typeOfRun: TypeOfRun\r\n    ): Promise<*> {\r\n        if (Pipeline.getReleaseState() === ReleaseState.FAILED) {\r\n            if (typeOfRun == TypeOfRun.DRY_RUN) {\r\n                turnFailedProjectsIntoReTriggerAndReady(releasePlan)\r\n            } else {\r\n                turnFailedCommandsIntoStateReTrigger(releasePlan)\r\n            }\r\n        }\r\n        if (Pipeline.getReleaseState() === ReleaseState.SUCCEEDED) {\r\n            dispatchProcessContinue()\r\n            Pipeline.changeReleaseState(ReleaseState.READY)\r\n        }\r\n        Pipeline.changeTypeOfRun(typeOfRun)\r\n        dispatchProcessStart()\r\n        return dependencies.releaser.release(jobExecutor, jobExecutionDataFactory).then(\r\n            { result ->\r\n                dispatchProcessEnd(success = result)\r\n            },\r\n            { t ->\r\n                dispatchProcessEnd(success = false)\r\n                // the user should see this, otherwise we only display it in the dev-console.\r\n                showThrowableAndThrow(t)\r\n            }\r\n        )\r\n    }\r\n\r\n    private fun turnFailedProjectsIntoReTriggerAndReady(releasePlan: ReleasePlan) {\r\n        releasePlan.iterator().forEach { project ->\r\n            if (!project.isSubmodule && project.hasFailedCommandsOrSubmoduleHasFailedCommands(releasePlan)) {\r\n                turnCommandsIntoStateReadyToReTriggerAndReady(releasePlan, project)\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun turnCommandsIntoStateReadyToReTriggerAndReady(releasePlan: ReleasePlan, project: Project) {\r\n        project.commands.forEachIndexed { index, _ ->\r\n            val commandState = Pipeline.getCommandState(project.id, index)\r\n            if (commandState === CommandState.Failed) {\r\n                changeToStateReadyToReTrigger(project, index)\r\n            } else if (commandState === CommandState.Succeeded) {\r\n                changeStateToReadyWithoutCheck(project, index)\r\n            }\r\n        }\r\n        releasePlan.getSubmodules(project.id).forEach {\r\n            val submodule = releasePlan.getProject(it)\r\n            turnCommandsIntoStateReadyToReTriggerAndReady(releasePlan, submodule)\r\n        }\r\n    }\r\n\r\n    private fun Project.hasFailedCommandsOrSubmoduleHasFailedCommands(releasePlan: ReleasePlan): Boolean {\r\n        return commands.mapWithIndex()\r\n            .any { (index, _) -> Pipeline.getCommandState(id, index) === CommandState.Failed }\r\n            || releasePlan.getSubmodules(id).any {\r\n            releasePlan.getProject(it).hasFailedCommandsOrSubmoduleHasFailedCommands(releasePlan)\r\n        }\r\n    }\r\n\r\n    private fun turnFailedCommandsIntoStateReTrigger(releasePlan: ReleasePlan) {\r\n        releasePlan.iterator().forEach { project ->\r\n            project.commands.forEachIndexed { index, _ ->\r\n                val commandState = Pipeline.getCommandState(project.id, index)\r\n                if (commandState === CommandState.Failed) {\r\n                    changeToStateReadyToReTrigger(project, index)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun changeStateToReadyWithoutCheck(project: Project, index: Int) {\r\n        Pipeline.changeStateOfCommand(project, index, CommandState.Ready, Pipeline.STATE_READY) { _, _ ->\r\n            // we do not check transition here, Succeeded to Ready is normally not allowed\r\n            CommandState.Ready\r\n        }\r\n    }\r\n\r\n    private fun changeToStateReadyToReTrigger(project: Project, index: Int) {\r\n        Pipeline.changeStateOfCommand(project, index, CommandState.ReadyToReTrigger, Pipeline.STATE_READY_TO_BE_TRIGGER)\r\n    }\r\n\r\n    private fun HTMLElement.addClickEventListenerIfNotDeactivatedNorDisabled(action: () -> Any) {\r\n        addClickEventListener {\r\n            @Suppress(\"RedundantUnitExpression\")\r\n            if (hasClass(DEACTIVATED) || hasClass(DISABLED)) return@addClickEventListener Unit\r\n            action()\r\n        }\r\n    }\r\n\r\n    private fun HTMLElement.disable(reason: String) {\r\n        this.addClass(DISABLED)\r\n        this.title = reason\r\n    }\r\n\r\n    private fun HTMLElement.isDisabled() = hasClass(DISABLED)\r\n\r\n    private fun HTMLElement.deactivate(reason: String) {\r\n        if (saveButton.isDisabled()) return\r\n\r\n        this.addClass(DEACTIVATED)\r\n        this.setTitleSaveOld(reason)\r\n    }\r\n\r\n    private fun deactivateSaveButton() {\r\n        saveButton.deactivate(\"Nothing to save, no changes were made\")\r\n        listOf(dryRunButton, releaseButton, exploreButton).forEach {\r\n            val oldTitle = it.getOldTitleOrNull()\r\n            if (oldTitle != null) {\r\n                it.title = oldTitle\r\n                it.removeClass(DEACTIVATED)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun activateSaveButton() {\r\n        if (saveButton.isDisabled()) return\r\n\r\n        saveButton.removeClass(DEACTIVATED)\r\n        saveButton.title = \"Publish changed json file and change location\"\r\n        val saveFirst = \"You need to save your changes first.\"\r\n        listOf(dryRunButton, releaseButton, exploreButton).forEach {\r\n            it.deactivate(saveFirst)\r\n        }\r\n    }\r\n\r\n    private fun activateDryRunButton() = activateButton(\r\n        dryRunButton, \"Start a dry run based on this release plan (no commit will be made, no artifact deployed etc.).\"\r\n    )\r\n\r\n    private fun activateReleaseButton() = activateButton(\r\n        releaseButton, \"Start a release based on this release plan.\"\r\n    )\r\n\r\n    private fun activateExploreButton() = activateButton(\r\n        exploreButton, \"See in which order the projects are build, actual order may vary due to unequal execution time.\"\r\n    )\r\n\r\n    private fun activateToolsButton() = activateButton(\r\n        toolsButton, TOOLS_INACTIVE_TITLE\r\n    )\r\n\r\n    private fun activateSettingsButton() = activateButton(\r\n        settingsButton, SETTINGS_INACTIVE_TITLE\r\n    )\r\n\r\n    private fun activateStartOverButton() = activateButton(\r\n        startOverButton, START_OVER_INACTIVE_TITLE\r\n    )\r\n\r\n    private fun activateButton(button: HTMLElement, newTitle: String) {\r\n        if (button.isDisabled()) return\r\n\r\n        button.removeClass(DEACTIVATED)\r\n        button.title = newTitle\r\n    }\r\n\r\n    /**\r\n     * Applies changes and publishes the new release.json with the help of the [Publisher].\r\n     * @return `true` if publishing was carried out, `false` in case there were not any changes.\r\n     */\r\n    fun save(jobExecutor: JobExecutor, verbose: Boolean): Promise<Boolean> {\r\n        val publisher = publisher\r\n        if (publisher == null) {\r\n            deactivateSaveButton()\r\n            showThrowableAndThrow(\r\n                IllegalStateException(\r\n                    \"Save button should not be activate if no publish job url was specified.\" +\r\n                        \"\\nPlease report a bug: $GITHUB_REPO\"\r\n                )\r\n            )\r\n        }\r\n\r\n        val changed = publisher.applyChanges()\r\n        return if (changed) {\r\n            val publishId = getTextField(ContentContainer.RELEASE_ID_HTML_ID).value\r\n            val newFileName = \"release-$publishId\"\r\n            publisher.publish(newFileName, verbose, jobExecutor)\r\n                .then { true }\r\n        } else {\r\n            if (verbose) showInfo(\"Seems like all changes have been reverted manually. Will not save anything.\")\r\n            deactivateSaveButton()\r\n            Promise.resolve(false)\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val DEACTIVATED = \"deactivated\"\r\n        private const val DISABLED = \"disabled\"\r\n\r\n        private const val EVENT_PROCESS_START = \"process.start\"\r\n        private const val EVENT_PROCESS_END = \"process.end\"\r\n        private const val EVENT_PROCESS_CONTINUE = \"process.continue\"\r\n        private const val EVENT_PROCESS_RESET = \"process.reset\"\r\n\r\n        private const val TOOLS_INACTIVE_TITLE = \"Open the toolbox to see further available features.\"\r\n        private const val SETTINGS_INACTIVE_TITLE = \"Open Settings.\"\r\n        private const val START_OVER_INACTIVE_TITLE = \"Start over with a new process.\"\r\n\r\n        private val userButton get() = elementById(\"user\")\r\n        private val userIcon get() = elementById(\"user.icon\")\r\n        private val userName get() = elementById(\"user.name\")\r\n        private val saveButton get() = elementById(\"save\")\r\n        private val downloadButton get() = elementById(\"download\")\r\n        private val dryRunButton get() = elementById(\"dryRun\")\r\n        private val releaseButton get() = elementById(\"release\")\r\n        private val exploreButton get() = elementById(\"explore\")\r\n        private val toolsButton get() = elementById(\"tools\")\r\n        private val settingsButton get() = elementById(\"settings\")\r\n        private val startOverButton get() = elementById(\"startOver\")\r\n        private val eclipsePsfButton get() = elementById(\"eclipsePsf\")\r\n        private val gitCloneCommandsButton get() = elementById(\"gitCloneCommands\")\r\n        private val listDependentsButton get() = elementById(\"listDependents\")\r\n\r\n        private lateinit var _modifiableState: ModifiableState\r\n        var modifiableState: ModifiableState\r\n            get() = _modifiableState\r\n            private set(value) {\r\n                _modifiableState = value\r\n            }\r\n\r\n        fun registerForProcessStartEvent(callback: (Event) -> Unit) {\r\n            elementById(\"menu\").addEventListener(EVENT_PROCESS_START, callback)\r\n        }\r\n\r\n        fun registerForProcessEndEvent(callback: (Boolean) -> Unit) {\r\n            elementById(\"menu\").addEventListener(EVENT_PROCESS_END, { e ->\r\n                val customEvent = e as CustomEvent\r\n                val success = customEvent.detail as Boolean\r\n                callback(success)\r\n            })\r\n        }\r\n\r\n        private fun registerForProcessContinueEvent(callback: (Event) -> Unit) {\r\n            elementById(\"menu\").addEventListener(EVENT_PROCESS_CONTINUE, callback)\r\n        }\r\n\r\n        private fun registerForProcessResetEvent(callback: (Event) -> Unit) {\r\n            elementById(\"menu\").addEventListener(EVENT_PROCESS_RESET, callback)\r\n        }\r\n\r\n        private fun dispatchProcessStart() {\r\n            elementById(\"menu\").dispatchEvent(Event(EVENT_PROCESS_START))\r\n        }\r\n\r\n        private fun dispatchProcessEnd(success: Boolean) {\r\n            elementById(\"menu\").dispatchEvent(CustomEvent(EVENT_PROCESS_END, CustomEventInit(detail = success)))\r\n        }\r\n\r\n        private fun dispatchProcessContinue() {\r\n            elementById(\"menu\").dispatchEvent(Event(EVENT_PROCESS_CONTINUE))\r\n        }\r\n\r\n        private fun dispatchProcessReset() {\r\n            elementById(\"menu\").dispatchEvent(Event(EVENT_PROCESS_RESET))\r\n        }\r\n\r\n\r\n        fun disableUnDisableForProcessStartAndEnd(input: HTMLInputElement, titleElement: HTMLElement) {\r\n            registerForProcessStartEvent {\r\n                input.asDynamic().oldDisabled = input.disabled\r\n                input.disabled = true\r\n                titleElement.setTitleSaveOld(getDisabledMessage())\r\n            }\r\n            registerForProcessEndEvent { _ ->\r\n                if (input.id.startsWith(\"config-\") || isInputFieldOfNonSuccessfulCommand(input.id)) {\r\n                    unDisableInputField(input, titleElement)\r\n                }\r\n            }\r\n        }\r\n\r\n        fun unDisableForProcessContinueAndReset(input: HTMLInputElement, titleElement: HTMLElement) {\r\n            registerForProcessContinueEvent { unDisableInputField(input, titleElement) }\r\n            registerForProcessResetEvent { unDisableInputField(input, titleElement) }\r\n        }\r\n\r\n        private fun unDisableInputField(input: HTMLInputElement, titleElement: HTMLElement) {\r\n            input.disabled = input.asDynamic().oldDisabled as Boolean\r\n            titleElement.title = titleElement.getOldTitle()\r\n        }\r\n\r\n        private fun getDisabledMessage(): String {\r\n            val (processName, _, _) = getCurrentRunData()\r\n            return \"disabled due to process '$processName' which is in progress.\"\r\n        }\r\n\r\n\r\n        fun getCurrentRunData(): Triple<String, HTMLElement, HTMLElement> {\r\n            val typeOfRun = modifiableState.releasePlan.typeOfRun\r\n            val buttonPair = when (typeOfRun) {\r\n                TypeOfRun.EXPLORE -> exploreButton to elementById(\"explore:text\")\r\n                TypeOfRun.DRY_RUN -> dryRunButton to elementById(\"dryRun:text\")\r\n                TypeOfRun.RELEASE -> releaseButton to elementById(\"release:text\")\r\n            }\r\n            return Triple(typeOfRun.toProcessName(), buttonPair.first, buttonPair.second)\r\n        }\r\n\r\n        private fun isInputFieldOfNonSuccessfulCommand(id: String): Boolean {\r\n            if (id == RELEASE_ID_HTML_ID) return false\r\n\r\n            val project = Pipeline.getSurroundingProject(id)\r\n            val releasePlan = modifiableState.releasePlan\r\n            return releasePlan.getProject(project.id).commands.any {\r\n                it.state !== CommandState.Succeeded && it.state !== CommandState.Disabled\r\n            }\r\n        }\r\n    }\r\n\r\n    internal class Dependencies(\r\n        val publisher: Publisher,\r\n        val releaser: Releaser,\r\n        val jenkinsJobExecutor: JobExecutor,\r\n        val simulatingJobExecutor: JobExecutor\r\n    )\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAt(index: Int): Byte {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAt(index: Int): Short {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAt(index: Int): Int {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAt(index: Int): Long {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAt(index: Int): Float {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAt(index: Int): Double {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAt(index: Int): Boolean {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAt(index: Int): Char {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns new array which is a copy of range of original array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of range of original array.\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    for (index in indices)\n        result[index] = this[index]\n    return result\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size)))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Collections.Transformations.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    val set = LinkedHashSet<Byte>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    val set = LinkedHashSet<Short>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    val set = LinkedHashSet<Int>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    val set = LinkedHashSet<Long>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    val set = LinkedHashSet<Float>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    val set = LinkedHashSet<Double>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    val set = LinkedHashSet<Boolean>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    val set = LinkedHashSet<Char>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) count++\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ByteArray.max(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ShortArray.max(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun IntArray.max(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun LongArray.max(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun CharArray.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ByteArray.min(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ShortArray.min(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun IntArray.min(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun LongArray.min(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun CharArray.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        count += 1\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] wrapping each value produced by this [Iterator] with the [IndexedValue],\n * containing value and it's index.\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(index++, iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.dom\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Document](https://developer.mozilla.org/en/docs/Web/API/Document) to Kotlin\n */\npublic external open class Document : Node, GlobalEventHandlers, DocumentAndElementEventHandlers, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GeometryUtils {\n    open val fullscreenEnabled: Boolean\n    open val fullscreen: Boolean\n    var onfullscreenchange: ((Event) -> dynamic)?\n    var onfullscreenerror: ((Event) -> dynamic)?\n    open val rootElement: SVGSVGElement?\n    var title: String\n    open val referrer: String\n    var domain: String\n    open val activeElement: Element?\n    open val location: Location?\n    var cookie: String\n    open val lastModified: String\n    open val readyState: DocumentReadyState\n    var dir: String\n    var body: HTMLElement?\n    open val head: HTMLHeadElement?\n    open val images: HTMLCollection\n    open val embeds: HTMLCollection\n    open val plugins: HTMLCollection\n    open val links: HTMLCollection\n    open val forms: HTMLCollection\n    open val scripts: HTMLCollection\n    open val currentScript: HTMLOrSVGScriptElement?\n    open val defaultView: Window?\n    var designMode: String\n    var onreadystatechange: ((Event) -> dynamic)?\n    var fgColor: String\n    var linkColor: String\n    var vlinkColor: String\n    var alinkColor: String\n    var bgColor: String\n    open val anchors: HTMLCollection\n    open val applets: HTMLCollection\n    open val all: HTMLAllCollection\n    open val implementation: DOMImplementation\n    open val URL: String\n    open val documentURI: String\n    open val origin: String\n    open val compatMode: String\n    open val characterSet: String\n    open val charset: String\n    open val inputEncoding: String\n    open val contentType: String\n    open val doctype: DocumentType?\n    open val documentElement: Element?\n    open val scrollingElement: Element?\n    open val styleSheets: StyleSheetList\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((Event) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((Event) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((Event) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((Event) -> dynamic)?\n    override var ondrag: ((Event) -> dynamic)?\n    override var ondragend: ((Event) -> dynamic)?\n    override var ondragenter: ((Event) -> dynamic)?\n    override var ondragexit: ((Event) -> dynamic)?\n    override var ondragleave: ((Event) -> dynamic)?\n    override var ondragover: ((Event) -> dynamic)?\n    override var ondragstart: ((Event) -> dynamic)?\n    override var ondrop: ((Event) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((Event) -> dynamic)?\n    override var oninput: ((Event) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((Event) -> dynamic)?\n    override var onkeypress: ((Event) -> dynamic)?\n    override var onkeyup: ((Event) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((Event) -> dynamic)?\n    override var onmousedown: ((Event) -> dynamic)?\n    override var onmouseenter: ((Event) -> dynamic)?\n    override var onmouseleave: ((Event) -> dynamic)?\n    override var onmousemove: ((Event) -> dynamic)?\n    override var onmouseout: ((Event) -> dynamic)?\n    override var onmouseover: ((Event) -> dynamic)?\n    override var onmouseup: ((Event) -> dynamic)?\n    override var onwheel: ((Event) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((Event) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var oncopy: ((Event) -> dynamic)?\n    override var oncut: ((Event) -> dynamic)?\n    override var onpaste: ((Event) -> dynamic)?\n    override val fullscreenElement: Element?\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    fun exitFullscreen(): Promise<Unit>\n    fun getElementsByName(elementName: String): NodeList\n    fun open(type: String = definedExternally, replace: String = definedExternally): Document\n    fun open(url: String, name: String, features: String): Window\n    fun close(): Unit\n    fun write(vararg text: String): Unit\n    fun writeln(vararg text: String): Unit\n    fun hasFocus(): Boolean\n    fun execCommand(commandId: String, showUI: Boolean = definedExternally, value: String = definedExternally): Boolean\n    fun queryCommandEnabled(commandId: String): Boolean\n    fun queryCommandIndeterm(commandId: String): Boolean\n    fun queryCommandState(commandId: String): Boolean\n    fun queryCommandSupported(commandId: String): Boolean\n    fun queryCommandValue(commandId: String): String\n    fun clear(): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun createElement(localName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createDocumentFragment(): DocumentFragment\n    fun createTextNode(data: String): Text\n    fun createCDATASection(data: String): CDATASection\n    fun createComment(data: String): Comment\n    fun createProcessingInstruction(target: String, data: String): ProcessingInstruction\n    fun importNode(node: Node, deep: Boolean = definedExternally): Node\n    fun adoptNode(node: Node): Node\n    fun createAttribute(localName: String): Attr\n    fun createAttributeNS(namespace: String?, qualifiedName: String): Attr\n    fun createEvent(interface_: String): Event\n    fun createRange(): Range\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): NodeIterator\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): NodeIterator\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): TreeWalker\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): TreeWalker\n    fun elementFromPoint(x: Double, y: Double): Element?\n    fun elementsFromPoint(x: Double, y: Double): Array<Element>\n    fun caretPositionFromPoint(x: Double, y: Double): CaretPosition?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n@kotlin.internal.InlineOnly inline operator fun Document.get(name: String): dynamic = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Window](https://developer.mozilla.org/en/docs/Web/API/Window) to Kotlin\n */\npublic external abstract class Window : EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, WindowSessionStorage, WindowLocalStorage, GlobalPerformance, UnionMessagePortOrWindow {\n    override val performance: Performance\n    open val window: Window\n    open val self: Window\n    open val document: Document\n    open var name: String\n    open val location: Location\n    open val history: History\n    open val customElements: CustomElementRegistry\n    open val locationbar: BarProp\n    open val menubar: BarProp\n    open val personalbar: BarProp\n    open val scrollbars: BarProp\n    open val statusbar: BarProp\n    open val toolbar: BarProp\n    open var status: String\n    open val closed: Boolean\n    open val frames: Window\n    open val length: Int\n    open val top: Window\n    open var opener: Any?\n    open val parent: Window\n    open val frameElement: Element?\n    open val navigator: Navigator\n    open val applicationCache: ApplicationCache\n    open val external: External\n    open val screen: Screen\n    open val innerWidth: Int\n    open val innerHeight: Int\n    open val scrollX: Double\n    open val pageXOffset: Double\n    open val scrollY: Double\n    open val pageYOffset: Double\n    open val screenX: Int\n    open val screenY: Int\n    open val outerWidth: Int\n    open val outerHeight: Int\n    open val devicePixelRatio: Double\n    fun close(): Unit\n    fun stop(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?\n    fun alert(): Unit\n    fun alert(message: String): Unit\n    fun confirm(message: String = definedExternally): Boolean\n    fun prompt(message: String = definedExternally, default: String = definedExternally): String?\n    fun print(): Unit\n    fun requestAnimationFrame(callback: (Double) -> Unit): Int\n    fun cancelAnimationFrame(handle: Int): Unit\n    fun postMessage(message: Any?, targetOrigin: String, transfer: Array<dynamic> = definedExternally): Unit\n    fun captureEvents(): Unit\n    fun releaseEvents(): Unit\n    fun matchMedia(query: String): MediaQueryList\n    fun moveTo(x: Int, y: Int): Unit\n    fun moveBy(x: Int, y: Int): Unit\n    fun resizeTo(x: Int, y: Int): Unit\n    fun resizeBy(x: Int, y: Int): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration\n}\n@kotlin.internal.InlineOnly inline operator fun Window.get(name: String): dynamic = asDynamic()[name]\n\npublic external abstract class HTMLAllCollection {\n    open val length: Int\n//    fun namedItem(name: String): UnionElementOrHTMLCollection?\n    fun item(nameOrIndex: String = definedExternally): UnionElementOrHTMLCollection?\n}\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(index: Int): Element? = asDynamic()[index]\n//@kotlin.internal.InlineOnly inline operator fun HTMLAllCollection.get(name: String): UnionElementOrHTMLCollection? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLFormControlsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLFormControlsCollection) to Kotlin\n */\npublic external abstract class HTMLFormControlsCollection : HTMLCollection {\n//    override fun namedItem(name: String): UnionElementOrRadioNodeList?\n}\n//@kotlin.internal.InlineOnly override inline operator fun HTMLFormControlsCollection.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [RadioNodeList](https://developer.mozilla.org/en/docs/Web/API/RadioNodeList) to Kotlin\n */\npublic external abstract class RadioNodeList : NodeList, UnionElementOrRadioNodeList {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionsCollection) to Kotlin\n */\npublic external abstract class HTMLOptionsCollection : HTMLCollection {\n    override var length: Int\n    open var selectedIndex: Int\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLOptionsCollection.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLElement](https://developer.mozilla.org/en/docs/Web/API/HTMLElement) to Kotlin\n */\npublic external abstract class HTMLElement : Element, ElementCSSInlineStyle, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable {\n    open var title: String\n    open var lang: String\n    open var translate: Boolean\n    open var dir: String\n    open val dataset: DOMStringMap\n    open var hidden: Boolean\n    open var tabIndex: Int\n    open var accessKey: String\n    open val accessKeyLabel: String\n    open var draggable: Boolean\n    open val dropzone: DOMTokenList\n    open var contextMenu: HTMLMenuElement?\n    open var spellcheck: Boolean\n    open var innerText: String\n    open val offsetParent: Element?\n    open val offsetTop: Int\n    open val offsetLeft: Int\n    open val offsetWidth: Int\n    open val offsetHeight: Int\n    fun click(): Unit\n    fun focus(): Unit\n    fun blur(): Unit\n    fun forceSpellCheck(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLUnknownElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUnknownElement) to Kotlin\n */\npublic external abstract class HTMLUnknownElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [DOMStringMap](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) to Kotlin\n */\npublic external abstract class DOMStringMap {\n}\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.get(name: String): String? = asDynamic()[name]\n@kotlin.internal.InlineOnly inline operator fun DOMStringMap.set(name: String, value: String): Unit { asDynamic()[name] = value; }\n\n/**\n * Exposes the JavaScript [HTMLHtmlElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHtmlElement) to Kotlin\n */\npublic external abstract class HTMLHtmlElement : HTMLElement {\n    open var version: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadElement) to Kotlin\n */\npublic external abstract class HTMLHeadElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLTitleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTitleElement) to Kotlin\n */\npublic external abstract class HTMLTitleElement : HTMLElement {\n    open var text: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBaseElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBaseElement) to Kotlin\n */\npublic external abstract class HTMLBaseElement : HTMLElement {\n    open var href: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLinkElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLinkElement) to Kotlin\n */\npublic external abstract class HTMLLinkElement : HTMLElement, LinkStyle {\n    open var scope: String\n    open var workerType: WorkerType\n    open var href: String\n    open var crossOrigin: String?\n    open var rel: String\n    @JsName(\"as\") open var as_: RequestDestination\n    open val relList: DOMTokenList\n    open var media: String\n    open var nonce: String\n    open var hreflang: String\n    open var type: String\n    open val sizes: DOMTokenList\n    open var referrerPolicy: String\n    open var charset: String\n    open var rev: String\n    open var target: String\n}\n\n/**\n * Exposes the JavaScript [HTMLMetaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMetaElement) to Kotlin\n */\npublic external abstract class HTMLMetaElement : HTMLElement {\n    open var name: String\n    open var httpEquiv: String\n    open var content: String\n    open var scheme: String\n}\n\n/**\n * Exposes the JavaScript [HTMLStyleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLStyleElement) to Kotlin\n */\npublic external abstract class HTMLStyleElement : HTMLElement, LinkStyle {\n    open var media: String\n    open var nonce: String\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLBodyElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBodyElement) to Kotlin\n */\npublic external abstract class HTMLBodyElement : HTMLElement, WindowEventHandlers {\n    open var text: String\n    open var link: String\n    open var vLink: String\n    open var aLink: String\n    open var bgColor: String\n    open var background: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadingElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadingElement) to Kotlin\n */\npublic external abstract class HTMLHeadingElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLParagraphElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParagraphElement) to Kotlin\n */\npublic external abstract class HTMLParagraphElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHRElement) to Kotlin\n */\npublic external abstract class HTMLHRElement : HTMLElement {\n    open var align: String\n    open var color: String\n    open var noShade: Boolean\n    open var size: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPreElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPreElement) to Kotlin\n */\npublic external abstract class HTMLPreElement : HTMLElement {\n    open var width: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLQuoteElement](https://developer.mozilla.org/en/docs/Web/API/HTMLQuoteElement) to Kotlin\n */\npublic external abstract class HTMLQuoteElement : HTMLElement {\n    open var cite: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOListElement) to Kotlin\n */\npublic external abstract class HTMLOListElement : HTMLElement {\n    open var reversed: Boolean\n    open var start: Int\n    open var type: String\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLUListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUListElement) to Kotlin\n */\npublic external abstract class HTMLUListElement : HTMLElement {\n    open var compact: Boolean\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLLIElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLIElement) to Kotlin\n */\npublic external abstract class HTMLLIElement : HTMLElement {\n    open var value: Int\n    open var type: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDListElement) to Kotlin\n */\npublic external abstract class HTMLDListElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDivElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDivElement) to Kotlin\n */\npublic external abstract class HTMLDivElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLAnchorElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement) to Kotlin\n */\npublic external abstract class HTMLAnchorElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var hreflang: String\n    open var type: String\n    open var text: String\n    open var referrerPolicy: String\n    open var coords: String\n    open var charset: String\n    open var name: String\n    open var rev: String\n    open var shape: String\n}\n\n/**\n * Exposes the JavaScript [HTMLDataElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataElement) to Kotlin\n */\npublic external abstract class HTMLDataElement : HTMLElement {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTimeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTimeElement) to Kotlin\n */\npublic external abstract class HTMLTimeElement : HTMLElement {\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLSpanElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSpanElement) to Kotlin\n */\npublic external abstract class HTMLSpanElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLBRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBRElement) to Kotlin\n */\npublic external abstract class HTMLBRElement : HTMLElement {\n    open var clear: String\n}\n\n/**\n * Exposes the JavaScript [HTMLHyperlinkElementUtils](https://developer.mozilla.org/en/docs/Web/API/HTMLHyperlinkElementUtils) to Kotlin\n */\npublic external interface HTMLHyperlinkElementUtils {\n    var href: String\n    val origin: String\n    var protocol: String\n    var username: String\n    var password: String\n    var host: String\n    var hostname: String\n    var port: String\n    var pathname: String\n    var search: String\n    var hash: String\n}\n\n/**\n * Exposes the JavaScript [HTMLModElement](https://developer.mozilla.org/en/docs/Web/API/HTMLModElement) to Kotlin\n */\npublic external abstract class HTMLModElement : HTMLElement {\n    open var cite: String\n    open var dateTime: String\n}\n\n/**\n * Exposes the JavaScript [HTMLPictureElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPictureElement) to Kotlin\n */\npublic external abstract class HTMLPictureElement : HTMLElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLSourceElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSourceElement) to Kotlin\n */\npublic external abstract class HTMLSourceElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var srcset: String\n    open var sizes: String\n    open var media: String\n}\n\n/**\n * Exposes the JavaScript [HTMLImageElement](https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement) to Kotlin\n */\npublic external abstract class HTMLImageElement : HTMLElement, TexImageSource, HTMLOrSVGImageElement {\n    open var alt: String\n    open var src: String\n    open var srcset: String\n    open var sizes: String\n    open var crossOrigin: String?\n    open var useMap: String\n    open var isMap: Boolean\n    open var width: Int\n    open var height: Int\n    open val naturalWidth: Int\n    open val naturalHeight: Int\n    open val complete: Boolean\n    open val currentSrc: String\n    open var referrerPolicy: String\n    open var name: String\n    open var lowsrc: String\n    open var align: String\n    open var hspace: Int\n    open var vspace: Int\n    open var longDesc: String\n    open var border: String\n    open val x: Int\n    open val y: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLIFrameElement](https://developer.mozilla.org/en/docs/Web/API/HTMLIFrameElement) to Kotlin\n */\npublic external abstract class HTMLIFrameElement : HTMLElement {\n    open var src: String\n    open var srcdoc: String\n    open var name: String\n    open val sandbox: DOMTokenList\n    open var allowFullscreen: Boolean\n    open var allowUserMedia: Boolean\n    open var width: String\n    open var height: String\n    open var referrerPolicy: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var align: String\n    open var scrolling: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var marginHeight: String\n    open var marginWidth: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLEmbedElement](https://developer.mozilla.org/en/docs/Web/API/HTMLEmbedElement) to Kotlin\n */\npublic external abstract class HTMLEmbedElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var width: String\n    open var height: String\n    open var align: String\n    open var name: String\n    fun getSVGDocument(): Document?\n}\n\n/**\n * Exposes the JavaScript [HTMLObjectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLObjectElement) to Kotlin\n */\npublic external abstract class HTMLObjectElement : HTMLElement {\n    open var data: String\n    open var type: String\n    open var typeMustMatch: Boolean\n    open var name: String\n    open var useMap: String\n    open val form: HTMLFormElement?\n    open var width: String\n    open var height: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open var align: String\n    open var archive: String\n    open var code: String\n    open var declare: Boolean\n    open var hspace: Int\n    open var standby: String\n    open var vspace: Int\n    open var codeBase: String\n    open var codeType: String\n    open var border: String\n    fun getSVGDocument(): Document?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLParamElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParamElement) to Kotlin\n */\npublic external abstract class HTMLParamElement : HTMLElement {\n    open var name: String\n    open var value: String\n    open var type: String\n    open var valueType: String\n}\n\n/**\n * Exposes the JavaScript [HTMLVideoElement](https://developer.mozilla.org/en/docs/Web/API/HTMLVideoElement) to Kotlin\n */\npublic external abstract class HTMLVideoElement : HTMLMediaElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    open val videoWidth: Int\n    open val videoHeight: Int\n    open var poster: String\n    open var playsInline: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLAudioElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement) to Kotlin\n */\npublic external abstract class HTMLAudioElement : HTMLMediaElement {\n}\n\n/**\n * Exposes the JavaScript [HTMLTrackElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTrackElement) to Kotlin\n */\npublic external abstract class HTMLTrackElement : HTMLElement {\n    open var kind: String\n    open var src: String\n    open var srclang: String\n    open var label: String\n    open var default: Boolean\n    open val readyState: Short\n    open val track: TextTrack\n\n    companion object {\n        val NONE: Short\n        val LOADING: Short\n        val LOADED: Short\n        val ERROR: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMediaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMediaElement) to Kotlin\n */\npublic external abstract class HTMLMediaElement : HTMLElement {\n    open val error: MediaError?\n    open var src: String\n    open var srcObject: dynamic\n    open val currentSrc: String\n    open var crossOrigin: String?\n    open val networkState: Short\n    open var preload: String\n    open val buffered: TimeRanges\n    open val readyState: Short\n    open val seeking: Boolean\n    open var currentTime: Double\n    open val duration: Double\n    open val paused: Boolean\n    open var defaultPlaybackRate: Double\n    open var playbackRate: Double\n    open val played: TimeRanges\n    open val seekable: TimeRanges\n    open val ended: Boolean\n    open var autoplay: Boolean\n    open var loop: Boolean\n    open var controls: Boolean\n    open var volume: Double\n    open var muted: Boolean\n    open var defaultMuted: Boolean\n    open val audioTracks: AudioTrackList\n    open val videoTracks: VideoTrackList\n    open val textTracks: TextTrackList\n    fun load(): Unit\n    fun canPlayType(type: String): CanPlayTypeResult\n    fun fastSeek(time: Double): Unit\n    fun getStartDate(): dynamic\n    fun play(): Promise<Unit>\n    fun pause(): Unit\n    fun addTextTrack(kind: TextTrackKind, label: String = definedExternally, language: String = definedExternally): TextTrack\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [MediaError](https://developer.mozilla.org/en/docs/Web/API/MediaError) to Kotlin\n */\npublic external abstract class MediaError {\n    open val code: Short\n\n    companion object {\n        val MEDIA_ERR_ABORTED: Short\n        val MEDIA_ERR_NETWORK: Short\n        val MEDIA_ERR_DECODE: Short\n        val MEDIA_ERR_SRC_NOT_SUPPORTED: Short\n    }\n}\n\npublic external abstract class AudioTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): AudioTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun AudioTrackList.get(index: Int): AudioTrack? = asDynamic()[index]\n\npublic external abstract class AudioTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var enabled: Boolean\n}\n\npublic external abstract class VideoTrackList : EventTarget {\n    open val length: Int\n    open val selectedIndex: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): VideoTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun VideoTrackList.get(index: Int): VideoTrack? = asDynamic()[index]\n\npublic external abstract class VideoTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var selected: Boolean\n}\n\npublic external abstract class TextTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((Event) -> dynamic)?\n    open var onremovetrack: ((Event) -> dynamic)?\n    fun getTrackById(id: String): TextTrack?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackList.get(index: Int): TextTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrack](https://developer.mozilla.org/en/docs/Web/API/TextTrack) to Kotlin\n */\npublic external abstract class TextTrack : EventTarget, UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val kind: TextTrackKind\n    open val label: String\n    open val language: String\n    open val id: String\n    open val inBandMetadataTrackDispatchType: String\n    open var mode: TextTrackMode\n    open val cues: TextTrackCueList?\n    open val activeCues: TextTrackCueList?\n    open var oncuechange: ((Event) -> dynamic)?\n    fun addCue(cue: TextTrackCue): Unit\n    fun removeCue(cue: TextTrackCue): Unit\n}\n\npublic external abstract class TextTrackCueList {\n    open val length: Int\n    fun getCueById(id: String): TextTrackCue?\n}\n@kotlin.internal.InlineOnly inline operator fun TextTrackCueList.get(index: Int): TextTrackCue? = asDynamic()[index]\n\npublic external abstract class TextTrackCue : EventTarget {\n    open val track: TextTrack?\n    open var id: String\n    open var startTime: Double\n    open var endTime: Double\n    open var pauseOnExit: Boolean\n    open var onenter: ((Event) -> dynamic)?\n    open var onexit: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin\n */\npublic external abstract class TimeRanges {\n    open val length: Int\n    fun start(index: Int): Double\n    fun end(index: Int): Double\n}\n\npublic external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event {\n    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?\n}\n\npublic external interface TrackEventInit : EventInit {\n    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit {\n    val o = js(\"({})\")\n\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin\n */\npublic external abstract class HTMLMapElement : HTMLElement {\n    open var name: String\n    open val areas: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAreaElement) to Kotlin\n */\npublic external abstract class HTMLAreaElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var alt: String\n    open var coords: String\n    open var shape: String\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var referrerPolicy: String\n    open var noHref: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLTableElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableElement) to Kotlin\n */\npublic external abstract class HTMLTableElement : HTMLElement {\n    open var caption: HTMLTableCaptionElement?\n    open var tHead: HTMLTableSectionElement?\n    open var tFoot: HTMLTableSectionElement?\n    open val tBodies: HTMLCollection\n    open val rows: HTMLCollection\n    open var align: String\n    open var border: String\n    open var frame: String\n    open var rules: String\n    open var summary: String\n    open var width: String\n    open var bgColor: String\n    open var cellPadding: String\n    open var cellSpacing: String\n    fun createCaption(): HTMLTableCaptionElement\n    fun deleteCaption(): Unit\n    fun createTHead(): HTMLTableSectionElement\n    fun deleteTHead(): Unit\n    fun createTFoot(): HTMLTableSectionElement\n    fun deleteTFoot(): Unit\n    fun createTBody(): HTMLTableSectionElement\n    fun insertRow(index: Int = definedExternally): HTMLTableRowElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCaptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCaptionElement) to Kotlin\n */\npublic external abstract class HTMLTableCaptionElement : HTMLElement {\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableColElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableColElement) to Kotlin\n */\npublic external abstract class HTMLTableColElement : HTMLElement {\n    open var span: Int\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var width: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTableSectionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableSectionElement) to Kotlin\n */\npublic external abstract class HTMLTableSectionElement : HTMLElement {\n    open val rows: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    fun insertRow(index: Int = definedExternally): HTMLElement\n    fun deleteRow(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableRowElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableRowElement) to Kotlin\n */\npublic external abstract class HTMLTableRowElement : HTMLElement {\n    open val rowIndex: Int\n    open val sectionRowIndex: Int\n    open val cells: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var bgColor: String\n    fun insertCell(index: Int = definedExternally): HTMLElement\n    fun deleteCell(index: Int): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCellElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCellElement) to Kotlin\n */\npublic external abstract class HTMLTableCellElement : HTMLElement {\n    open var colSpan: Int\n    open var rowSpan: Int\n    open var headers: String\n    open val cellIndex: Int\n    open var scope: String\n    open var abbr: String\n    open var align: String\n    open var axis: String\n    open var height: String\n    open var width: String\n    open var ch: String\n    open var chOff: String\n    open var noWrap: Boolean\n    open var vAlign: String\n    open var bgColor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLFormElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFormElement) to Kotlin\n */\npublic external abstract class HTMLFormElement : HTMLElement {\n    open var acceptCharset: String\n    open var action: String\n    open var autocomplete: String\n    open var enctype: String\n    open var encoding: String\n    open var method: String\n    open var name: String\n    open var noValidate: Boolean\n    open var target: String\n    open val elements: HTMLFormControlsCollection\n    open val length: Int\n    fun submit(): Unit\n    fun reset(): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLFormElement.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLLabelElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLabelElement) to Kotlin\n */\npublic external abstract class HTMLLabelElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var htmlFor: String\n    open val control: HTMLElement?\n}\n\n/**\n * Exposes the JavaScript [HTMLInputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement) to Kotlin\n */\npublic external abstract class HTMLInputElement : HTMLElement {\n    open var accept: String\n    open var alt: String\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var defaultChecked: Boolean\n    open var checked: Boolean\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open val files: FileList?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var height: Int\n    open var indeterminate: Boolean\n    open var inputMode: String\n    open val list: HTMLElement?\n    open var max: String\n    open var maxLength: Int\n    open var min: String\n    open var minLength: Int\n    open var multiple: Boolean\n    open var name: String\n    open var pattern: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var size: Int\n    open var src: String\n    open var step: String\n    open var type: String\n    open var defaultValue: String\n    open var value: String\n    open var valueAsDate: dynamic\n    open var valueAsNumber: Double\n    open var width: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    open var align: String\n    open var useMap: String\n    fun stepUp(n: Int = definedExternally): Unit\n    fun stepDown(n: Int = definedExternally): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLButtonElement](https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement) to Kotlin\n */\npublic external abstract class HTMLButtonElement : HTMLElement {\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var name: String\n    open var type: String\n    open var value: String\n    open var menu: HTMLMenuElement?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLSelectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSelectElement) to Kotlin\n */\npublic external abstract class HTMLSelectElement : HTMLElement, ItemArrayLike<Element> {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var multiple: Boolean\n    open var name: String\n    open var required: Boolean\n    open var size: Int\n    open val type: String\n    open val options: HTMLOptionsCollection\n    override var length: Int\n    open val selectedOptions: HTMLCollection\n    open var selectedIndex: Int\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): HTMLOptionElement?\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally): Unit\n    fun remove(index: Int): Unit\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLSelectElement.set(index: Int, option: HTMLOptionElement?): Unit { asDynamic()[index] = option; }\n\n/**\n * Exposes the JavaScript [HTMLDataListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataListElement) to Kotlin\n */\npublic external abstract class HTMLDataListElement : HTMLElement {\n    open val options: HTMLCollection\n}\n\n/**\n * Exposes the JavaScript [HTMLOptGroupElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptGroupElement) to Kotlin\n */\npublic external abstract class HTMLOptGroupElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open var label: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionElement) to Kotlin\n */\npublic external abstract class HTMLOptionElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var label: String\n    open var defaultSelected: Boolean\n    open var selected: Boolean\n    open var value: String\n    open var text: String\n    open val index: Int\n}\n\n/**\n * Exposes the JavaScript [HTMLTextAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTextAreaElement) to Kotlin\n */\npublic external abstract class HTMLTextAreaElement : HTMLElement {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var cols: Int\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var inputMode: String\n    open var maxLength: Int\n    open var minLength: Int\n    open var name: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var rows: Int\n    open var wrap: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val textLength: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n    fun select(): Unit\n    fun setRangeText(replacement: String): Unit\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally): Unit\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLKeygenElement](https://developer.mozilla.org/en/docs/Web/API/HTMLKeygenElement) to Kotlin\n */\npublic external abstract class HTMLKeygenElement : HTMLElement {\n    open var autofocus: Boolean\n    open var challenge: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var keytype: String\n    open var name: String\n    open val type: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLOutputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOutputElement) to Kotlin\n */\npublic external abstract class HTMLOutputElement : HTMLElement {\n    open val htmlFor: DOMTokenList\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLProgressElement](https://developer.mozilla.org/en/docs/Web/API/HTMLProgressElement) to Kotlin\n */\npublic external abstract class HTMLProgressElement : HTMLElement {\n    open var value: Double\n    open var max: Double\n    open val position: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLMeterElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMeterElement) to Kotlin\n */\npublic external abstract class HTMLMeterElement : HTMLElement {\n    open var value: Double\n    open var min: Double\n    open var max: Double\n    open var low: Double\n    open var high: Double\n    open var optimum: Double\n    open val labels: NodeList\n}\n\n/**\n * Exposes the JavaScript [HTMLFieldSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFieldSetElement) to Kotlin\n */\npublic external abstract class HTMLFieldSetElement : HTMLElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open val elements: HTMLCollection\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLLegendElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLegendElement) to Kotlin\n */\npublic external abstract class HTMLLegendElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var align: String\n}\n\n/**\n * Exposes the JavaScript [ValidityState](https://developer.mozilla.org/en/docs/Web/API/ValidityState) to Kotlin\n */\npublic external abstract class ValidityState {\n    open val valueMissing: Boolean\n    open val typeMismatch: Boolean\n    open val patternMismatch: Boolean\n    open val tooLong: Boolean\n    open val tooShort: Boolean\n    open val rangeUnderflow: Boolean\n    open val rangeOverflow: Boolean\n    open val stepMismatch: Boolean\n    open val badInput: Boolean\n    open val customError: Boolean\n    open val valid: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDetailsElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDetailsElement) to Kotlin\n */\npublic external abstract class HTMLDetailsElement : HTMLElement {\n    open var open: Boolean\n}\n\npublic external abstract class HTMLMenuElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var compact: Boolean\n}\n\npublic external abstract class HTMLMenuItemElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var icon: String\n    open var disabled: Boolean\n    open var checked: Boolean\n    open var radiogroup: String\n    open var default: Boolean\n}\n\npublic external open class RelatedEvent(type: String, eventInitDict: RelatedEventInit = definedExternally) : Event {\n    open val relatedTarget: EventTarget?\n}\n\npublic external interface RelatedEventInit : EventInit {\n    var relatedTarget: EventTarget? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RelatedEventInit(relatedTarget: EventTarget? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): RelatedEventInit {\n    val o = js(\"({})\")\n\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLDialogElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDialogElement) to Kotlin\n */\npublic external abstract class HTMLDialogElement : HTMLElement {\n    open var open: Boolean\n    open var returnValue: String\n    fun show(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun showModal(anchor: UnionElementOrMouseEvent = definedExternally): Unit\n    fun close(returnValue: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLScriptElement](https://developer.mozilla.org/en/docs/Web/API/HTMLScriptElement) to Kotlin\n */\npublic external abstract class HTMLScriptElement : HTMLElement, HTMLOrSVGScriptElement {\n    open var src: String\n    open var type: String\n    open var charset: String\n    open var async: Boolean\n    open var defer: Boolean\n    open var crossOrigin: String?\n    open var text: String\n    open var nonce: String\n    open var event: String\n    open var htmlFor: String\n}\n\n/**\n * Exposes the JavaScript [HTMLTemplateElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTemplateElement) to Kotlin\n */\npublic external abstract class HTMLTemplateElement : HTMLElement {\n    open val content: DocumentFragment\n}\n\n/**\n * Exposes the JavaScript [HTMLSlotElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSlotElement) to Kotlin\n */\npublic external abstract class HTMLSlotElement : HTMLElement {\n    open var name: String\n    fun assignedNodes(options: AssignedNodesOptions = definedExternally): Array<Node>\n}\n\npublic external interface AssignedNodesOptions {\n    var flatten: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AssignedNodesOptions(flatten: Boolean? = false): AssignedNodesOptions {\n    val o = js(\"({})\")\n\n    o[\"flatten\"] = flatten\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLCanvasElement](https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement) to Kotlin\n */\npublic external abstract class HTMLCanvasElement : HTMLElement, TexImageSource {\n    open var width: Int\n    open var height: Int\n    fun getContext(contextId: String, vararg arguments: Any?): RenderingContext?\n    fun toDataURL(type: String = definedExternally, quality: Any? = definedExternally): String\n    fun toBlob(_callback: (Blob?) -> Unit, type: String = definedExternally, quality: Any? = definedExternally): Unit\n}\n\npublic external interface CanvasRenderingContext2DSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CanvasRenderingContext2DSettings(alpha: Boolean? = true): CanvasRenderingContext2DSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D) to Kotlin\n */\npublic external abstract class CanvasRenderingContext2D : CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasHitRegion, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath, RenderingContext {\n    open val canvas: HTMLCanvasElement\n}\n\npublic external interface CanvasState {\n    fun save(): Unit\n    fun restore(): Unit\n}\n\npublic external interface CanvasTransform {\n    fun scale(x: Double, y: Double): Unit\n    fun rotate(angle: Double): Unit\n    fun translate(x: Double, y: Double): Unit\n    fun transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun getTransform(): DOMMatrix\n    fun setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double): Unit\n    fun setTransform(transform: dynamic = definedExternally): Unit\n    fun resetTransform(): Unit\n}\n\npublic external interface CanvasCompositing {\n    var globalAlpha: Double\n    var globalCompositeOperation: String\n}\n\npublic external interface CanvasImageSmoothing {\n    var imageSmoothingEnabled: Boolean\n    var imageSmoothingQuality: ImageSmoothingQuality\n}\n\npublic external interface CanvasFillStrokeStyles {\n    var strokeStyle: dynamic\n    var fillStyle: dynamic\n    fun createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double): CanvasGradient\n    fun createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double): CanvasGradient\n    fun createPattern(image: dynamic, repetition: String): CanvasPattern?\n}\n\npublic external interface CanvasShadowStyles {\n    var shadowOffsetX: Double\n    var shadowOffsetY: Double\n    var shadowBlur: Double\n    var shadowColor: String\n}\n\npublic external interface CanvasFilters {\n    var filter: String\n}\n\npublic external interface CanvasRect {\n    fun clearRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun fillRect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun strokeRect(x: Double, y: Double, w: Double, h: Double): Unit\n}\n\npublic external interface CanvasDrawPath {\n    fun beginPath(): Unit\n    fun fill(fillRule: CanvasFillRule = definedExternally): Unit\n    fun fill(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun stroke(): Unit\n    fun stroke(path: Path2D): Unit\n    fun clip(fillRule: CanvasFillRule = definedExternally): Unit\n    fun clip(path: Path2D, fillRule: CanvasFillRule = definedExternally): Unit\n    fun resetClip(): Unit\n    fun isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInStroke(x: Double, y: Double): Boolean\n    fun isPointInStroke(path: Path2D, x: Double, y: Double): Boolean\n}\n\npublic external interface CanvasUserInterface {\n    fun drawFocusIfNeeded(element: Element): Unit\n    fun drawFocusIfNeeded(path: Path2D, element: Element): Unit\n    fun scrollPathIntoView(): Unit\n    fun scrollPathIntoView(path: Path2D): Unit\n}\n\npublic external interface CanvasText {\n    fun fillText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun strokeText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally): Unit\n    fun measureText(text: String): TextMetrics\n}\n\npublic external interface CanvasDrawImage {\n    fun drawImage(image: dynamic, dx: Double, dy: Double): Unit\n    fun drawImage(image: dynamic, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n    fun drawImage(image: dynamic, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double): Unit\n}\n\npublic external interface CanvasHitRegion {\n    fun addHitRegion(options: HitRegionOptions = definedExternally): Unit\n    fun removeHitRegion(id: String): Unit\n    fun clearHitRegions(): Unit\n}\n\npublic external interface CanvasImageData {\n    fun createImageData(sw: Double, sh: Double): ImageData\n    fun createImageData(imagedata: ImageData): ImageData\n    fun getImageData(sx: Double, sy: Double, sw: Double, sh: Double): ImageData\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double): Unit\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double, dirtyX: Double, dirtyY: Double, dirtyWidth: Double, dirtyHeight: Double): Unit\n}\n\npublic external interface CanvasPathDrawingStyles {\n    var lineWidth: Double\n    var lineCap: CanvasLineCap\n    var lineJoin: CanvasLineJoin\n    var miterLimit: Double\n    var lineDashOffset: Double\n    fun setLineDash(segments: Array<Double>): Unit\n    fun getLineDash(): Array<Double>\n}\n\npublic external interface CanvasTextDrawingStyles {\n    var font: String\n    var textAlign: CanvasTextAlign\n    var textBaseline: CanvasTextBaseline\n    var direction: CanvasDirection\n}\n\npublic external interface CanvasPath {\n    fun closePath(): Unit\n    fun moveTo(x: Double, y: Double): Unit\n    fun lineTo(x: Double, y: Double): Unit\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n    fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasGradient](https://developer.mozilla.org/en/docs/Web/API/CanvasGradient) to Kotlin\n */\npublic external abstract class CanvasGradient {\n    fun addColorStop(offset: Double, color: String): Unit\n}\n\n/**\n * Exposes the JavaScript [CanvasPattern](https://developer.mozilla.org/en/docs/Web/API/CanvasPattern) to Kotlin\n */\npublic external abstract class CanvasPattern {\n    fun setTransform(transform: dynamic = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [TextMetrics](https://developer.mozilla.org/en/docs/Web/API/TextMetrics) to Kotlin\n */\npublic external abstract class TextMetrics {\n    open val width: Double\n    open val actualBoundingBoxLeft: Double\n    open val actualBoundingBoxRight: Double\n    open val fontBoundingBoxAscent: Double\n    open val fontBoundingBoxDescent: Double\n    open val actualBoundingBoxAscent: Double\n    open val actualBoundingBoxDescent: Double\n    open val emHeightAscent: Double\n    open val emHeightDescent: Double\n    open val hangingBaseline: Double\n    open val alphabeticBaseline: Double\n    open val ideographicBaseline: Double\n}\n\npublic external interface HitRegionOptions {\n    var path: Path2D? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */\n        get() = definedExternally\n        set(value) = definedExternally\n    var id: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var parentID: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cursor: String? /* = \"inherit\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var control: Element? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var label: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var role: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = \"\", parentID: String? = null, cursor: String? = \"inherit\", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions {\n    val o = js(\"({})\")\n\n    o[\"path\"] = path\n    o[\"fillRule\"] = fillRule\n    o[\"id\"] = id\n    o[\"parentID\"] = parentID\n    o[\"cursor\"] = cursor\n    o[\"control\"] = control\n    o[\"label\"] = label\n    o[\"role\"] = role\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin\n */\npublic external open class ImageData : TexImageSource {\n    constructor(sw: Int, sh: Int)\n    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)\n    open val width: Int\n    open val height: Int\n    open val data: Uint8ClampedArray\n}\n\n/**\n * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin\n */\npublic external open class Path2D() : CanvasPath {\n    constructor(path: Path2D)\n    constructor(paths: Array<Path2D>, fillRule: CanvasFillRule = definedExternally)\n    constructor(d: String)\n    fun addPath(path: Path2D, transform: dynamic = definedExternally): Unit\n    override fun closePath(): Unit\n    override fun moveTo(x: Double, y: Double): Unit\n    override fun lineTo(x: Double, y: Double): Unit\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double): Unit\n    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double): Unit\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double): Unit\n    override fun rect(x: Double, y: Double, w: Double, h: Double): Unit\n    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */): Unit\n}\n\n/**\n * Exposes the JavaScript [Touch](https://developer.mozilla.org/en/docs/Web/API/Touch) to Kotlin\n */\npublic external abstract class Touch {\n    open val region: String?\n}\n\n/**\n * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin\n */\npublic external abstract class ImageBitmapRenderingContext {\n    open val canvas: HTMLCanvasElement\n    fun transferFromImageBitmap(bitmap: ImageBitmap?): Unit\n}\n\npublic external interface ImageBitmapRenderingContextSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapRenderingContextSettings(alpha: Boolean? = true): ImageBitmapRenderingContextSettings {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomElementRegistry](https://developer.mozilla.org/en/docs/Web/API/CustomElementRegistry) to Kotlin\n */\npublic external abstract class CustomElementRegistry {\n    fun define(name: String, constructor: () -> dynamic, options: ElementDefinitionOptions = definedExternally): Unit\n    fun get(name: String): Any?\n    fun whenDefined(name: String): Promise<Unit>\n}\n\npublic external interface ElementDefinitionOptions {\n    var extends: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementDefinitionOptions(extends: String? = null): ElementDefinitionOptions {\n    val o = js(\"({})\")\n\n    o[\"extends\"] = extends\n\n    return o\n}\n\npublic external interface ElementContentEditable {\n    var contentEditable: String\n    val isContentEditable: Boolean\n}\n\n/**\n * Exposes the JavaScript [DataTransfer](https://developer.mozilla.org/en/docs/Web/API/DataTransfer) to Kotlin\n */\npublic external abstract class DataTransfer {\n    open var dropEffect: String\n    open var effectAllowed: String\n    open val items: DataTransferItemList\n    open val types: Array<out String>\n    open val files: FileList\n    fun setDragImage(image: Element, x: Int, y: Int): Unit\n    fun getData(format: String): String\n    fun setData(format: String, data: String): Unit\n    fun clearData(format: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [DataTransferItemList](https://developer.mozilla.org/en/docs/Web/API/DataTransferItemList) to Kotlin\n */\npublic external abstract class DataTransferItemList {\n    open val length: Int\n    fun add(data: String, type: String): DataTransferItem?\n    fun add(data: File): DataTransferItem?\n    fun remove(index: Int): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun DataTransferItemList.get(index: Int): DataTransferItem? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DataTransferItem](https://developer.mozilla.org/en/docs/Web/API/DataTransferItem) to Kotlin\n */\npublic external abstract class DataTransferItem {\n    open val kind: String\n    open val type: String\n    fun getAsString(_callback: ((String) -> Unit)?): Unit\n    fun getAsFile(): File?\n}\n\n/**\n * Exposes the JavaScript [DragEvent](https://developer.mozilla.org/en/docs/Web/API/DragEvent) to Kotlin\n */\npublic external open class DragEvent(type: String, eventInitDict: DragEventInit = definedExternally) : MouseEvent {\n    open val dataTransfer: DataTransfer?\n}\n\npublic external interface DragEventInit : MouseEventInit {\n    var dataTransfer: DataTransfer? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DragEventInit(dataTransfer: DataTransfer? = null, screenX: Int? = 0, screenY: Int? = 0, clientX: Int? = 0, clientY: Int? = 0, button: Short? = 0, buttons: Short? = 0, relatedTarget: EventTarget? = null, ctrlKey: Boolean? = false, shiftKey: Boolean? = false, altKey: Boolean? = false, metaKey: Boolean? = false, modifierAltGraph: Boolean? = false, modifierCapsLock: Boolean? = false, modifierFn: Boolean? = false, modifierFnLock: Boolean? = false, modifierHyper: Boolean? = false, modifierNumLock: Boolean? = false, modifierScrollLock: Boolean? = false, modifierSuper: Boolean? = false, modifierSymbol: Boolean? = false, modifierSymbolLock: Boolean? = false, view: Window? = null, detail: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): DragEventInit {\n    val o = js(\"({})\")\n\n    o[\"dataTransfer\"] = dataTransfer\n    o[\"screenX\"] = screenX\n    o[\"screenY\"] = screenY\n    o[\"clientX\"] = clientX\n    o[\"clientY\"] = clientY\n    o[\"button\"] = button\n    o[\"buttons\"] = buttons\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"ctrlKey\"] = ctrlKey\n    o[\"shiftKey\"] = shiftKey\n    o[\"altKey\"] = altKey\n    o[\"metaKey\"] = metaKey\n    o[\"modifierAltGraph\"] = modifierAltGraph\n    o[\"modifierCapsLock\"] = modifierCapsLock\n    o[\"modifierFn\"] = modifierFn\n    o[\"modifierFnLock\"] = modifierFnLock\n    o[\"modifierHyper\"] = modifierHyper\n    o[\"modifierNumLock\"] = modifierNumLock\n    o[\"modifierScrollLock\"] = modifierScrollLock\n    o[\"modifierSuper\"] = modifierSuper\n    o[\"modifierSymbol\"] = modifierSymbol\n    o[\"modifierSymbolLock\"] = modifierSymbolLock\n    o[\"view\"] = view\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class BarProp {\n    open val visible: Boolean\n}\n\n/**\n * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin\n */\npublic external abstract class History {\n    open val length: Int\n    open var scrollRestoration: ScrollRestoration\n    open val state: Any?\n    fun go(delta: Int = definedExternally): Unit\n    fun back(): Unit\n    fun forward(): Unit\n    fun pushState(data: Any?, title: String, url: String? = definedExternally): Unit\n    fun replaceState(data: Any?, title: String, url: String? = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin\n */\npublic external abstract class Location {\n    open var href: String\n    open val origin: String\n    open var protocol: String\n    open var host: String\n    open var hostname: String\n    open var port: String\n    open var pathname: String\n    open var search: String\n    open var hash: String\n    open val ancestorOrigins: Array<out String>\n    fun assign(url: String): Unit\n    fun replace(url: String): Unit\n    fun reload(): Unit\n}\n\n/**\n * Exposes the JavaScript [PopStateEvent](https://developer.mozilla.org/en/docs/Web/API/PopStateEvent) to Kotlin\n */\npublic external open class PopStateEvent(type: String, eventInitDict: PopStateEventInit = definedExternally) : Event {\n    open val state: Any?\n}\n\npublic external interface PopStateEventInit : EventInit {\n    var state: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PopStateEventInit(state: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PopStateEventInit {\n    val o = js(\"({})\")\n\n    o[\"state\"] = state\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [HashChangeEvent](https://developer.mozilla.org/en/docs/Web/API/HashChangeEvent) to Kotlin\n */\npublic external open class HashChangeEvent(type: String, eventInitDict: HashChangeEventInit = definedExternally) : Event {\n    open val oldURL: String\n    open val newURL: String\n}\n\npublic external interface HashChangeEventInit : EventInit {\n    var oldURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HashChangeEventInit(oldURL: String? = \"\", newURL: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): HashChangeEventInit {\n    val o = js(\"({})\")\n\n    o[\"oldURL\"] = oldURL\n    o[\"newURL\"] = newURL\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PageTransitionEvent](https://developer.mozilla.org/en/docs/Web/API/PageTransitionEvent) to Kotlin\n */\npublic external open class PageTransitionEvent(type: String, eventInitDict: PageTransitionEventInit = definedExternally) : Event {\n    open val persisted: Boolean\n}\n\npublic external interface PageTransitionEventInit : EventInit {\n    var persisted: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PageTransitionEventInit(persisted: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PageTransitionEventInit {\n    val o = js(\"({})\")\n\n    o[\"persisted\"] = persisted\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [BeforeUnloadEvent](https://developer.mozilla.org/en/docs/Web/API/BeforeUnloadEvent) to Kotlin\n */\npublic external open class BeforeUnloadEvent : Event {\n    var returnValue: String\n}\n\npublic external abstract class ApplicationCache : EventTarget {\n    open val status: Short\n    open var onchecking: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onnoupdate: ((Event) -> dynamic)?\n    open var ondownloading: ((Event) -> dynamic)?\n    open var onprogress: ((Event) -> dynamic)?\n    open var onupdateready: ((Event) -> dynamic)?\n    open var oncached: ((Event) -> dynamic)?\n    open var onobsolete: ((Event) -> dynamic)?\n    fun update(): Unit\n    fun abort(): Unit\n    fun swapCache(): Unit\n\n    companion object {\n        val UNCACHED: Short\n        val IDLE: Short\n        val CHECKING: Short\n        val DOWNLOADING: Short\n        val UPDATEREADY: Short\n        val OBSOLETE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NavigatorOnLine](https://developer.mozilla.org/en/docs/Web/API/NavigatorOnLine) to Kotlin\n */\npublic external interface NavigatorOnLine {\n    val onLine: Boolean\n}\n\n/**\n * Exposes the JavaScript [ErrorEvent](https://developer.mozilla.org/en/docs/Web/API/ErrorEvent) to Kotlin\n */\npublic external open class ErrorEvent(type: String, eventInitDict: ErrorEventInit = definedExternally) : Event {\n    open val message: String\n    open val filename: String\n    open val lineno: Int\n    open val colno: Int\n    open val error: Any?\n}\n\npublic external interface ErrorEventInit : EventInit {\n    var message: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var filename: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lineno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var error: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ErrorEventInit(message: String? = \"\", filename: String? = \"\", lineno: Int? = 0, colno: Int? = 0, error: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ErrorEventInit {\n    val o = js(\"({})\")\n\n    o[\"message\"] = message\n    o[\"filename\"] = filename\n    o[\"lineno\"] = lineno\n    o[\"colno\"] = colno\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [PromiseRejectionEvent](https://developer.mozilla.org/en/docs/Web/API/PromiseRejectionEvent) to Kotlin\n */\npublic external open class PromiseRejectionEvent(type: String, eventInitDict: PromiseRejectionEventInit) : Event {\n    open val promise: Promise<Any?>\n    open val reason: Any?\n}\n\npublic external interface PromiseRejectionEventInit : EventInit {\n    var promise: Promise<Any?>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PromiseRejectionEventInit(promise: Promise<Any?>?, reason: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PromiseRejectionEventInit {\n    val o = js(\"({})\")\n\n    o[\"promise\"] = promise\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GlobalEventHandlers](https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers) to Kotlin\n */\npublic external interface GlobalEventHandlers {\n    var onabort: ((Event) -> dynamic)?\n    var onblur: ((Event) -> dynamic)?\n    var oncancel: ((Event) -> dynamic)?\n    var oncanplay: ((Event) -> dynamic)?\n    var oncanplaythrough: ((Event) -> dynamic)?\n    var onchange: ((Event) -> dynamic)?\n    var onclick: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    var oncontextmenu: ((Event) -> dynamic)?\n    var oncuechange: ((Event) -> dynamic)?\n    var ondblclick: ((Event) -> dynamic)?\n    var ondrag: ((Event) -> dynamic)?\n    var ondragend: ((Event) -> dynamic)?\n    var ondragenter: ((Event) -> dynamic)?\n    var ondragexit: ((Event) -> dynamic)?\n    var ondragleave: ((Event) -> dynamic)?\n    var ondragover: ((Event) -> dynamic)?\n    var ondragstart: ((Event) -> dynamic)?\n    var ondrop: ((Event) -> dynamic)?\n    var ondurationchange: ((Event) -> dynamic)?\n    var onemptied: ((Event) -> dynamic)?\n    var onended: ((Event) -> dynamic)?\n    var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    var onfocus: ((Event) -> dynamic)?\n    var oninput: ((Event) -> dynamic)?\n    var oninvalid: ((Event) -> dynamic)?\n    var onkeydown: ((Event) -> dynamic)?\n    var onkeypress: ((Event) -> dynamic)?\n    var onkeyup: ((Event) -> dynamic)?\n    var onload: ((Event) -> dynamic)?\n    var onloadeddata: ((Event) -> dynamic)?\n    var onloadedmetadata: ((Event) -> dynamic)?\n    var onloadend: ((Event) -> dynamic)?\n    var onloadstart: ((Event) -> dynamic)?\n    var onmousedown: ((Event) -> dynamic)?\n    var onmouseenter: ((Event) -> dynamic)?\n    var onmouseleave: ((Event) -> dynamic)?\n    var onmousemove: ((Event) -> dynamic)?\n    var onmouseout: ((Event) -> dynamic)?\n    var onmouseover: ((Event) -> dynamic)?\n    var onmouseup: ((Event) -> dynamic)?\n    var onwheel: ((Event) -> dynamic)?\n    var onpause: ((Event) -> dynamic)?\n    var onplay: ((Event) -> dynamic)?\n    var onplaying: ((Event) -> dynamic)?\n    var onprogress: ((Event) -> dynamic)?\n    var onratechange: ((Event) -> dynamic)?\n    var onreset: ((Event) -> dynamic)?\n    var onresize: ((Event) -> dynamic)?\n    var onscroll: ((Event) -> dynamic)?\n    var onseeked: ((Event) -> dynamic)?\n    var onseeking: ((Event) -> dynamic)?\n    var onselect: ((Event) -> dynamic)?\n    var onshow: ((Event) -> dynamic)?\n    var onstalled: ((Event) -> dynamic)?\n    var onsubmit: ((Event) -> dynamic)?\n    var onsuspend: ((Event) -> dynamic)?\n    var ontimeupdate: ((Event) -> dynamic)?\n    var ontoggle: ((Event) -> dynamic)?\n    var onvolumechange: ((Event) -> dynamic)?\n    var onwaiting: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowEventHandlers](https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers) to Kotlin\n */\npublic external interface WindowEventHandlers {\n    var onafterprint: ((Event) -> dynamic)?\n    var onbeforeprint: ((Event) -> dynamic)?\n    var onbeforeunload: ((Event) -> String?)?\n    var onhashchange: ((Event) -> dynamic)?\n    var onlanguagechange: ((Event) -> dynamic)?\n    var onmessage: ((Event) -> dynamic)?\n    var onoffline: ((Event) -> dynamic)?\n    var ononline: ((Event) -> dynamic)?\n    var onpagehide: ((Event) -> dynamic)?\n    var onpageshow: ((Event) -> dynamic)?\n    var onpopstate: ((Event) -> dynamic)?\n    var onrejectionhandled: ((Event) -> dynamic)?\n    var onstorage: ((Event) -> dynamic)?\n    var onunhandledrejection: ((Event) -> dynamic)?\n    var onunload: ((Event) -> dynamic)?\n}\n\npublic external interface DocumentAndElementEventHandlers {\n    var oncopy: ((Event) -> dynamic)?\n    var oncut: ((Event) -> dynamic)?\n    var onpaste: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [WindowOrWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WindowOrWorkerGlobalScope) to Kotlin\n */\npublic external interface WindowOrWorkerGlobalScope {\n    val caches: CacheStorage\n    val origin: String\n    fun fetch(input: dynamic, init: RequestInit = definedExternally): Promise<Response>\n    fun btoa(data: String): String\n    fun atob(data: String): String\n    fun setTimeout(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearTimeout(handle: Int = definedExternally): Unit\n    fun setInterval(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearInterval(handle: Int = definedExternally): Unit\n    fun createImageBitmap(image: dynamic, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun createImageBitmap(image: dynamic, sx: Int, sy: Int, sw: Int, sh: Int, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n}\n\n/**\n * Exposes the JavaScript [Navigator](https://developer.mozilla.org/en/docs/Web/API/Navigator) to Kotlin\n */\npublic external abstract class Navigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n    fun vibrate(pattern: dynamic): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorID](https://developer.mozilla.org/en/docs/Web/API/NavigatorID) to Kotlin\n */\npublic external interface NavigatorID {\n    val appCodeName: String\n    val appName: String\n    val appVersion: String\n    val platform: String\n    val product: String\n    val productSub: String\n    val userAgent: String\n    val vendor: String\n    val vendorSub: String\n    val oscpu: String\n    fun taintEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorLanguage](https://developer.mozilla.org/en/docs/Web/API/NavigatorLanguage) to Kotlin\n */\npublic external interface NavigatorLanguage {\n    val language: String\n    val languages: Array<out String>\n}\n\npublic external interface NavigatorContentUtils {\n    fun registerProtocolHandler(scheme: String, url: String, title: String): Unit\n    fun registerContentHandler(mimeType: String, url: String, title: String): Unit\n    fun isProtocolHandlerRegistered(scheme: String, url: String): String\n    fun isContentHandlerRegistered(mimeType: String, url: String): String\n    fun unregisterProtocolHandler(scheme: String, url: String): Unit\n    fun unregisterContentHandler(mimeType: String, url: String): Unit\n}\n\npublic external interface NavigatorCookies {\n    val cookieEnabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorPlugins](https://developer.mozilla.org/en/docs/Web/API/NavigatorPlugins) to Kotlin\n */\npublic external interface NavigatorPlugins {\n    val plugins: PluginArray\n    val mimeTypes: MimeTypeArray\n    fun javaEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [PluginArray](https://developer.mozilla.org/en/docs/Web/API/PluginArray) to Kotlin\n */\npublic external abstract class PluginArray : ItemArrayLike<Plugin> {\n    override val length: Int\n    fun refresh(reload: Boolean = definedExternally): Unit\n    override fun item(index: Int): Plugin?\n    fun namedItem(name: String): Plugin?\n}\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(index: Int): Plugin? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun PluginArray.get(name: String): Plugin? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeTypeArray](https://developer.mozilla.org/en/docs/Web/API/MimeTypeArray) to Kotlin\n */\npublic external abstract class MimeTypeArray : ItemArrayLike<MimeType> {\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun MimeTypeArray.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Plugin](https://developer.mozilla.org/en/docs/Web/API/Plugin) to Kotlin\n */\npublic external abstract class Plugin : ItemArrayLike<MimeType> {\n    open val name: String\n    open val description: String\n    open val filename: String\n    override val length: Int\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(index: Int): MimeType? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Plugin.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeType](https://developer.mozilla.org/en/docs/Web/API/MimeType) to Kotlin\n */\npublic external abstract class MimeType {\n    open val type: String\n    open val description: String\n    open val suffixes: String\n    open val enabledPlugin: Plugin\n}\n\n/**\n * Exposes the JavaScript [ImageBitmap](https://developer.mozilla.org/en/docs/Web/API/ImageBitmap) to Kotlin\n */\npublic external abstract class ImageBitmap : TexImageSource {\n    open val width: Int\n    open val height: Int\n    fun close(): Unit\n}\n\npublic external interface ImageBitmapOptions {\n    var imageOrientation: ImageOrientation? /* = ImageOrientation.NONE */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultiplyAlpha: PremultiplyAlpha? /* = PremultiplyAlpha.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colorSpaceConversion: ColorSpaceConversion? /* = ColorSpaceConversion.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeWidth: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeHeight: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeQuality: ResizeQuality? /* = ResizeQuality.LOW */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapOptions(imageOrientation: ImageOrientation? = ImageOrientation.NONE, premultiplyAlpha: PremultiplyAlpha? = PremultiplyAlpha.DEFAULT, colorSpaceConversion: ColorSpaceConversion? = ColorSpaceConversion.DEFAULT, resizeWidth: Int? = null, resizeHeight: Int? = null, resizeQuality: ResizeQuality? = ResizeQuality.LOW): ImageBitmapOptions {\n    val o = js(\"({})\")\n\n    o[\"imageOrientation\"] = imageOrientation\n    o[\"premultiplyAlpha\"] = premultiplyAlpha\n    o[\"colorSpaceConversion\"] = colorSpaceConversion\n    o[\"resizeWidth\"] = resizeWidth\n    o[\"resizeHeight\"] = resizeHeight\n    o[\"resizeQuality\"] = resizeQuality\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageEvent](https://developer.mozilla.org/en/docs/Web/API/MessageEvent) to Kotlin\n */\npublic external open class MessageEvent(type: String, eventInitDict: MessageEventInit = definedExternally) : Event {\n    open val data: Any?\n    open val origin: String\n    open val lastEventId: String\n    open val source: UnionMessagePortOrWindow?\n    open val ports: Array<out MessagePort>\n    fun initMessageEvent(type: String, bubbles: Boolean, cancelable: Boolean, data: Any?, origin: String, lastEventId: String, source: UnionMessagePortOrWindow?, ports: Array<MessagePort>): Unit\n}\n\npublic external interface MessageEventInit : EventInit {\n    var data: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var origin: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lastEventId: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var source: UnionMessagePortOrWindow? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var ports: Array<MessagePort>? /* = arrayOf() */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MessageEventInit(data: Any? = null, origin: String? = \"\", lastEventId: String? = \"\", source: UnionMessagePortOrWindow? = null, ports: Array<MessagePort>? = arrayOf(), bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MessageEventInit {\n    val o = js(\"({})\")\n\n    o[\"data\"] = data\n    o[\"origin\"] = origin\n    o[\"lastEventId\"] = lastEventId\n    o[\"source\"] = source\n    o[\"ports\"] = ports\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [EventSource](https://developer.mozilla.org/en/docs/Web/API/EventSource) to Kotlin\n */\npublic external open class EventSource(url: String, eventSourceInitDict: EventSourceInit = definedExternally) : EventTarget {\n    open val url: String\n    open val withCredentials: Boolean\n    open val readyState: Short\n    var onopen: ((Event) -> dynamic)?\n    var onmessage: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    fun close(): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSED: Short\n    }\n}\n\npublic external interface EventSourceInit {\n    var withCredentials: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventSourceInit(withCredentials: Boolean? = false): EventSourceInit {\n    val o = js(\"({})\")\n\n    o[\"withCredentials\"] = withCredentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [WebSocket](https://developer.mozilla.org/en/docs/Web/API/WebSocket) to Kotlin\n */\npublic external open class WebSocket(url: String, protocols: dynamic = definedExternally) : EventTarget {\n    open val url: String\n    open val readyState: Short\n    open val bufferedAmount: Int\n    var onopen: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    open val extensions: String\n    open val protocol: String\n    var onmessage: ((Event) -> dynamic)?\n    var binaryType: BinaryType\n    fun close(code: Short = definedExternally, reason: String = definedExternally): Unit\n    fun send(data: String): Unit\n    fun send(data: Blob): Unit\n    fun send(data: ArrayBuffer): Unit\n    fun send(data: ArrayBufferView): Unit\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSING: Short\n        val CLOSED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CloseEvent](https://developer.mozilla.org/en/docs/Web/API/CloseEvent) to Kotlin\n */\npublic external open class CloseEvent(type: String, eventInitDict: CloseEventInit = definedExternally) : Event {\n    open val wasClean: Boolean\n    open val code: Short\n    open val reason: String\n}\n\npublic external interface CloseEventInit : EventInit {\n    var wasClean: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var code: Short? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CloseEventInit(wasClean: Boolean? = false, code: Short? = 0, reason: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CloseEventInit {\n    val o = js(\"({})\")\n\n    o[\"wasClean\"] = wasClean\n    o[\"code\"] = code\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageChannel](https://developer.mozilla.org/en/docs/Web/API/MessageChannel) to Kotlin\n */\npublic external open class MessageChannel {\n    open val port1: MessagePort\n    open val port2: MessagePort\n}\n\n/**\n * Exposes the JavaScript [MessagePort](https://developer.mozilla.org/en/docs/Web/API/MessagePort) to Kotlin\n */\npublic external abstract class MessagePort : EventTarget, UnionMessagePortOrWindow, UnionMessagePortOrServiceWorker, UnionClientOrMessagePortOrServiceWorker {\n    open var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun start(): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [BroadcastChannel](https://developer.mozilla.org/en/docs/Web/API/BroadcastChannel) to Kotlin\n */\npublic external open class BroadcastChannel(name: String) : EventTarget {\n    open val name: String\n    var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [WorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WorkerGlobalScope) to Kotlin\n */\npublic external abstract class WorkerGlobalScope : EventTarget, WindowOrWorkerGlobalScope, GlobalPerformance {\n    open val self: WorkerGlobalScope\n    open val location: WorkerLocation\n    open val navigator: WorkerNavigator\n    open var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    open var onlanguagechange: ((Event) -> dynamic)?\n    open var onoffline: ((Event) -> dynamic)?\n    open var ononline: ((Event) -> dynamic)?\n    open var onrejectionhandled: ((Event) -> dynamic)?\n    open var onunhandledrejection: ((Event) -> dynamic)?\n    fun importScripts(vararg urls: String): Unit\n}\n\n/**\n * Exposes the JavaScript [DedicatedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/DedicatedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class DedicatedWorkerGlobalScope : WorkerGlobalScope {\n    open var onmessage: ((Event) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [SharedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/SharedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class SharedWorkerGlobalScope : WorkerGlobalScope {\n    open val name: String\n    open val applicationCache: ApplicationCache\n    open var onconnect: ((Event) -> dynamic)?\n    fun close(): Unit\n}\n\n/**\n * Exposes the JavaScript [AbstractWorker](https://developer.mozilla.org/en/docs/Web/API/AbstractWorker) to Kotlin\n */\npublic external interface AbstractWorker {\n    var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) to Kotlin\n */\npublic external open class Worker(scriptURL: String, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    var onmessage: ((Event) -> dynamic)?\n    override var onerror: ((Event) -> dynamic)?\n    fun terminate(): Unit\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally): Unit\n}\n\npublic external interface WorkerOptions {\n    var type: WorkerType? /* = WorkerType.CLASSIC */\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials? /* = RequestCredentials.OMIT */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WorkerOptions(type: WorkerType? = WorkerType.CLASSIC, credentials: RequestCredentials? = RequestCredentials.OMIT): WorkerOptions {\n    val o = js(\"({})\")\n\n    o[\"type\"] = type\n    o[\"credentials\"] = credentials\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [SharedWorker](https://developer.mozilla.org/en/docs/Web/API/SharedWorker) to Kotlin\n */\npublic external open class SharedWorker(scriptURL: String, name: String = definedExternally, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    open val port: MessagePort\n    override var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [NavigatorConcurrentHardware](https://developer.mozilla.org/en/docs/Web/API/NavigatorConcurrentHardware) to Kotlin\n */\npublic external interface NavigatorConcurrentHardware {\n    val hardwareConcurrency: Int\n}\n\n/**\n * Exposes the JavaScript [WorkerNavigator](https://developer.mozilla.org/en/docs/Web/API/WorkerNavigator) to Kotlin\n */\npublic external abstract class WorkerNavigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n}\n\n/**\n * Exposes the JavaScript [WorkerLocation](https://developer.mozilla.org/en/docs/Web/API/WorkerLocation) to Kotlin\n */\npublic external abstract class WorkerLocation {\n    open var href: String\n    open val origin: String\n    open val protocol: String\n    open val host: String\n    open val hostname: String\n    open val port: String\n    open val pathname: String\n    open val search: String\n    open val hash: String\n}\n\n/**\n * Exposes the JavaScript [Storage](https://developer.mozilla.org/en/docs/Web/API/Storage) to Kotlin\n */\npublic external abstract class Storage {\n    open val length: Int\n    fun key(index: Int): String?\n    fun getItem(key: String): String?\n    fun setItem(key: String, value: String): Unit\n    fun removeItem(key: String): Unit\n    fun clear(): Unit\n}\n@kotlin.internal.InlineOnly inline operator fun Storage.get(key: String): String? = asDynamic()[key]\n@kotlin.internal.InlineOnly inline operator fun Storage.set(key: String, value: String): Unit { asDynamic()[key] = value; }\n\n/**\n * Exposes the JavaScript [WindowSessionStorage](https://developer.mozilla.org/en/docs/Web/API/WindowSessionStorage) to Kotlin\n */\npublic external interface WindowSessionStorage {\n    val sessionStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [WindowLocalStorage](https://developer.mozilla.org/en/docs/Web/API/WindowLocalStorage) to Kotlin\n */\npublic external interface WindowLocalStorage {\n    val localStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [StorageEvent](https://developer.mozilla.org/en/docs/Web/API/StorageEvent) to Kotlin\n */\npublic external open class StorageEvent(type: String, eventInitDict: StorageEventInit = definedExternally) : Event {\n    open val key: String?\n    open val oldValue: String?\n    open val newValue: String?\n    open val url: String\n    open val storageArea: Storage?\n}\n\npublic external interface StorageEventInit : EventInit {\n    var key: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var oldValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var url: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var storageArea: Storage? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun StorageEventInit(key: String? = null, oldValue: String? = null, newValue: String? = null, url: String? = \"\", storageArea: Storage? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): StorageEventInit {\n    val o = js(\"({})\")\n\n    o[\"key\"] = key\n    o[\"oldValue\"] = oldValue\n    o[\"newValue\"] = newValue\n    o[\"url\"] = url\n    o[\"storageArea\"] = storageArea\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external abstract class HTMLAppletElement : HTMLElement {\n    open var align: String\n    open var alt: String\n    open var archive: String\n    open var code: String\n    open var codeBase: String\n    open var height: String\n    open var hspace: Int\n    open var name: String\n    open var _object: String\n    open var vspace: Int\n    open var width: String\n}\n\npublic external abstract class HTMLMarqueeElement : HTMLElement {\n    open var behavior: String\n    open var bgColor: String\n    open var direction: String\n    open var height: String\n    open var hspace: Int\n    open var loop: Int\n    open var scrollAmount: Int\n    open var scrollDelay: Int\n    open var trueSpeed: Boolean\n    open var vspace: Int\n    open var width: String\n    open var onbounce: ((Event) -> dynamic)?\n    open var onfinish: ((Event) -> dynamic)?\n    open var onstart: ((Event) -> dynamic)?\n    fun start(): Unit\n    fun stop(): Unit\n}\n\n/**\n * Exposes the JavaScript [HTMLFrameSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFrameSetElement) to Kotlin\n */\npublic external abstract class HTMLFrameSetElement : HTMLElement, WindowEventHandlers {\n    open var cols: String\n    open var rows: String\n}\n\npublic external abstract class HTMLFrameElement : HTMLElement {\n    open var name: String\n    open var scrolling: String\n    open var src: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var noResize: Boolean\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var marginHeight: String\n    open var marginWidth: String\n}\n\npublic external abstract class HTMLDirectoryElement : HTMLElement {\n    open var compact: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLFontElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFontElement) to Kotlin\n */\npublic external abstract class HTMLFontElement : HTMLElement {\n    open var color: String\n    open var face: String\n    open var size: String\n}\n\npublic external interface External {\n    fun AddSearchProvider(): Unit\n    fun IsSearchProviderInstalled(): Unit\n}\n\npublic external interface EventInit {\n    var bubbles: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cancelable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventInit(bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): EventInit {\n    val o = js(\"({})\")\n\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent) to Kotlin\n */\npublic external open class CustomEvent(type: String, eventInitDict: CustomEventInit = definedExternally) : Event {\n    open val detail: Any?\n    fun initCustomEvent(type: String, bubbles: Boolean, cancelable: Boolean, detail: Any?): Unit\n}\n\npublic external interface CustomEventInit : EventInit {\n    var detail: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CustomEventInit(detail: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CustomEventInit {\n    val o = js(\"({})\")\n\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\npublic external interface EventListenerOptions {\n    var capture: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventListenerOptions(capture: Boolean? = false): EventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface AddEventListenerOptions : EventListenerOptions {\n    var passive: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var once: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AddEventListenerOptions(passive: Boolean? = false, once: Boolean? = false, capture: Boolean? = false): AddEventListenerOptions {\n    val o = js(\"({})\")\n\n    o[\"passive\"] = passive\n    o[\"once\"] = once\n    o[\"capture\"] = capture\n\n    return o\n}\n\npublic external interface NonElementParentNode {\n    fun getElementById(elementId: String): Element?\n}\n\n/**\n * Exposes the JavaScript [DocumentOrShadowRoot](https://developer.mozilla.org/en/docs/Web/API/DocumentOrShadowRoot) to Kotlin\n */\npublic external interface DocumentOrShadowRoot {\n    val fullscreenElement: Element?\n}\n\n/**\n * Exposes the JavaScript [ParentNode](https://developer.mozilla.org/en/docs/Web/API/ParentNode) to Kotlin\n */\npublic external interface ParentNode {\n    val children: HTMLCollection\n    val firstElementChild: Element?\n    val lastElementChild: Element?\n    val childElementCount: Int\n    fun prepend(vararg nodes: dynamic): Unit\n    fun append(vararg nodes: dynamic): Unit\n    fun querySelector(selectors: String): Element?\n    fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [NonDocumentTypeChildNode](https://developer.mozilla.org/en/docs/Web/API/NonDocumentTypeChildNode) to Kotlin\n */\npublic external interface NonDocumentTypeChildNode {\n    val previousElementSibling: Element?\n    val nextElementSibling: Element?\n}\n\n/**\n * Exposes the JavaScript [ChildNode](https://developer.mozilla.org/en/docs/Web/API/ChildNode) to Kotlin\n */\npublic external interface ChildNode {\n    fun before(vararg nodes: dynamic): Unit\n    fun after(vararg nodes: dynamic): Unit\n    fun replaceWith(vararg nodes: dynamic): Unit\n    fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Slotable](https://developer.mozilla.org/en/docs/Web/API/Slotable) to Kotlin\n */\npublic external interface Slotable {\n    val assignedSlot: HTMLSlotElement?\n}\n\n/**\n * Exposes the JavaScript [NodeList](https://developer.mozilla.org/en/docs/Web/API/NodeList) to Kotlin\n */\npublic external abstract class NodeList : ItemArrayLike<Node> {\n    override val length: Int\n    override fun item(index: Int): Node?\n}\n@kotlin.internal.InlineOnly inline operator fun NodeList.get(index: Int): Node? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [HTMLCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLCollection) to Kotlin\n */\npublic external abstract class HTMLCollection : UnionElementOrHTMLCollection, ItemArrayLike<Element> {\n    override val length: Int\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): Element?\n}\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(index: Int): Element? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun HTMLCollection.get(name: String): Element? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) to Kotlin\n */\npublic external open class MutationObserver(callback: (Array<MutationRecord>, MutationObserver) -> Unit) {\n    fun observe(target: Node, options: MutationObserverInit = definedExternally): Unit\n    fun disconnect(): Unit\n    fun takeRecords(): Array<MutationRecord>\n}\n\npublic external interface MutationObserverInit {\n    var childList: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributes: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterData: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var subtree: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterDataOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeFilter: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MutationObserverInit(childList: Boolean? = false, attributes: Boolean? = null, characterData: Boolean? = null, subtree: Boolean? = false, attributeOldValue: Boolean? = null, characterDataOldValue: Boolean? = null, attributeFilter: Array<String>? = null): MutationObserverInit {\n    val o = js(\"({})\")\n\n    o[\"childList\"] = childList\n    o[\"attributes\"] = attributes\n    o[\"characterData\"] = characterData\n    o[\"subtree\"] = subtree\n    o[\"attributeOldValue\"] = attributeOldValue\n    o[\"characterDataOldValue\"] = characterDataOldValue\n    o[\"attributeFilter\"] = attributeFilter\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MutationRecord](https://developer.mozilla.org/en/docs/Web/API/MutationRecord) to Kotlin\n */\npublic external abstract class MutationRecord {\n    open val type: String\n    open val target: Node\n    open val addedNodes: NodeList\n    open val removedNodes: NodeList\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open val attributeName: String?\n    open val attributeNamespace: String?\n    open val oldValue: String?\n}\n\n/**\n * Exposes the JavaScript [Node](https://developer.mozilla.org/en/docs/Web/API/Node) to Kotlin\n */\npublic external abstract class Node : EventTarget {\n    open val nodeType: Short\n    open val nodeName: String\n    open val baseURI: String\n    open val isConnected: Boolean\n    open val ownerDocument: Document?\n    open val parentNode: Node?\n    open val parentElement: Element?\n    open val childNodes: NodeList\n    open val firstChild: Node?\n    open val lastChild: Node?\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open var nodeValue: String?\n    open var textContent: String?\n    fun getRootNode(options: GetRootNodeOptions = definedExternally): Node\n    fun hasChildNodes(): Boolean\n    fun normalize(): Unit\n    fun cloneNode(deep: Boolean = definedExternally): Node\n    fun isEqualNode(otherNode: Node?): Boolean\n    fun isSameNode(otherNode: Node?): Boolean\n    fun compareDocumentPosition(other: Node): Short\n    fun contains(other: Node?): Boolean\n    fun lookupPrefix(namespace: String?): String?\n    fun lookupNamespaceURI(prefix: String?): String?\n    fun isDefaultNamespace(namespace: String?): Boolean\n    fun insertBefore(node: Node, child: Node?): Node\n    fun appendChild(node: Node): Node\n    fun replaceChild(node: Node, child: Node): Node\n    fun removeChild(child: Node): Node\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface GetRootNodeOptions {\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun GetRootNodeOptions(composed: Boolean? = false): GetRootNodeOptions {\n    val o = js(\"({})\")\n\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [XMLDocument](https://developer.mozilla.org/en/docs/Web/API/XMLDocument) to Kotlin\n */\npublic external open class XMLDocument : Document {\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\npublic external interface ElementCreationOptions {\n    @JsName(\"is\") var is_: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementCreationOptions(is_: String? = null): ElementCreationOptions {\n    val o = js(\"({})\")\n\n    o[\"is\"] = is_\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMImplementation](https://developer.mozilla.org/en/docs/Web/API/DOMImplementation) to Kotlin\n */\npublic external abstract class DOMImplementation {\n    fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType\n    fun createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = definedExternally): XMLDocument\n    fun createHTMLDocument(title: String = definedExternally): Document\n    fun hasFeature(): Boolean\n}\n\n/**\n * Exposes the JavaScript [DocumentType](https://developer.mozilla.org/en/docs/Web/API/DocumentType) to Kotlin\n */\npublic external abstract class DocumentType : Node, ChildNode {\n    open val name: String\n    open val publicId: String\n    open val systemId: String\n}\n\n/**\n * Exposes the JavaScript [DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) to Kotlin\n */\npublic external open class DocumentFragment : Node, NonElementParentNode, ParentNode {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [ShadowRoot](https://developer.mozilla.org/en/docs/Web/API/ShadowRoot) to Kotlin\n */\npublic external open class ShadowRoot : DocumentFragment, DocumentOrShadowRoot {\n    open val mode: ShadowRootMode\n    open val host: Element\n    override val fullscreenElement: Element?\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic): Unit\n    override fun append(vararg nodes: dynamic): Unit\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [Element](https://developer.mozilla.org/en/docs/Web/API/Element) to Kotlin\n */\npublic external abstract class Element : Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, GeometryUtils, UnionElementOrProcessingInstruction, UnionElementOrHTMLCollection, UnionElementOrRadioNodeList, UnionElementOrMouseEvent {\n    open var innerHTML: String\n    open var outerHTML: String\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val tagName: String\n    open var id: String\n    open var className: String\n    open val classList: DOMTokenList\n    open var slot: String\n    open val attributes: NamedNodeMap\n    open val shadowRoot: ShadowRoot?\n    open var scrollTop: Double\n    open var scrollLeft: Double\n    open val scrollWidth: Int\n    open val scrollHeight: Int\n    open val clientTop: Int\n    open val clientLeft: Int\n    open val clientWidth: Int\n    open val clientHeight: Int\n    fun requestFullscreen(): Promise<Unit>\n    fun insertAdjacentHTML(position: String, text: String): Unit\n    fun hasAttributes(): Boolean\n    fun getAttributeNames(): Array<String>\n    fun getAttribute(qualifiedName: String): String?\n    fun getAttributeNS(namespace: String?, localName: String): String?\n    fun setAttribute(qualifiedName: String, value: String): Unit\n    fun setAttributeNS(namespace: String?, qualifiedName: String, value: String): Unit\n    fun removeAttribute(qualifiedName: String): Unit\n    fun removeAttributeNS(namespace: String?, localName: String): Unit\n    fun hasAttribute(qualifiedName: String): Boolean\n    fun hasAttributeNS(namespace: String?, localName: String): Boolean\n    fun getAttributeNode(qualifiedName: String): Attr?\n    fun getAttributeNodeNS(namespace: String?, localName: String): Attr?\n    fun setAttributeNode(attr: Attr): Attr?\n    fun setAttributeNodeNS(attr: Attr): Attr?\n    fun removeAttributeNode(attr: Attr): Attr\n    fun attachShadow(init: ShadowRootInit): ShadowRoot\n    fun closest(selectors: String): Element?\n    fun matches(selectors: String): Boolean\n    fun webkitMatchesSelector(selectors: String): Boolean\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun insertAdjacentElement(where: String, element: Element): Element?\n    fun insertAdjacentText(where: String, data: String): Unit\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun scrollIntoView(): Unit\n    fun scrollIntoView(arg: dynamic): Unit\n    fun scroll(options: ScrollToOptions = definedExternally): Unit\n    fun scroll(x: Double, y: Double): Unit\n    fun scrollTo(options: ScrollToOptions = definedExternally): Unit\n    fun scrollTo(x: Double, y: Double): Unit\n    fun scrollBy(options: ScrollToOptions = definedExternally): Unit\n    fun scrollBy(x: Double, y: Double): Unit\n}\n\npublic external interface ShadowRootInit {\n    var mode: ShadowRootMode?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ShadowRootInit(mode: ShadowRootMode?): ShadowRootInit {\n    val o = js(\"({})\")\n\n    o[\"mode\"] = mode\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [NamedNodeMap](https://developer.mozilla.org/en/docs/Web/API/NamedNodeMap) to Kotlin\n */\npublic external abstract class NamedNodeMap : ItemArrayLike<Attr> {\n    override val length: Int\n    override fun item(index: Int): Attr?\n    fun getNamedItem(qualifiedName: String): Attr?\n    fun getNamedItemNS(namespace: String?, localName: String): Attr?\n    fun setNamedItem(attr: Attr): Attr?\n    fun setNamedItemNS(attr: Attr): Attr?\n    fun removeNamedItem(qualifiedName: String): Attr\n    fun removeNamedItemNS(namespace: String?, localName: String): Attr\n}\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(index: Int): Attr? = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun NamedNodeMap.get(qualifiedName: String): Attr? = asDynamic()[qualifiedName]\n\n/**\n * Exposes the JavaScript [Attr](https://developer.mozilla.org/en/docs/Web/API/Attr) to Kotlin\n */\npublic external abstract class Attr : Node {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val name: String\n    open var value: String\n    open val ownerElement: Element?\n    open val specified: Boolean\n}\n\n/**\n * Exposes the JavaScript [CharacterData](https://developer.mozilla.org/en/docs/Web/API/CharacterData) to Kotlin\n */\npublic external abstract class CharacterData : Node, NonDocumentTypeChildNode, ChildNode {\n    open var data: String\n    open val length: Int\n    fun substringData(offset: Int, count: Int): String\n    fun appendData(data: String): Unit\n    fun insertData(offset: Int, data: String): Unit\n    fun deleteData(offset: Int, count: Int): Unit\n    fun replaceData(offset: Int, count: Int, data: String): Unit\n}\n\n/**\n * Exposes the JavaScript [Text](https://developer.mozilla.org/en/docs/Web/API/Text) to Kotlin\n */\npublic external open class Text(data: String = definedExternally) : CharacterData, Slotable, GeometryUtils {\n    open val wholeText: String\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    fun splitText(offset: Int): Text\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [CDATASection](https://developer.mozilla.org/en/docs/Web/API/CDATASection) to Kotlin\n */\npublic external open class CDATASection : Text {\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [ProcessingInstruction](https://developer.mozilla.org/en/docs/Web/API/ProcessingInstruction) to Kotlin\n */\npublic external abstract class ProcessingInstruction : CharacterData, LinkStyle, UnionElementOrProcessingInstruction {\n    open val target: String\n}\n\n/**\n * Exposes the JavaScript [Comment](https://developer.mozilla.org/en/docs/Web/API/Comment) to Kotlin\n */\npublic external open class Comment(data: String = definedExternally) : CharacterData {\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override fun before(vararg nodes: dynamic): Unit\n    override fun after(vararg nodes: dynamic): Unit\n    override fun replaceWith(vararg nodes: dynamic): Unit\n    override fun remove(): Unit\n}\n\n/**\n * Exposes the JavaScript [Range](https://developer.mozilla.org/en/docs/Web/API/Range) to Kotlin\n */\npublic external open class Range {\n    open val startContainer: Node\n    open val startOffset: Int\n    open val endContainer: Node\n    open val endOffset: Int\n    open val collapsed: Boolean\n    open val commonAncestorContainer: Node\n    fun createContextualFragment(fragment: String): DocumentFragment\n    fun setStart(node: Node, offset: Int): Unit\n    fun setEnd(node: Node, offset: Int): Unit\n    fun setStartBefore(node: Node): Unit\n    fun setStartAfter(node: Node): Unit\n    fun setEndBefore(node: Node): Unit\n    fun setEndAfter(node: Node): Unit\n    fun collapse(toStart: Boolean = definedExternally): Unit\n    fun selectNode(node: Node): Unit\n    fun selectNodeContents(node: Node): Unit\n    fun compareBoundaryPoints(how: Short, sourceRange: Range): Short\n    fun deleteContents(): Unit\n    fun extractContents(): DocumentFragment\n    fun cloneContents(): DocumentFragment\n    fun insertNode(node: Node): Unit\n    fun surroundContents(newParent: Node): Unit\n    fun cloneRange(): Range\n    fun detach(): Unit\n    fun isPointInRange(node: Node, offset: Int): Boolean\n    fun comparePoint(node: Node, offset: Int): Short\n    fun intersectsNode(node: Node): Boolean\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n\n    companion object {\n        val START_TO_START: Short\n        val START_TO_END: Short\n        val END_TO_END: Short\n        val END_TO_START: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NodeIterator](https://developer.mozilla.org/en/docs/Web/API/NodeIterator) to Kotlin\n */\npublic external abstract class NodeIterator {\n    open val root: Node\n    open val referenceNode: Node\n    open val pointerBeforeReferenceNode: Boolean\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    fun nextNode(): Node?\n    fun previousNode(): Node?\n    fun detach(): Unit\n}\n\n/**\n * Exposes the JavaScript [TreeWalker](https://developer.mozilla.org/en/docs/Web/API/TreeWalker) to Kotlin\n */\npublic external abstract class TreeWalker {\n    open val root: Node\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    open var currentNode: Node\n    fun parentNode(): Node?\n    fun firstChild(): Node?\n    fun lastChild(): Node?\n    fun previousSibling(): Node?\n    fun nextSibling(): Node?\n    fun previousNode(): Node?\n    fun nextNode(): Node?\n}\n\n/**\n * Exposes the JavaScript [NodeFilter](https://developer.mozilla.org/en/docs/Web/API/NodeFilter) to Kotlin\n */\npublic external interface NodeFilter {\n    fun acceptNode(node: Node): Short\n\n    companion object {\n        val FILTER_ACCEPT: Short\n        val FILTER_REJECT: Short\n        val FILTER_SKIP: Short\n        val SHOW_ALL: Int\n        val SHOW_ELEMENT: Int\n        val SHOW_ATTRIBUTE: Int\n        val SHOW_TEXT: Int\n        val SHOW_CDATA_SECTION: Int\n        val SHOW_ENTITY_REFERENCE: Int\n        val SHOW_ENTITY: Int\n        val SHOW_PROCESSING_INSTRUCTION: Int\n        val SHOW_COMMENT: Int\n        val SHOW_DOCUMENT: Int\n        val SHOW_DOCUMENT_TYPE: Int\n        val SHOW_DOCUMENT_FRAGMENT: Int\n        val SHOW_NOTATION: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMTokenList](https://developer.mozilla.org/en/docs/Web/API/DOMTokenList) to Kotlin\n */\npublic external abstract class DOMTokenList : ItemArrayLike<String> {\n    override val length: Int\n    open var value: String\n    override fun item(index: Int): String?\n    fun contains(token: String): Boolean\n    fun add(vararg tokens: String): Unit\n    fun remove(vararg tokens: String): Unit\n    fun toggle(token: String, force: Boolean = definedExternally): Boolean\n    fun replace(token: String, newToken: String): Unit\n    fun supports(token: String): Boolean\n}\n@kotlin.internal.InlineOnly inline operator fun DOMTokenList.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMPointReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMPointReadOnly) to Kotlin\n */\npublic external open class DOMPointReadOnly(x: Double, y: Double, z: Double, w: Double) {\n    open val x: Double\n    open val y: Double\n    open val z: Double\n    open val w: Double\n    fun matrixTransform(matrix: DOMMatrixReadOnly): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [DOMPoint](https://developer.mozilla.org/en/docs/Web/API/DOMPoint) to Kotlin\n */\npublic external open class DOMPoint : DOMPointReadOnly {\n    constructor(point: DOMPointInit)\n    constructor(x: Double = definedExternally, y: Double = definedExternally, z: Double = definedExternally, w: Double = definedExternally)\n    override var x: Double\n    override var y: Double\n    override var z: Double\n    override var w: Double\n}\n\npublic external interface DOMPointInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var z: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var w: Double? /* = 1.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMPointInit(x: Double? = 0.0, y: Double? = 0.0, z: Double? = 0.0, w: Double? = 1.0): DOMPointInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"z\"] = z\n    o[\"w\"] = w\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMRect](https://developer.mozilla.org/en/docs/Web/API/DOMRect) to Kotlin\n */\npublic external open class DOMRect(x: Double = definedExternally, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally) : DOMRectReadOnly {\n    override var x: Double\n    override var y: Double\n    override var width: Double\n    override var height: Double\n}\n\n/**\n * Exposes the JavaScript [DOMRectReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMRectReadOnly) to Kotlin\n */\npublic external open class DOMRectReadOnly(x: Double, y: Double, width: Double, height: Double) {\n    open val x: Double\n    open val y: Double\n    open val width: Double\n    open val height: Double\n    open val top: Double\n    open val right: Double\n    open val bottom: Double\n    open val left: Double\n}\n\npublic external interface DOMRectInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var width: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMRectInit(x: Double? = 0.0, y: Double? = 0.0, width: Double? = 0.0, height: Double? = 0.0): DOMRectInit {\n    val o = js(\"({})\")\n\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"width\"] = width\n    o[\"height\"] = height\n\n    return o\n}\n\npublic external interface DOMRectList : ItemArrayLike<DOMRect> {\n    override fun item(index: Int): DOMRect?\n}\n@kotlin.internal.InlineOnly inline operator fun DOMRectList.get(index: Int): DOMRect? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMQuad](https://developer.mozilla.org/en/docs/Web/API/DOMQuad) to Kotlin\n */\npublic external open class DOMQuad {\n    constructor(p1: DOMPointInit = definedExternally, p2: DOMPointInit = definedExternally, p3: DOMPointInit = definedExternally, p4: DOMPointInit = definedExternally)\n    constructor(rect: DOMRectInit)\n    open val p1: DOMPoint\n    open val p2: DOMPoint\n    open val p3: DOMPoint\n    open val p4: DOMPoint\n    open val bounds: DOMRectReadOnly\n}\n\n/**\n * Exposes the JavaScript [DOMMatrixReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMMatrixReadOnly) to Kotlin\n */\npublic external open class DOMMatrixReadOnly(numberSequence: Array<Double>) {\n    open val a: Double\n    open val b: Double\n    open val c: Double\n    open val d: Double\n    open val e: Double\n    open val f: Double\n    open val m11: Double\n    open val m12: Double\n    open val m13: Double\n    open val m14: Double\n    open val m21: Double\n    open val m22: Double\n    open val m23: Double\n    open val m24: Double\n    open val m31: Double\n    open val m32: Double\n    open val m33: Double\n    open val m34: Double\n    open val m41: Double\n    open val m42: Double\n    open val m43: Double\n    open val m44: Double\n    open val is2D: Boolean\n    open val isIdentity: Boolean\n    fun translate(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scale(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3d(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniform(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotate(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVector(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngle(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewX(sx: Double): DOMMatrix\n    fun skewY(sy: Double): DOMMatrix\n    fun multiply(other: DOMMatrix): DOMMatrix\n    fun flipX(): DOMMatrix\n    fun flipY(): DOMMatrix\n    fun inverse(): DOMMatrix\n    fun transformPoint(point: DOMPointInit = definedExternally): DOMPoint\n    fun toFloat32Array(): Float32Array\n    fun toFloat64Array(): Float64Array\n}\n\n/**\n * Exposes the JavaScript [DOMMatrix](https://developer.mozilla.org/en/docs/Web/API/DOMMatrix) to Kotlin\n */\npublic external open class DOMMatrix() : DOMMatrixReadOnly {\n    constructor(transformList: String)\n    constructor(other: DOMMatrixReadOnly)\n    constructor(array32: Float32Array)\n    constructor(array64: Float64Array)\n    constructor(numberSequence: Array<Double>)\n    override var a: Double\n    override var b: Double\n    override var c: Double\n    override var d: Double\n    override var e: Double\n    override var f: Double\n    override var m11: Double\n    override var m12: Double\n    override var m13: Double\n    override var m14: Double\n    override var m21: Double\n    override var m22: Double\n    override var m23: Double\n    override var m24: Double\n    override var m31: Double\n    override var m32: Double\n    override var m33: Double\n    override var m34: Double\n    override var m41: Double\n    override var m42: Double\n    override var m43: Double\n    override var m44: Double\n    fun multiplySelf(other: DOMMatrix): DOMMatrix\n    fun preMultiplySelf(other: DOMMatrix): DOMMatrix\n    fun translateSelf(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scaleSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3dSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniformSelf(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotateSelf(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVectorSelf(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngleSelf(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewXSelf(sx: Double): DOMMatrix\n    fun skewYSelf(sy: Double): DOMMatrix\n    fun invertSelf(): DOMMatrix\n    fun setMatrixValue(transformList: String): DOMMatrix\n}\n\npublic external interface ScrollOptions {\n    var behavior: ScrollBehavior? /* = ScrollBehavior.AUTO */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollOptions(behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollOptions {\n    val o = js(\"({})\")\n\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\npublic external interface ScrollToOptions : ScrollOptions {\n    var left: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var top: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollToOptions(left: Double? = null, top: Double? = null, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollToOptions {\n    val o = js(\"({})\")\n\n    o[\"left\"] = left\n    o[\"top\"] = top\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaQueryList](https://developer.mozilla.org/en/docs/Web/API/MediaQueryList) to Kotlin\n */\npublic external abstract class MediaQueryList : EventTarget {\n    open val media: String\n    open val matches: Boolean\n    open var onchange: ((Event) -> dynamic)?\n    fun addListener(listener: EventListener?): Unit\n    fun addListener(listener: ((Event) -> Unit)?): Unit\n    fun removeListener(listener: EventListener?): Unit\n    fun removeListener(listener: ((Event) -> Unit)?): Unit\n}\n\n/**\n * Exposes the JavaScript [MediaQueryListEvent](https://developer.mozilla.org/en/docs/Web/API/MediaQueryListEvent) to Kotlin\n */\npublic external open class MediaQueryListEvent(type: String, eventInitDict: MediaQueryListEventInit = definedExternally) : Event {\n    open val media: String\n    open val matches: Boolean\n}\n\npublic external interface MediaQueryListEventInit : EventInit {\n    var media: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var matches: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaQueryListEventInit(media: String? = \"\", matches: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaQueryListEventInit {\n    val o = js(\"({})\")\n\n    o[\"media\"] = media\n    o[\"matches\"] = matches\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [Screen](https://developer.mozilla.org/en/docs/Web/API/Screen) to Kotlin\n */\npublic external abstract class Screen {\n    open val availWidth: Int\n    open val availHeight: Int\n    open val width: Int\n    open val height: Int\n    open val colorDepth: Int\n    open val pixelDepth: Int\n}\n\n/**\n * Exposes the JavaScript [CaretPosition](https://developer.mozilla.org/en/docs/Web/API/CaretPosition) to Kotlin\n */\npublic external abstract class CaretPosition {\n    open val offsetNode: Node\n    open val offset: Int\n    fun getClientRect(): DOMRect?\n}\n\npublic external interface ScrollIntoViewOptions : ScrollOptions {\n    var block: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var inline: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollIntoViewOptions(block: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, inline: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollIntoViewOptions {\n    val o = js(\"({})\")\n\n    o[\"block\"] = block\n    o[\"inline\"] = inline\n    o[\"behavior\"] = behavior\n\n    return o\n}\n\npublic external interface BoxQuadOptions {\n    var box: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var relativeTo: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BoxQuadOptions(box: CSSBoxType? = CSSBoxType.BORDER, relativeTo: dynamic = null): BoxQuadOptions {\n    val o = js(\"({})\")\n\n    o[\"box\"] = box\n    o[\"relativeTo\"] = relativeTo\n\n    return o\n}\n\npublic external interface ConvertCoordinateOptions {\n    var fromBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var toBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConvertCoordinateOptions(fromBox: CSSBoxType? = CSSBoxType.BORDER, toBox: CSSBoxType? = CSSBoxType.BORDER): ConvertCoordinateOptions {\n    val o = js(\"({})\")\n\n    o[\"fromBox\"] = fromBox\n    o[\"toBox\"] = toBox\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [GeometryUtils](https://developer.mozilla.org/en/docs/Web/API/GeometryUtils) to Kotlin\n */\npublic external interface GeometryUtils {\n    fun getBoxQuads(options: BoxQuadOptions = definedExternally): Array<DOMQuad>\n    fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMPoint\n}\n\npublic external @marker interface UnionElementOrProcessingInstruction {\n}\n\npublic external @marker interface UnionElementOrHTMLCollection {\n}\n\npublic external @marker interface UnionElementOrRadioNodeList {\n}\n\npublic external @marker interface UnionHTMLOptGroupElementOrHTMLOptionElement {\n}\n\npublic external @marker interface UnionAudioTrackOrTextTrackOrVideoTrack {\n}\n\npublic external @marker interface UnionElementOrMouseEvent {\n}\n\npublic external @marker interface UnionMessagePortOrWindow {\n}\n\npublic external @marker interface UnionMessagePortOrServiceWorker {\n}\n\npublic external @marker interface HTMLOrSVGScriptElement {\n}\n\npublic external @marker interface RenderingContext {\n}\n\npublic external @marker interface HTMLOrSVGImageElement {\n}\n\n/* please, don't implement this interface! */\npublic external interface DocumentReadyState {\n    companion object\n}\npublic inline val DocumentReadyState.Companion.LOADING: DocumentReadyState get() = \"loading\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.INTERACTIVE: DocumentReadyState get() = \"interactive\".asDynamic().unsafeCast<DocumentReadyState>()\npublic inline val DocumentReadyState.Companion.COMPLETE: DocumentReadyState get() = \"complete\".asDynamic().unsafeCast<DocumentReadyState>()\n\n/* please, don't implement this interface! */\npublic external interface CanPlayTypeResult {\n    companion object\n}\npublic inline val CanPlayTypeResult.Companion.EMPTY: CanPlayTypeResult get() = \"\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.MAYBE: CanPlayTypeResult get() = \"maybe\".asDynamic().unsafeCast<CanPlayTypeResult>()\npublic inline val CanPlayTypeResult.Companion.PROBABLY: CanPlayTypeResult get() = \"probably\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackMode {\n    companion object\n}\npublic inline val TextTrackMode.Companion.DISABLED: TextTrackMode get() = \"disabled\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.HIDDEN: TextTrackMode get() = \"hidden\".asDynamic().unsafeCast<TextTrackMode>()\npublic inline val TextTrackMode.Companion.SHOWING: TextTrackMode get() = \"showing\".asDynamic().unsafeCast<TextTrackMode>()\n\n/* please, don't implement this interface! */\npublic external interface TextTrackKind {\n    companion object\n}\npublic inline val TextTrackKind.Companion.SUBTITLES: TextTrackKind get() = \"subtitles\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CAPTIONS: TextTrackKind get() = \"captions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.DESCRIPTIONS: TextTrackKind get() = \"descriptions\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.CHAPTERS: TextTrackKind get() = \"chapters\".asDynamic().unsafeCast<TextTrackKind>()\npublic inline val TextTrackKind.Companion.METADATA: TextTrackKind get() = \"metadata\".asDynamic().unsafeCast<TextTrackKind>()\n\n/* please, don't implement this interface! */\npublic external interface SelectionMode {\n    companion object\n}\npublic inline val SelectionMode.Companion.SELECT: SelectionMode get() = \"select\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.START: SelectionMode get() = \"start\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.END: SelectionMode get() = \"end\".asDynamic().unsafeCast<SelectionMode>()\npublic inline val SelectionMode.Companion.PRESERVE: SelectionMode get() = \"preserve\".asDynamic().unsafeCast<SelectionMode>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasFillRule {\n    companion object\n}\npublic inline val CanvasFillRule.Companion.NONZERO: CanvasFillRule get() = \"nonzero\".asDynamic().unsafeCast<CanvasFillRule>()\npublic inline val CanvasFillRule.Companion.EVENODD: CanvasFillRule get() = \"evenodd\".asDynamic().unsafeCast<CanvasFillRule>()\n\n/* please, don't implement this interface! */\npublic external interface ImageSmoothingQuality {\n    companion object\n}\npublic inline val ImageSmoothingQuality.Companion.LOW: ImageSmoothingQuality get() = \"low\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.MEDIUM: ImageSmoothingQuality get() = \"medium\".asDynamic().unsafeCast<ImageSmoothingQuality>()\npublic inline val ImageSmoothingQuality.Companion.HIGH: ImageSmoothingQuality get() = \"high\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineCap {\n    companion object\n}\npublic inline val CanvasLineCap.Companion.BUTT: CanvasLineCap get() = \"butt\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.ROUND: CanvasLineCap get() = \"round\".asDynamic().unsafeCast<CanvasLineCap>()\npublic inline val CanvasLineCap.Companion.SQUARE: CanvasLineCap get() = \"square\".asDynamic().unsafeCast<CanvasLineCap>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasLineJoin {\n    companion object\n}\npublic inline val CanvasLineJoin.Companion.ROUND: CanvasLineJoin get() = \"round\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.BEVEL: CanvasLineJoin get() = \"bevel\".asDynamic().unsafeCast<CanvasLineJoin>()\npublic inline val CanvasLineJoin.Companion.MITER: CanvasLineJoin get() = \"miter\".asDynamic().unsafeCast<CanvasLineJoin>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextAlign {\n    companion object\n}\npublic inline val CanvasTextAlign.Companion.START: CanvasTextAlign get() = \"start\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.END: CanvasTextAlign get() = \"end\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.LEFT: CanvasTextAlign get() = \"left\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.RIGHT: CanvasTextAlign get() = \"right\".asDynamic().unsafeCast<CanvasTextAlign>()\npublic inline val CanvasTextAlign.Companion.CENTER: CanvasTextAlign get() = \"center\".asDynamic().unsafeCast<CanvasTextAlign>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasTextBaseline {\n    companion object\n}\npublic inline val CanvasTextBaseline.Companion.TOP: CanvasTextBaseline get() = \"top\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.HANGING: CanvasTextBaseline get() = \"hanging\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.MIDDLE: CanvasTextBaseline get() = \"middle\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.ALPHABETIC: CanvasTextBaseline get() = \"alphabetic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.IDEOGRAPHIC: CanvasTextBaseline get() = \"ideographic\".asDynamic().unsafeCast<CanvasTextBaseline>()\npublic inline val CanvasTextBaseline.Companion.BOTTOM: CanvasTextBaseline get() = \"bottom\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\n/* please, don't implement this interface! */\npublic external interface CanvasDirection {\n    companion object\n}\npublic inline val CanvasDirection.Companion.LTR: CanvasDirection get() = \"ltr\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.RTL: CanvasDirection get() = \"rtl\".asDynamic().unsafeCast<CanvasDirection>()\npublic inline val CanvasDirection.Companion.INHERIT: CanvasDirection get() = \"inherit\".asDynamic().unsafeCast<CanvasDirection>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollRestoration {\n    companion object\n}\npublic inline val ScrollRestoration.Companion.AUTO: ScrollRestoration get() = \"auto\".asDynamic().unsafeCast<ScrollRestoration>()\npublic inline val ScrollRestoration.Companion.MANUAL: ScrollRestoration get() = \"manual\".asDynamic().unsafeCast<ScrollRestoration>()\n\n/* please, don't implement this interface! */\npublic external interface ImageOrientation {\n    companion object\n}\npublic inline val ImageOrientation.Companion.NONE: ImageOrientation get() = \"none\".asDynamic().unsafeCast<ImageOrientation>()\npublic inline val ImageOrientation.Companion.FLIPY: ImageOrientation get() = \"flipY\".asDynamic().unsafeCast<ImageOrientation>()\n\n/* please, don't implement this interface! */\npublic external interface PremultiplyAlpha {\n    companion object\n}\npublic inline val PremultiplyAlpha.Companion.NONE: PremultiplyAlpha get() = \"none\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.PREMULTIPLY: PremultiplyAlpha get() = \"premultiply\".asDynamic().unsafeCast<PremultiplyAlpha>()\npublic inline val PremultiplyAlpha.Companion.DEFAULT: PremultiplyAlpha get() = \"default\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\n/* please, don't implement this interface! */\npublic external interface ColorSpaceConversion {\n    companion object\n}\npublic inline val ColorSpaceConversion.Companion.NONE: ColorSpaceConversion get() = \"none\".asDynamic().unsafeCast<ColorSpaceConversion>()\npublic inline val ColorSpaceConversion.Companion.DEFAULT: ColorSpaceConversion get() = \"default\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\n/* please, don't implement this interface! */\npublic external interface ResizeQuality {\n    companion object\n}\npublic inline val ResizeQuality.Companion.PIXELATED: ResizeQuality get() = \"pixelated\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.LOW: ResizeQuality get() = \"low\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.MEDIUM: ResizeQuality get() = \"medium\".asDynamic().unsafeCast<ResizeQuality>()\npublic inline val ResizeQuality.Companion.HIGH: ResizeQuality get() = \"high\".asDynamic().unsafeCast<ResizeQuality>()\n\n/* please, don't implement this interface! */\npublic external interface BinaryType {\n    companion object\n}\npublic inline val BinaryType.Companion.BLOB: BinaryType get() = \"blob\".asDynamic().unsafeCast<BinaryType>()\npublic inline val BinaryType.Companion.ARRAYBUFFER: BinaryType get() = \"arraybuffer\".asDynamic().unsafeCast<BinaryType>()\n\n/* please, don't implement this interface! */\npublic external interface WorkerType {\n    companion object\n}\npublic inline val WorkerType.Companion.CLASSIC: WorkerType get() = \"classic\".asDynamic().unsafeCast<WorkerType>()\npublic inline val WorkerType.Companion.MODULE: WorkerType get() = \"module\".asDynamic().unsafeCast<WorkerType>()\n\n/* please, don't implement this interface! */\npublic external interface ShadowRootMode {\n    companion object\n}\npublic inline val ShadowRootMode.Companion.OPEN: ShadowRootMode get() = \"open\".asDynamic().unsafeCast<ShadowRootMode>()\npublic inline val ShadowRootMode.Companion.CLOSED: ShadowRootMode get() = \"closed\".asDynamic().unsafeCast<ShadowRootMode>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollBehavior {\n    companion object\n}\npublic inline val ScrollBehavior.Companion.AUTO: ScrollBehavior get() = \"auto\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.INSTANT: ScrollBehavior get() = \"instant\".asDynamic().unsafeCast<ScrollBehavior>()\npublic inline val ScrollBehavior.Companion.SMOOTH: ScrollBehavior get() = \"smooth\".asDynamic().unsafeCast<ScrollBehavior>()\n\n/* please, don't implement this interface! */\npublic external interface ScrollLogicalPosition {\n    companion object\n}\npublic inline val ScrollLogicalPosition.Companion.START: ScrollLogicalPosition get() = \"start\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.CENTER: ScrollLogicalPosition get() = \"center\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.END: ScrollLogicalPosition get() = \"end\".asDynamic().unsafeCast<ScrollLogicalPosition>()\npublic inline val ScrollLogicalPosition.Companion.NEAREST: ScrollLogicalPosition get() = \"nearest\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\n/* please, don't implement this interface! */\npublic external interface CSSBoxType {\n    companion object\n}\npublic inline val CSSBoxType.Companion.MARGIN: CSSBoxType get() = \"margin\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.BORDER: CSSBoxType get() = \"border\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.PADDING: CSSBoxType get() = \"padding\".asDynamic().unsafeCast<CSSBoxType>()\npublic inline val CSSBoxType.Companion.CONTENT: CSSBoxType get() = \"content\".asDynamic().unsafeCast<CSSBoxType>()\n\n","package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsCommand\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMavenReleasePlugin\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMultiMavenReleasePlugin\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsUpdateDependency\r\nimport ch.loewenfels.depgraph.gui.elementById\r\nimport ch.loewenfels.depgraph.gui.getCheckbox\r\nimport ch.loewenfels.depgraph.gui.getUnderlyingHtmlElement\r\nimport ch.loewenfels.depgraph.gui.jobexecution.GITHUB_NEW_ISSUE\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.gui.showError\r\nimport ch.loewenfels.depgraph.hasNextOnTheSameLevel\r\nimport ch.tutteli.kbox.toPeekingIterator\r\nimport kotlinx.html.*\r\nimport kotlinx.html.dom.append\r\nimport org.w3c.dom.HTMLAnchorElement\r\nimport org.w3c.dom.HTMLElement\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.hasClass\r\nimport kotlin.dom.removeClass\r\n\r\nclass Pipeline(private val modifiableState: ModifiableState, private val menu: Menu) {\r\n    private val contextMenu = ContextMenu(modifiableState, menu)\r\n\r\n    init {\r\n        setUpProjects()\r\n        Toggler(modifiableState, menu)\r\n        contextMenu.setUpOnContextMenuForProjectsAndCommands()\r\n    }\r\n\r\n    private fun setUpProjects() {\r\n        val releasePlan = modifiableState.releasePlan\r\n        val set = hashSetOf<ProjectId>()\r\n        val pipeline = elementById(PIPELINE_HTML_ID)\r\n        pipeline.asDynamic().state = releasePlan.state\r\n        pipeline.asDynamic().typeOfRun = releasePlan.typeOfRun\r\n        pipeline.append {\r\n            val itr = releasePlan.iterator().toPeekingIterator()\r\n            var level: Int\r\n            while (itr.hasNext()) {\r\n                val project = itr.next()\r\n                level = project.level\r\n\r\n                div(\"level l$level\") {\r\n                    if (!project.isSubmodule) {\r\n                        project(project)\r\n                    }\r\n                    set.add(project.id)\r\n                    while (itr.hasNextOnTheSameLevel(level)) {\r\n                        val nextProject = itr.next()\r\n                        if (!nextProject.isSubmodule) {\r\n                            project(nextProject)\r\n                        }\r\n                        set.add(nextProject.id)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        updateStatus(releasePlan, set)\r\n    }\r\n\r\n    private fun updateStatus(\r\n        releasePlan: ReleasePlan,\r\n        set: HashSet<ProjectId>\r\n    ) {\r\n        val involvedProjects = set.size\r\n        val status = elementById(\"status\")\r\n        status.innerText = \"Projects involved: $involvedProjects\"\r\n        val numOfSubmodules = releasePlan.getProjects().count { it.isSubmodule }\r\n        val numOfMultiModules = involvedProjects - numOfSubmodules\r\n        status.title =\r\n            \"multi-module/single Projects: $numOfMultiModules, submodules: $numOfSubmodules\"\r\n        if (involvedProjects != releasePlan.getNumberOfProjects()) {\r\n            showError(\r\n                \"\"\"\r\n                    |Not all dependent projects are involved in the process.\r\n                    |Please report a bug: $GITHUB_NEW_ISSUE\r\n                    |The following projects where left out of the analysis:\r\n                    |${(releasePlan.getProjectIds() - set).joinToString(\"\\n\") { it.identifier }}\r\n                \"\"\".trimMargin()\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun DIV.project(project: Project) {\r\n        div {\r\n            getUnderlyingHtmlElement().asDynamic().project = project\r\n            val hasCommands = project.commands.isNotEmpty()\r\n            classes = setOf(\r\n                \"project\",\r\n                if (project.isSubmodule) \"submodule\" else \"\",\r\n                if (!hasCommands) \"withoutCommands\" else \"\",\r\n                if (modifiableState.releasePlan.hasSubmodules(project.id)) \"withSubmodules\" else \"\"\r\n            )\r\n\r\n            val identifier = project.id.identifier\r\n            this.id = identifier\r\n            div(\"title\") {\r\n                span {\r\n                    projectId(project.id)\r\n                }\r\n            }\r\n            if (!project.isSubmodule) {\r\n                div(\"fields\") {\r\n                    textFieldReadOnlyWithLabel(\r\n                        \"$identifier:currentVersion\", \"Current Version\", project.currentVersion, menu\r\n                    )\r\n                    textFieldWithLabel(\"$identifier:releaseVersion\", \"Release Version\", project.releaseVersion, menu)\r\n                }\r\n                this@Pipeline.contextMenu.createProjectContextMenu(this, project)\r\n            }\r\n            commands(project)\r\n\r\n            if (project.isSubmodule) {\r\n                // means we are within a multi-module and might want to show submodules of this submodule\r\n                submodules(project.id)\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun CommonAttributeGroupFacade.projectId(id: ProjectId) {\r\n        if (id is MavenProjectId) {\r\n            title = id.identifier\r\n            +id.artifactId\r\n        } else {\r\n            +id.identifier\r\n        }\r\n    }\r\n\r\n    private fun INPUT.projectId(id: ProjectId) {\r\n        if (id is MavenProjectId) {\r\n            title = id.identifier\r\n            value = id.artifactId\r\n        } else {\r\n            value = id.identifier\r\n        }\r\n    }\r\n\r\n    private fun DIV.commands(project: Project) {\r\n        project.commands.forEachIndexed { index, command ->\r\n            div {\r\n                val commandId = getCommandId(project, index)\r\n                id = commandId\r\n                classes = setOf(\"command\", stateToCssClass(command.state))\r\n                div(\"commandTitle\") {\r\n                    id = \"$commandId$TITLE_SUFFIX\"\r\n                    +command::class.simpleName!!\r\n                }\r\n                div(\"fields\") {\r\n                    fieldsForCommand(commandId, project, index, command)\r\n                }\r\n                val div = getUnderlyingHtmlElement().asDynamic()\r\n                div.state = command.state\r\n                if (command is JenkinsCommand) {\r\n                    div.buildUrl = command.buildUrl\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun DIV.fieldsForCommand(idPrefix: String, project: Project, index: Int, command: Command) {\r\n        val cssClass = if (command is ReleaseCommand) \"release\" else \"\"\r\n        val isNotDeactivated = command.state !is CommandState.Deactivated\r\n\r\n        toggle(\r\n            \"$idPrefix$DEACTIVATE_SUFFIX\",\r\n            if (isNotDeactivated) \"Click to deactivate command\" else \"Click to activate command\",\r\n            isNotDeactivated,\r\n            command.state === CommandState.Disabled,\r\n            cssClass\r\n        )\r\n        a(classes = \"state\") {\r\n            id = \"$idPrefix$STATE_SUFFIX\"\r\n            i(\"material-icons\") {\r\n                span()\r\n                id = \"$idPrefix:status.icon\"\r\n            }\r\n            if (command is JenkinsCommand) {\r\n                href = command.buildUrl ?: \"\"\r\n            }\r\n            title = stateToTitle(command.state)\r\n        }\r\n        this@Pipeline.contextMenu.createCommandContextMenu(this, idPrefix, project, index)\r\n\r\n        when (command) {\r\n            is JenkinsMavenReleasePlugin ->\r\n                appendJenkinsMavenReleasePluginField(idPrefix, command)\r\n            is JenkinsMultiMavenReleasePlugin ->\r\n                appendJenkinsMultiMavenReleasePluginFields(idPrefix, project.id, command)\r\n            is JenkinsUpdateDependency ->\r\n                appendJenkinsUpdateDependencyField(idPrefix, command)\r\n            else ->\r\n                showError(\"Unknown command found, cannot display its fields.\\n$command\")\r\n        }\r\n    }\r\n\r\n    private fun DIV.appendJenkinsMavenReleasePluginField(idPrefix: String, command: JenkinsMavenReleasePlugin) {\r\n        fieldNextDevVersion(idPrefix, command, command.nextDevVersion)\r\n    }\r\n\r\n    private fun DIV.fieldNextDevVersion(idPrefix: String, command: Command, nextDevVersion: String) {\r\n        textFieldWithLabel(\"$idPrefix$NEXT_DEV_VERSION_SUFFIX\", \"Next Dev Version\", nextDevVersion, menu) {\r\n            if (command.state === CommandState.Disabled) {\r\n                disabled = true\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun DIV.appendJenkinsMultiMavenReleasePluginFields(\r\n        idPrefix: String,\r\n        projectId: ProjectId,\r\n        command: JenkinsMultiMavenReleasePlugin\r\n    ) {\r\n        fieldNextDevVersion(idPrefix, command, command.nextDevVersion)\r\n        submodules(projectId)\r\n    }\r\n\r\n    private fun DIV.submodules(projectId: ProjectId) {\r\n        val submodules = modifiableState.releasePlan.getSubmodules(projectId)\r\n        if (submodules.isEmpty()) return\r\n\r\n        div(\"submodules\") {\r\n            submodules.forEach {\r\n                project(modifiableState.releasePlan.getProject(it))\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun DIV.appendJenkinsUpdateDependencyField(idPrefix: String, command: JenkinsUpdateDependency) {\r\n        textFieldReadOnlyWithLabel(\"$idPrefix:groupId\", \"Dependency\", command.projectId.identifier, menu) {\r\n            projectId(command.projectId)\r\n        }\r\n    }\r\n\r\n    private fun DIV.toggle(\r\n        idCheckbox: String,\r\n        title: String,\r\n        checked: Boolean,\r\n        disabled: Boolean,\r\n        checkboxCssClass: String = \"\"\r\n    ) {\r\n        label(\"toggle\") {\r\n            checkBoxInput(classes = checkboxCssClass) {\r\n                this.id = idCheckbox\r\n                this.checked = checked && !disabled\r\n                this.disabled = disabled\r\n            }\r\n            span(\"slider\") {\r\n                this.id = \"$idCheckbox$SLIDER_SUFFIX\"\r\n                this.title = title\r\n                if (disabled) {\r\n                    this.title = STATE_DISABLED\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        private const val PIPELINE_HTML_ID = \"pipeline\"\r\n\r\n        private const val STATE_WAITING = \"Wait for dependent projects to complete.\"\r\n        const val STATE_READY = \"Ready to be queued for execution.\"\r\n        const val STATE_READY_TO_BE_TRIGGER = \"Ready to be re-scheduled\"\r\n        const val STATE_QUEUEING = \"Currently queueing the job.\"\r\n        private const val STATE_RE_POLLING = \"Job is being re-polled.\"\r\n        const val STATE_IN_PROGRESS = \"Job is running.\"\r\n        const val STATE_SUCCEEDED = \"Job completed successfully.\"\r\n        const val STATE_FAILED = \"Job failed - click to navigate to console.\"\r\n        private const val STATE_DEACTIVATED = \"Currently deactivated, click to activate\"\r\n        const val STATE_DISABLED = \"Command disabled, cannot be reactivated.\"\r\n\r\n        const val DEACTIVATE_SUFFIX = \":deactivate\"\r\n        const val SLIDER_SUFFIX = \":slider\"\r\n        const val NEXT_DEV_VERSION_SUFFIX = \":nextDevVersion\"\r\n        const val STATE_SUFFIX = \":state\"\r\n        const val TITLE_SUFFIX = \":title\"\r\n\r\n\r\n        fun getCommandId(project: Project, index: Int) = getCommandId(project.id, index)\r\n        fun getCommandId(projectId: ProjectId, index: Int) = \"${projectId.identifier}:$index\"\r\n        fun getCommand(project: Project, index: Int) = getCommand(project.id, index)\r\n        fun getCommand(projectId: ProjectId, index: Int): HTMLElement = elementById(getCommandId(projectId, index))\r\n\r\n        fun getToggle(project: Project, index: Int) =\r\n            getCheckbox(\"${getCommandId(project.id, index)}$DEACTIVATE_SUFFIX\")\r\n\r\n        fun getCommandState(projectId: ProjectId, index: Int) = getCommandState(getCommandId(projectId, index))\r\n        fun getCommandState(idPrefix: String) = elementById(idPrefix).asDynamic().state as CommandState\r\n\r\n        fun changeStateOfCommandAndAddBuildUrl(\r\n            project: Project,\r\n            index: Int,\r\n            newState: CommandState,\r\n            title: String,\r\n            buildUrl: String\r\n        ) = changeStateOfCommandAndAddBuildUrlIfSet(project, index, newState, title, buildUrl)\r\n\r\n        fun changeStateOfCommandAndAddBuildUrlIfSet(\r\n            project: Project,\r\n            index: Int,\r\n            newState: CommandState,\r\n            title: String,\r\n            buildUrl: String?\r\n        ) {\r\n            changeStateOfCommand(project, index, newState, title)\r\n            if(buildUrl != null){\r\n                changeBuildUrlOfCommand(project, index, buildUrl)\r\n            }\r\n        }\r\n\r\n        fun changeBuildUrlOfCommand(project: Project, index: Int, buildUrl: String) {\r\n            val commandId = getCommandId(project, index)\r\n            elementById<HTMLAnchorElement>(\"$commandId$STATE_SUFFIX\").href = buildUrl\r\n            elementById(commandId).asDynamic().buildUrl = buildUrl\r\n        }\r\n\r\n        fun changeStateOfCommand(project: Project, index: Int, newState: CommandState, title: String) {\r\n            changeStateOfCommand(project, index, newState, title) { previousState, commandId ->\r\n                try {\r\n                    previousState.checkTransitionAllowed(newState)\r\n                } catch (e: IllegalStateException) {\r\n                    val commandTitle = elementById(commandId + TITLE_SUFFIX)\r\n                    //TODO use $this instead of $getToStringRepresentation(...) once https://youtrack.jetbrains.com/issue/KT-23970 is fixed\r\n                    throw IllegalStateException(\r\n                        \"Cannot change the state of the command to ${newState.getToStringRepresentation()}.\" +\r\n                            \"\\nProject: ${project.id.identifier}\" +\r\n                            \"\\nCommand: ${commandTitle.innerText} (${index + 1}. command)\" +\r\n                            \"\\nCurrent state: ${previousState.getToStringRepresentation()}\",\r\n                        e\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        internal fun changeStateOfCommand(\r\n            project: Project,\r\n            index: Int,\r\n            newState: CommandState,\r\n            title: String,\r\n            checkStateTransition: (previousState: CommandState, commandId: String) -> CommandState\r\n        ) {\r\n            val commandId = getCommandId(project, index)\r\n            val command = elementById(commandId)\r\n            val dynCommand = command.asDynamic()\r\n            val previousState = dynCommand.state as CommandState\r\n            dynCommand.state = checkStateTransition(previousState, commandId)\r\n            command.removeClass(stateToCssClass(previousState))\r\n            command.addClass(stateToCssClass(newState))\r\n            elementById(\"$commandId$STATE_SUFFIX\").title = title\r\n        }\r\n\r\n        fun getReleaseState() = getPipelineAsDynamic().state as ReleaseState\r\n        fun getTypeOfRun() = getPipelineAsDynamic().typeOfRun as TypeOfRun\r\n\r\n        fun changeReleaseState(newState: ReleaseState) {\r\n            getPipelineAsDynamic().state = getReleaseState().checkTransitionAllowed(newState)\r\n        }\r\n\r\n        fun changeTypeOfRun(newTypeOfRun: TypeOfRun) {\r\n            getPipelineAsDynamic().typeOfRun = newTypeOfRun\r\n        }\r\n\r\n        private fun getPipelineAsDynamic() = elementById(PIPELINE_HTML_ID).asDynamic()\r\n\r\n        private fun stateToCssClass(state: CommandState) = when (state) {\r\n            is CommandState.Waiting -> \"waiting\"\r\n            CommandState.Ready -> \"ready\"\r\n            CommandState.ReadyToReTrigger -> \"readyToReTrigger\"\r\n            CommandState.Queueing,\r\n            CommandState.StillQueueing -> \"queueing\"\r\n            CommandState.RePolling -> \"rePolling\"\r\n            CommandState.InProgress -> \"inProgress\"\r\n            CommandState.Succeeded -> \"succeeded\"\r\n            is CommandState.Failed -> \"failed\"\r\n            is CommandState.Deactivated -> \"deactivated\"\r\n            CommandState.Disabled -> \"disabled\"\r\n        }\r\n\r\n        internal fun stateToTitle(state: CommandState) = when (state) {\r\n            is CommandState.Waiting -> STATE_WAITING\r\n            CommandState.Ready -> STATE_READY\r\n            CommandState.ReadyToReTrigger -> STATE_READY_TO_BE_TRIGGER\r\n            CommandState.Queueing,\r\n            CommandState.StillQueueing -> STATE_QUEUEING\r\n            CommandState.RePolling -> STATE_RE_POLLING\r\n            CommandState.InProgress -> STATE_IN_PROGRESS\r\n            CommandState.Succeeded -> STATE_SUCCEEDED\r\n            CommandState.Failed -> STATE_FAILED\r\n            is CommandState.Deactivated -> STATE_DEACTIVATED\r\n            CommandState.Disabled -> STATE_DISABLED\r\n        }\r\n\r\n        fun getSurroundingProject(id: String): Project {\r\n            var node = elementById(id).parentNode\r\n            while (node is HTMLElement && !node.hasClass(\"project\")) {\r\n                node = node.parentNode\r\n            }\r\n            check(node is HTMLElement && node.hasClass(\"project\")) {\r\n                \"Cannot determine whether input field should be re-activated or not, could not get surrounding project\"\r\n            }\r\n            return node.asDynamic().project as Project\r\n        }\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [LinkedHashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","package ch.loewenfels.depgraph.gui.components\r\n\r\nimport ch.loewenfels.depgraph.data.CommandState\r\nimport ch.loewenfels.depgraph.data.Project\r\nimport ch.loewenfels.depgraph.data.ReleaseCommand\r\nimport ch.loewenfels.depgraph.gui.addChangeEventListener\r\nimport ch.loewenfels.depgraph.gui.addClickEventListener\r\nimport ch.loewenfels.depgraph.gui.elementById\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.gui.showInfo\r\nimport ch.tutteli.kbox.mapWithIndex\r\nimport org.w3c.dom.CustomEvent\r\nimport org.w3c.dom.CustomEventInit\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.dom.events.Event\r\nimport kotlin.dom.hasClass\r\nimport kotlin.js.Promise\r\n\r\nclass Toggler(private val modifiableState: ModifiableState, private val menu: Menu) {\r\n\r\n    init {\r\n        modifiableState.releasePlan.getProjects().forEach { project ->\r\n            registerCommandToggleEvents(project)\r\n            registerReleaseUncheckEventForDependentsAndSubmodules(project)\r\n        }\r\n    }\r\n\r\n    private fun registerCommandToggleEvents(project: Project) {\r\n        project.commands.forEachIndexed { index, command ->\r\n            val toggle = Pipeline.getToggle(project, index)\r\n\r\n            if (command is ReleaseCommand) {\r\n                toggle.addChangeEventListener { toggleCommand(project, index, EVENT_RELEASE_TOGGLE_UNCHECKED) }\r\n                disallowClickIfNotAllCommandsOrSubmodulesActive(project, toggle)\r\n                val releasePlan = modifiableState.releasePlan\r\n                val projectAndSubmodules = sequenceOf(project) +\r\n                    releasePlan.getSubmodules(project.id).asSequence().map { releasePlan.getProject(it) }\r\n\r\n                projectAndSubmodules.forEach {\r\n                    registerForProjectEvent(it, EVENT_TOGGLE_UNCHECKED) { toggle.uncheck() }\r\n                }\r\n            } else {\r\n                toggle.addChangeEventListener { toggleCommand(project, index, EVENT_TOGGLE_UNCHECKED) }\r\n            }\r\n\r\n            val slider = getSlider(toggle)\r\n            Menu.disableUnDisableForProcessStartAndEnd(toggle, slider)\r\n            Menu.unDisableForProcessContinueAndReset(toggle, slider)\r\n        }\r\n    }\r\n\r\n    private fun toggleCommand(project: Project, index: Int, uncheckedEvent: String) {\r\n        val toggle = Pipeline.getToggle(project, index)\r\n        val command = Pipeline.getCommand(project, index).asDynamic()\r\n        val slider = getSlider(toggle)\r\n        val currentTitle = elementById(\"${Pipeline.getCommandId(project, index)}${Pipeline.STATE_SUFFIX}\").title\r\n        if (!toggle.checked) {\r\n            dispatchToggleEvent(project, toggle, uncheckedEvent)\r\n            val previous = command.state as CommandState\r\n            Pipeline.changeStateOfCommand(project, index, CommandState.Deactivated(previous), currentTitle)\r\n            slider.title = \"Click to activate command.\"\r\n        } else {\r\n            val oldState = command.state as CommandState.Deactivated\r\n            Pipeline.changeStateOfCommand(project, index, oldState.previous, currentTitle)\r\n            slider.title = \"Click to deactivate command.\"\r\n        }\r\n        menu.activateSaveButton()\r\n    }\r\n\r\n    private fun disallowClickIfNotAllCommandsOrSubmodulesActive(project: Project, toggle: HTMLInputElement) {\r\n        toggle.addClickEventListener { e ->\r\n            if (toggle.checked && notAllCommandsOrSubmodulesActive(project, toggle)) {\r\n                // cannot reactivate release command if not all commands are active\r\n                // setting checked again to false\r\n                //toggle.checked = false\r\n                e.preventDefault()\r\n                showInfo(\r\n                    \"Cannot reactivate the ReleaseCommand for project ${project.id.identifier} \" +\r\n                        \"because some commands (of submodules) are deactivated.\",\r\n                    4000\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun notAllCommandsOrSubmodulesActive(project: Project, toggle: HTMLInputElement): Boolean {\r\n        return notAllCommandsOrSubmodulesActive(project) { it.id != toggle.id }\r\n    }\r\n\r\n    private fun notAllCommandsOrSubmodulesActive(project: Project, predicate: (HTMLInputElement) -> Boolean): Boolean {\r\n        return notAllCommandsActive(project, predicate) || notAllSubmodulesActive(project)\r\n    }\r\n\r\n    private fun notAllCommandsActive(project: Project, predicate: (HTMLInputElement) -> Boolean): Boolean {\r\n        return project.commands.asSequence()\r\n            .mapIndexed { index, _ -> Pipeline.getToggle(project, index) }\r\n            .filter(predicate)\r\n            .any { checkbox -> !checkbox.checked }\r\n    }\r\n\r\n    private fun notAllSubmodulesActive(project: Project): Boolean {\r\n        return modifiableState.releasePlan.getSubmodules(project.id).any { submoduleId ->\r\n            val submodulesHasCommands = !elementById(project.id.identifier).hasClass(\"withoutCommands\")\r\n            submodulesHasCommands &&\r\n                notAllCommandsOrSubmodulesActive(\r\n                    modifiableState.releasePlan.getProject(submoduleId),\r\n                    //cannot be the same command, hence we do not filter commands at all => thus we use `{ true }`\r\n                    predicate = { true }\r\n                )\r\n        }\r\n    }\r\n\r\n    private fun registerReleaseUncheckEventForDependentsAndSubmodules(project: Project) {\r\n        if (!project.isSubmodule) {\r\n            val projectIds = modifiableState.releasePlan.collectDependentsInclDependentsOfAllSubmodules(project.id)\r\n\r\n            projectIds.forEach { (projectId, dependentId) ->\r\n                modifiableState.releasePlan.getProject(dependentId).commands\r\n                    .mapWithIndex()\r\n                    .filter { (_, command) ->\r\n                        // release command will get deactivated automatically via deactivation dependency update\r\n                        if (command is ReleaseCommand) return@filter false\r\n                        val state = command.state\r\n                        state is CommandState.Waiting && state.dependencies.contains(projectId)\r\n                    }\r\n                    .forEach { (index, _) ->\r\n                        registerForProjectEvent(project, EVENT_RELEASE_TOGGLE_UNCHECKED) {\r\n                            Pipeline.getToggle(modifiableState.releasePlan.getProject(dependentId), index).uncheck()\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun HTMLInputElement.uncheck() = changeChecked(this, false)\r\n\r\n    private fun changeChecked(toggle: HTMLInputElement, checked: Boolean) {\r\n        if (toggle.checked == checked) return\r\n\r\n        toggle.checked = checked\r\n        Promise.resolve(0).then {\r\n            //used to avoid stack-overflow\r\n            toggle.dispatchEvent(Event(\"change\"))\r\n        }\r\n    }\r\n\r\n    private fun dispatchToggleEvent(project: Project, toggle: HTMLInputElement, event: String) {\r\n        projectElement(project).dispatchEvent(CustomEvent(event, CustomEventInit(toggle)))\r\n    }\r\n\r\n    private fun registerForProjectEvent(project: Project, event: String, callback: (Event) -> Unit) {\r\n        projectElement(project).addEventListener(event, callback)\r\n    }\r\n\r\n    private fun projectElement(project: Project) = elementById(project.id.identifier)\r\n\r\n    companion object {\r\n        private const val EVENT_TOGGLE_UNCHECKED = \"toggle.unchecked\"\r\n        private const val EVENT_RELEASE_TOGGLE_UNCHECKED = \"release.toggle.unchecked\"\r\n\r\n        fun getSlider(toggle: HTMLInputElement) = elementById(\"${toggle.id}${Pipeline.SLIDER_SUFFIX}\")\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.ReleasePlan\r\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\r\nimport ch.loewenfels.depgraph.gui.components.Menu\r\nimport ch.loewenfels.depgraph.gui.components.Pipeline\r\nimport ch.loewenfels.depgraph.gui.components.textAreaWithLabel\r\nimport ch.loewenfels.depgraph.gui.components.textFieldWithLabel\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport kotlinx.html.div\r\nimport kotlinx.html.dom.append\r\nimport org.w3c.dom.asList\r\nimport kotlin.browser.document\r\n\r\nclass ContentContainer(modifiableState: ModifiableState, private val menu: Menu) {\r\n\r\n    init {\r\n        val releasePlan = modifiableState.releasePlan\r\n        val rootProjectId = releasePlan.rootProjectId\r\n        val htmlTitle = (rootProjectId as? MavenProjectId)?.artifactId ?: rootProjectId.identifier\r\n        document.title = \"Release $htmlTitle\"\r\n        releasePlan.warnings.forEach { showWarning(it) }\r\n        setInfoBubble(releasePlan.infos)\r\n        setUpConfig(releasePlan)\r\n        Pipeline(modifiableState, menu)\r\n    }\r\n\r\n    private fun setInfoBubble(messages: List<String>) {\r\n        if (messages.isNotEmpty()) {\r\n            val minimized = elementById(\"infosMinimized\")\r\n            minimized.style.display = \"block\"\r\n            minimized.addEventListener(\"click\", {\r\n                minimized.style.display = \"none\"\r\n                messages.forEach { showInfo(it) }\r\n            })\r\n        }\r\n        val messagesDiv = elementById(\"messages\")\r\n        elementById(HIDE_MESSAGES_HTML_ID).addClickEventListener {\r\n            document.querySelectorAll(\"#messages > div\")\r\n                .asList()\r\n                .forEach { messagesDiv.removeChild(it) }\r\n        }\r\n    }\r\n\r\n    private fun setUpConfig(releasePlan: ReleasePlan) {\r\n        //TODO add description for each property => see https://github.com/loewenfels/dep-graph-releaser/issues/22\r\n        elementById(\"config\").append {\r\n            div {\r\n                textFieldWithLabel(RELEASE_ID_HTML_ID, \"ReleaseId\", releasePlan.releaseId, menu)\r\n\r\n                val config = releasePlan.config\r\n                listOf(\r\n                    ConfigKey.COMMIT_PREFIX,\r\n                    ConfigKey.UPDATE_DEPENDENCY_JOB,\r\n                    ConfigKey.DRY_RUN_JOB,\r\n                    ConfigKey.REMOTE_REGEX,\r\n                    ConfigKey.RELATIVE_PATH_EXCLUDE_PROJECT_REGEX,\r\n                    ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REGEX,\r\n                    ConfigKey.RELATIVE_PATH_TO_GIT_REPO_REPLACEMENT,\r\n                    ConfigKey.REGEX_PARAMS,\r\n                    ConfigKey.INITIAL_RELEASE_JSON\r\n                ).forEach { key ->\r\n                    textFieldWithLabel(\"config-${key.asString()}\", key.asString(), config[key] ?: \"\", menu)\r\n                }\r\n                val key = ConfigKey.JOB_MAPPING\r\n                textAreaWithLabel(\r\n                    \"config-${key.asString()}\", key.asString(), config[key]?.replace(\"|\", \"\\n\") ?: \"\", menu\r\n                )\r\n            }\r\n        }\r\n        val initialSite = getTextField(\"config-${ConfigKey.INITIAL_RELEASE_JSON.asString()}\")\r\n        if (initialSite.value.isBlank()) {\r\n            initialSite.value = App.determineJsonUrl() ?: \"\"\r\n        }\r\n    }\r\n\r\n    companion object {\r\n        const val RELEASE_ID_HTML_ID = \"releaseId\"\r\n        const val HIDE_MESSAGES_HTML_ID = \"hideMessages\"\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui\n\nimport ch.loewenfels.depgraph.gui.jobexecution.GITHUB_NEW_ISSUE\nimport kotlinx.html.HTMLTag\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.events.Event\nimport kotlin.dom.addClass\nimport kotlin.dom.hasClass\nimport kotlin.dom.removeClass\nimport kotlin.js.Promise\n\n/**\n * Hack to get the underlying [HTMLElement] of the the given [HTMLTag]. Fails if\n * a) downstream is renamed (is a private field)\n * b) variable mangling process changes in kotlin, then it might use another name than path_0\n */\nfun HTMLTag.getUnderlyingHtmlElement(): HTMLElement {\n    var d = this.consumer.asDynamic()\n    if (d.downstream != null) {\n        d = d.downstream\n    }\n    val arr = d.path_0.toArray() as Array<HTMLElement>\n    return arr[arr.size - 1]\n}\n\nfun HTMLElement.addClickEventListener(options: dynamic = js(\"({})\"), action: (Event) -> Any) {\n    this.addEventListener(\"click\", { withErrorHandling(it, action) }, options)\n}\n\nfun HTMLElement.addChangeEventListener(options: dynamic = js(\"({})\"), action: (Event) -> Any) {\n    this.addEventListener(\"change\", { withErrorHandling(it, action) }, options)\n}\n\nfun HTMLElement.toggleClass(cssClass: String) {\n    if (hasClass(cssClass)) {\n        removeClass(cssClass)\n    } else {\n        addClass(cssClass)\n    }\n}\n\nprivate fun withErrorHandling(event: Event, action: (Event) -> Any) {\n    Promise.resolve(1).then {\n        action(event)\n    }.catch { t ->\n        val message = \"An unexpected error occurred.\" +\n            \"\\nPlease report a bug with the following information at $GITHUB_NEW_ISSUE\"\n        showThrowableAndThrow(Error(message, t))\n    }\n}\n\nfun HTMLElement.getOldTitle() = this.asDynamic().oldTitle as String\nfun HTMLElement.getOldTitleOrNull() = this.asDynamic().oldTitle as? String\nfun HTMLElement.setTitleSaveOld(newTitle: String) {\n    if (this.title != newTitle) {\n        this.asDynamic().oldTitle = this.title\n    }\n    this.title = newTitle\n}\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.ReleasePlan\r\n\r\nabstract class BaseJobExecutionDataFactory(\r\n    protected val defaultJenkinsBaseUrl: String,\r\n    protected val releasePlan: ReleasePlan\r\n) : JobExecutionDataFactory {\r\n\r\n    protected fun requireConfigEntry(config: Map<ConfigKey, String>, key: ConfigKey) {\r\n        require(config.containsKey(key)) {\r\n            \"$key is not defined in settings\"\r\n        }\r\n    }\r\n\r\n    protected fun getConfig(key: ConfigKey) = releasePlan.getConfig(key)\r\n\r\n    protected fun getJobUrl(key: ConfigKey) = getJobUrl(defaultJenkinsBaseUrl, getConfig(key))\r\n    protected fun getJobUrl(jenkinsBaseUrl: String, jobName: String) = \"$jenkinsBaseUrl/job/$jobName\"\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport kotlin.js.Promise\r\n\r\n/**\r\n * Responsible to extract a build number from a triggered job.\r\n */\r\ninterface BuilderNumberExtractor {\r\n\r\n    /**\r\n     * Eventually returns the build number.\r\n     */\r\n    fun extract(): Promise<Int>\r\n\r\n    companion object {\r\n       val numberRegex = Regex(\"<number>([0-9]+)</number>\")\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.jobexecution.BuilderNumberExtractor.Companion.numberRegex\r\nimport ch.loewenfels.depgraph.gui.unwrapPromise\r\nimport org.w3c.fetch.RequestInit\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nclass BuildHistoryBasedBuildNumberExtractor(\r\n    private val authData: AuthData,\r\n    private val jobExecutionData: JobExecutionData\r\n) : BuilderNumberExtractor {\r\n\r\n    override fun extract(): Promise<Int> {\r\n        val headers = createHeaderWithAuthAndCrumb(authData)\r\n        val init = createGetRequest(headers)\r\n        return window.fetch(\"${jobExecutionData.jobBaseUrl}api/xml?xpath=//build/number&wrapper=builds\", init)\r\n            .then(::checkStatusOk)\r\n            .then { searchBuildNumber(it.second, init) }\r\n            .unwrapPromise()\r\n    }\r\n\r\n    private fun searchBuildNumber(body: String, init: RequestInit): Promise<Int> {\r\n        val matchResult = numberRegex.find(body)\r\n            ?: throw IllegalStateException(\"no job run at ${jobExecutionData.jobBaseUrl} so far, as consequence we cannot extract a build number.\")\r\n        val parametersRegex = Regex(createParameterRegexPattern(jobExecutionData.identifyingParams))\r\n        return searchBuildNumber(matchResult, parametersRegex, init)\r\n    }\r\n\r\n    private fun searchBuildNumber(matchResult: MatchResult, parametersRegex: Regex, init: RequestInit): Promise<Int> {\r\n        val buildNumber = matchResult.groupValues[1].toInt()\r\n        return window.fetch(\"${jobExecutionData.jobBaseUrl}$buildNumber/api/xml\", init)\r\n            .then(::checkStatusOk)\r\n            .then { (_, body) ->\r\n                if (parametersRegex.containsMatchIn(body)) {\r\n                    Promise.resolve(buildNumber)\r\n                } else {\r\n                    val newMatchResult = matchResult.next()\r\n                        ?: throw IllegalStateException(\"No job matches the given identifying parameters at ${jobExecutionData.jobBaseUrl}.\\nRegex used: ${parametersRegex.pattern}\")\r\n                    searchBuildNumber(newMatchResult, parametersRegex, init)\r\n                }\r\n            }.unwrapPromise()\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsUpdateDependency\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.M2ReleaseCommand\r\nimport ch.loewenfels.depgraph.gui.components.Pipeline\r\n\r\nprivate typealias GroupIdArtifactIdAndNewVersion = Triple<String, String, String>\r\n\r\nclass DryRunJobExecutionDataFactory(\r\n    defaultJenkinsBaseUrl: String,\r\n    releasePlan: ReleasePlan\r\n) : BaseJobExecutionDataFactory(defaultJenkinsBaseUrl, releasePlan) {\r\n\r\n    init {\r\n        checkConfig(releasePlan.config)\r\n    }\r\n\r\n    private fun checkConfig(config: Map<ConfigKey, String>) {\r\n        requireConfigEntry(config, ConfigKey.UPDATE_DEPENDENCY_JOB)\r\n        requireConfigEntry(config, ConfigKey.DRY_RUN_JOB)\r\n    }\r\n\r\n    override fun create(project: Project, command: Command): JobExecutionData {\r\n        return when (command) {\r\n            is JenkinsUpdateDependency -> triggerUpdateDependency(project, command)\r\n            is M2ReleaseCommand -> triggerRelease(project)\r\n            else -> throw UnsupportedOperationException(\"We do not (yet) support the command: $command\")\r\n        }\r\n    }\r\n\r\n    private fun triggerUpdateDependency(project: Project, command: JenkinsUpdateDependency): JobExecutionData {\r\n        val jobName = \"dry update dependency of ${project.id.identifier}\"\r\n        val (params, identifyingParams) = createUpdateDependencyParams(project, command)\r\n        return createJobExecutionData(jobName, params, identifyingParams)\r\n    }\r\n\r\n    private fun triggerRelease(project: Project): JobExecutionData {\r\n        val jobName = \"dry release ${project.id.identifier}\"\r\n        val (params, identifyingParams) = createReleaseParams(project)\r\n        return createJobExecutionData(jobName, params, identifyingParams)\r\n    }\r\n\r\n    private fun createUpdateDependencyParams(\r\n        project: Project,\r\n        command: JenkinsUpdateDependency\r\n    ): Pair<String, Map<String, String>> {\r\n        val releaseVersion = \"\"\r\n        val triple = determineGroupIdArtifactIdAndNewVersion(command)\r\n        return createParams(\"update\", project, releaseVersion, triple) to mapOf(\r\n            \"releaseId\" to releasePlan.releaseId,\r\n            \"groupId\" to triple.first,\r\n            \"artifactId\" to triple.second,\r\n            \"newVersion\" to triple.third\r\n        )\r\n    }\r\n\r\n    private fun determineGroupIdArtifactIdAndNewVersion(command: JenkinsUpdateDependency): GroupIdArtifactIdAndNewVersion {\r\n        val dependency = releasePlan.getProject(command.projectId)\r\n        val dependencyMavenProjectId = dependency.id as MavenProjectId\r\n        val groupId = dependencyMavenProjectId.groupId\r\n        val artifactId = dependencyMavenProjectId.artifactId\r\n        val newVersion = \"${dependency.releaseVersion}-${releasePlan.releaseId}\"\r\n        return Triple(groupId, artifactId, newVersion)\r\n    }\r\n\r\n    private fun createReleaseParams(project: Project): Pair<String, Map<String, String>> {\r\n        val releaseVersion = \"${project.releaseVersion}-${releasePlan.releaseId}\"\r\n        return createParams(\"release\", project, releaseVersion, GroupIdArtifactIdAndNewVersion(\"\", \"\", \"\")) to mapOf(\r\n            \"releaseId\" to releasePlan.releaseId,\r\n            \"releaseVersion\" to releaseVersion\r\n        )\r\n    }\r\n\r\n    private fun createParams(\r\n        commandName: String,\r\n        project: Project,\r\n        releaseVersion: String,\r\n        groupIdArtifactIdAndNewVersion: GroupIdArtifactIdAndNewVersion\r\n    ): String {\r\n        val (groupId, artifactId, newVersion) = groupIdArtifactIdAndNewVersion\r\n        val skipCheckout = if (isFirstTriggeredCommand(project)) \"false\" else \"true\"\r\n        return \"command=$commandName\" +\r\n            \"&pathToProject=${project.relativePath}\" +\r\n            \"&skipCheckout=$skipCheckout\" +\r\n            \"&releaseId=${releasePlan.releaseId}\" +\r\n            //release specific\r\n            \"&releaseVersion=$releaseVersion\" +\r\n            //update specific\r\n            \"&groupId=$groupId\" +\r\n            \"&artifactId=$artifactId\" +\r\n            \"&newVersion=$newVersion\"\r\n    }\r\n\r\n    private fun isFirstTriggeredCommand(project: Project): Boolean {\r\n        if (project.isSubmodule) return isFirstTriggeredCommand(searchTopMultiModule(project.id))\r\n        return !commandRanOnProjectOrSubmodules(project)\r\n    }\r\n\r\n    private fun searchTopMultiModule(projectId: ProjectId): Project\r\n        = releasePlan.getAllSubmodules().entries\r\n            .find { (_, v) -> v.contains(projectId) }\r\n            .let { if(it != null) searchTopMultiModule(it.key) else releasePlan.getProject(projectId) }\r\n\r\n    private fun commandRanOnProjectOrSubmodules(project: Project): Boolean {\r\n        var commandAlreadyRan = project.commands.withIndex().any { (index, command) ->\r\n            val state = getState(project, index, command)\r\n            state === CommandState.Succeeded || state === CommandState.Failed\r\n        }\r\n        val submodules = releasePlan.getSubmodules(project.id)\r\n        commandAlreadyRan = commandAlreadyRan || (submodules.isNotEmpty() && submodules.any {\r\n            commandRanOnProjectOrSubmodules(releasePlan.getProject(it))\r\n        })\r\n        return commandAlreadyRan\r\n    }\r\n\r\n    private fun getState(\r\n        project: Project,\r\n        index: Int,\r\n        command: Command\r\n    ): CommandState {\r\n        return if (releasePlan.state != ReleaseState.IN_PROGRESS) {\r\n            Pipeline.getCommandState(project.id, index)\r\n        } else {\r\n            command.state\r\n        }\r\n    }\r\n\r\n    private fun createJobExecutionData(\r\n        jobName: String,\r\n        params: String,\r\n        identifyingParams: Map<String, String>\r\n    ): JobExecutionData {\r\n        val jobUrl = getJobUrl(ConfigKey.DRY_RUN_JOB)\r\n        return JobExecutionData.buildWithParameters(jobName, jobUrl, params, identifyingParams)\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.internal.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport org.w3c.fetch.*\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nfun checkStatusOk(response: Response): Promise<Pair<Response, String>> {\r\n    @Suppress(\"UNCHECKED_CAST\" /* is non-null string because we do not ignore an error code */)\r\n    return checkResponseIgnore(response) { false } as Promise<Pair<Response, String>>\r\n}\r\n\r\nfun checkStatusOkOr403(response: Response) = checkResponseIgnoreStatus(response, 403)\r\nfun checkStatusOkOr404(response: Response) = checkResponseIgnoreStatus(response, 404)\r\n\r\nprivate fun checkResponseIgnoreStatus(response: Response, errorStatus: Int)\r\n    = checkResponseIgnore(response) { errorStatus.toShort() == response.status }\r\n\r\nfun checkStatusIgnoreOpaqueRedirect(response: Response)\r\n    = checkResponseIgnore(response) { response.type == ResponseType.OPAQUEREDIRECT }\r\n\r\nprivate fun checkResponseIgnore(\r\n    response: Response,\r\n    ignoreStatusNotOkPredicate: () -> Boolean\r\n): Promise<Pair<Response, String?>> {\r\n    return response.text().then { text ->\r\n        if (ignoreStatusNotOkPredicate()) {\r\n            response to null\r\n        } else {\r\n            check(response.ok) { \"response was not ok, ${response.status}: ${response.statusText}\\n$text\" }\r\n            response to text\r\n        }\r\n    }\r\n}\r\n\r\n@Suppress(\"UnsafeCastFromDynamic\")\r\nfun createFetchInitWithCredentials(): RequestInit {\r\n    val init = js(\"({})\")\r\n    init.credentials = \"include\"\r\n    init.method = RequestVerb.GET\r\n    return init\r\n}\r\n\r\n\r\nfun createHeaderWithAuthAndCrumb(authData: AuthData): dynamic {\r\n    val headers = js(\"({})\")\r\n    addAuthentication(headers, authData.usernameAndApiToken)\r\n    if (authData.crumbWithId != null) {\r\n        headers[authData.crumbWithId.id] = authData.crumbWithId.crumb\r\n    }\r\n    return headers\r\n}\r\n\r\nfun addAuthentication(headers: dynamic, usernameAndApiToken: UsernameAndApiToken) {\r\n    val base64UsernameAndToken = window.btoa(\"${usernameAndApiToken.username}:${usernameAndApiToken.token}\")\r\n    headers[\"Authorization\"] = \"Basic $base64UsernameAndToken\"\r\n}\r\n\r\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\r\nexternal interface RequestVerb {\r\n    companion object\r\n}\r\n\r\ninline val RequestVerb.Companion.GET get() = \"GET\".asDynamic().unsafeCast<RequestVerb>()\r\ninline val RequestVerb.Companion.POST get() = \"POST\".asDynamic().unsafeCast<RequestVerb>()\r\n\r\nfun createGetRequest(headers: dynamic): RequestInit = createRequestInit(null, RequestVerb.GET, headers)\r\n\r\nfun createRequestInit(\r\n    body: String?,\r\n    method: RequestVerb,\r\n    headers: dynamic\r\n): RequestInit {\r\n    val init = RequestInit(\r\n        body = body,\r\n        method = method.unsafeCast<String>(),\r\n        headers = headers,\r\n        mode = RequestMode.CORS,\r\n        cache = org.w3c.fetch.RequestCache.NO_CACHE,\r\n        redirect = org.w3c.fetch.RequestRedirect.MANUAL,\r\n        credentials = org.w3c.fetch.RequestCredentials.INCLUDE,\r\n        referrer = \"no-referrer\",\r\n        referrerPolicy = \"no-referrer\"\r\n    )\r\n    //have to remove properties because RequestInit sets them to null which is not what we want/is not valid\r\n    js(\r\n        \"delete init.integrity;\" +\r\n            \"delete init.keepalive;\" +\r\n            \"delete init.window;\"\r\n    )\r\n    return init\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.fetch\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Headers](https://developer.mozilla.org/en/docs/Web/API/Headers) to Kotlin\n */\npublic external open class Headers(init: dynamic = definedExternally) {\n    fun append(name: String, value: String): Unit\n    fun delete(name: String): Unit\n    fun get(name: String): String?\n    fun has(name: String): Boolean\n    fun set(name: String, value: String): Unit\n}\n\n/**\n * Exposes the JavaScript [Body](https://developer.mozilla.org/en/docs/Web/API/Body) to Kotlin\n */\npublic external interface Body {\n    val bodyUsed: Boolean\n    fun arrayBuffer(): Promise<ArrayBuffer>\n    fun blob(): Promise<Blob>\n    fun formData(): Promise<FormData>\n    fun json(): Promise<Any?>\n    fun text(): Promise<String>\n}\n\n/**\n * Exposes the JavaScript [Request](https://developer.mozilla.org/en/docs/Web/API/Request) to Kotlin\n */\npublic external open class Request(input: dynamic, init: RequestInit = definedExternally) : Body {\n    open val method: String\n    open val url: String\n    open val headers: Headers\n    open val type: RequestType\n    open val destination: RequestDestination\n    open val referrer: String\n    open val referrerPolicy: dynamic\n    open val mode: RequestMode\n    open val credentials: RequestCredentials\n    open val cache: RequestCache\n    open val redirect: RequestRedirect\n    open val integrity: String\n    open val keepalive: Boolean\n    override val bodyUsed: Boolean\n    fun clone(): Request\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n}\n\npublic external interface RequestInit {\n    var method: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var body: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrer: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var referrerPolicy: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var mode: RequestMode?\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials?\n        get() = definedExternally\n        set(value) = definedExternally\n    var cache: RequestCache?\n        get() = definedExternally\n        set(value) = definedExternally\n    var redirect: RequestRedirect?\n        get() = definedExternally\n        set(value) = definedExternally\n    var integrity: String?\n        get() = definedExternally\n        set(value) = definedExternally\n    var keepalive: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var window: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RequestInit(method: String? = null, headers: dynamic = null, body: dynamic = null, referrer: String? = null, referrerPolicy: dynamic = null, mode: RequestMode? = null, credentials: RequestCredentials? = null, cache: RequestCache? = null, redirect: RequestRedirect? = null, integrity: String? = null, keepalive: Boolean? = null, window: Any? = null): RequestInit {\n    val o = js(\"({})\")\n\n    o[\"method\"] = method\n    o[\"headers\"] = headers\n    o[\"body\"] = body\n    o[\"referrer\"] = referrer\n    o[\"referrerPolicy\"] = referrerPolicy\n    o[\"mode\"] = mode\n    o[\"credentials\"] = credentials\n    o[\"cache\"] = cache\n    o[\"redirect\"] = redirect\n    o[\"integrity\"] = integrity\n    o[\"keepalive\"] = keepalive\n    o[\"window\"] = window\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [Response](https://developer.mozilla.org/en/docs/Web/API/Response) to Kotlin\n */\npublic external open class Response(body: dynamic = definedExternally, init: ResponseInit = definedExternally) : Body {\n    open val type: ResponseType\n    open val url: String\n    open val redirected: Boolean\n    open val status: Short\n    open val ok: Boolean\n    open val statusText: String\n    open val headers: Headers\n    open val body: dynamic\n    open val trailer: Promise<Headers>\n    override val bodyUsed: Boolean\n    fun clone(): Response\n    override fun arrayBuffer(): Promise<ArrayBuffer>\n    override fun blob(): Promise<Blob>\n    override fun formData(): Promise<FormData>\n    override fun json(): Promise<Any?>\n    override fun text(): Promise<String>\n\n    companion object {\n        fun error(): Response\n        fun redirect(url: String, status: Short = definedExternally): Response\n    }\n}\n\npublic external interface ResponseInit {\n    var status: Short? /* = 200 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var statusText: String? /* = \"OK\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var headers: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ResponseInit(status: Short? = 200, statusText: String? = \"OK\", headers: dynamic = null): ResponseInit {\n    val o = js(\"({})\")\n\n    o[\"status\"] = status\n    o[\"statusText\"] = statusText\n    o[\"headers\"] = headers\n\n    return o\n}\n\n/* please, don't implement this interface! */\npublic external interface RequestType {\n    companion object\n}\npublic inline val RequestType.Companion.EMPTY: RequestType get() = \"\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.AUDIO: RequestType get() = \"audio\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.FONT: RequestType get() = \"font\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.IMAGE: RequestType get() = \"image\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.SCRIPT: RequestType get() = \"script\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.STYLE: RequestType get() = \"style\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.TRACK: RequestType get() = \"track\".asDynamic().unsafeCast<RequestType>()\npublic inline val RequestType.Companion.VIDEO: RequestType get() = \"video\".asDynamic().unsafeCast<RequestType>()\n\n/* please, don't implement this interface! */\npublic external interface RequestDestination {\n    companion object\n}\npublic inline val RequestDestination.Companion.EMPTY: RequestDestination get() = \"\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.DOCUMENT: RequestDestination get() = \"document\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.EMBED: RequestDestination get() = \"embed\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.FONT: RequestDestination get() = \"font\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.IMAGE: RequestDestination get() = \"image\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.MANIFEST: RequestDestination get() = \"manifest\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.MEDIA: RequestDestination get() = \"media\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.OBJECT: RequestDestination get() = \"object\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.REPORT: RequestDestination get() = \"report\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.SCRIPT: RequestDestination get() = \"script\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.SERVICEWORKER: RequestDestination get() = \"serviceworker\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.SHAREDWORKER: RequestDestination get() = \"sharedworker\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.STYLE: RequestDestination get() = \"style\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.WORKER: RequestDestination get() = \"worker\".asDynamic().unsafeCast<RequestDestination>()\npublic inline val RequestDestination.Companion.XSLT: RequestDestination get() = \"xslt\".asDynamic().unsafeCast<RequestDestination>()\n\n/* please, don't implement this interface! */\npublic external interface RequestMode {\n    companion object\n}\npublic inline val RequestMode.Companion.NAVIGATE: RequestMode get() = \"navigate\".asDynamic().unsafeCast<RequestMode>()\npublic inline val RequestMode.Companion.SAME_ORIGIN: RequestMode get() = \"same-origin\".asDynamic().unsafeCast<RequestMode>()\npublic inline val RequestMode.Companion.NO_CORS: RequestMode get() = \"no-cors\".asDynamic().unsafeCast<RequestMode>()\npublic inline val RequestMode.Companion.CORS: RequestMode get() = \"cors\".asDynamic().unsafeCast<RequestMode>()\n\n/* please, don't implement this interface! */\npublic external interface RequestCredentials {\n    companion object\n}\npublic inline val RequestCredentials.Companion.OMIT: RequestCredentials get() = \"omit\".asDynamic().unsafeCast<RequestCredentials>()\npublic inline val RequestCredentials.Companion.SAME_ORIGIN: RequestCredentials get() = \"same-origin\".asDynamic().unsafeCast<RequestCredentials>()\npublic inline val RequestCredentials.Companion.INCLUDE: RequestCredentials get() = \"include\".asDynamic().unsafeCast<RequestCredentials>()\n\n/* please, don't implement this interface! */\npublic external interface RequestCache {\n    companion object\n}\npublic inline val RequestCache.Companion.DEFAULT: RequestCache get() = \"default\".asDynamic().unsafeCast<RequestCache>()\npublic inline val RequestCache.Companion.NO_STORE: RequestCache get() = \"no-store\".asDynamic().unsafeCast<RequestCache>()\npublic inline val RequestCache.Companion.RELOAD: RequestCache get() = \"reload\".asDynamic().unsafeCast<RequestCache>()\npublic inline val RequestCache.Companion.NO_CACHE: RequestCache get() = \"no-cache\".asDynamic().unsafeCast<RequestCache>()\npublic inline val RequestCache.Companion.FORCE_CACHE: RequestCache get() = \"force-cache\".asDynamic().unsafeCast<RequestCache>()\npublic inline val RequestCache.Companion.ONLY_IF_CACHED: RequestCache get() = \"only-if-cached\".asDynamic().unsafeCast<RequestCache>()\n\n/* please, don't implement this interface! */\npublic external interface RequestRedirect {\n    companion object\n}\npublic inline val RequestRedirect.Companion.FOLLOW: RequestRedirect get() = \"follow\".asDynamic().unsafeCast<RequestRedirect>()\npublic inline val RequestRedirect.Companion.ERROR: RequestRedirect get() = \"error\".asDynamic().unsafeCast<RequestRedirect>()\npublic inline val RequestRedirect.Companion.MANUAL: RequestRedirect get() = \"manual\".asDynamic().unsafeCast<RequestRedirect>()\n\n/* please, don't implement this interface! */\npublic external interface ResponseType {\n    companion object\n}\npublic inline val ResponseType.Companion.BASIC: ResponseType get() = \"basic\".asDynamic().unsafeCast<ResponseType>()\npublic inline val ResponseType.Companion.CORS: ResponseType get() = \"cors\".asDynamic().unsafeCast<ResponseType>()\npublic inline val ResponseType.Companion.DEFAULT: ResponseType get() = \"default\".asDynamic().unsafeCast<ResponseType>()\npublic inline val ResponseType.Companion.ERROR: ResponseType get() = \"error\".asDynamic().unsafeCast<ResponseType>()\npublic inline val ResponseType.Companion.OPAQUE: ResponseType get() = \"opaque\".asDynamic().unsafeCast<ResponseType>()\npublic inline val ResponseType.Companion.OPAQUEREDIRECT: ResponseType get() = \"opaqueredirect\".asDynamic().unsafeCast<ResponseType>()\n\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\ndata class UsernameAndApiToken(val username: String, val token: String)\r\n\r\ndata class CrumbWithId(val id: String, val crumb: String)\r\n\r\ndata class AuthData(val usernameAndApiToken: UsernameAndApiToken, val crumbWithId: CrumbWithId?)\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport org.w3c.fetch.Response\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nfun issueCrumb(\r\n    jenkinsBaseUrl: String,\r\n    usernameAndApiToken: UsernameAndApiToken\r\n): Promise<AuthData> {\r\n    val url = \"$jenkinsBaseUrl/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\\\":\\\",//crumb)\"\r\n    val headers = createHeaderWithAuthAndCrumb(AuthData(usernameAndApiToken, null))\r\n    val init = createGetRequest(headers)\r\n    return window.fetch(url, init)\r\n        .then(::checkStatusOkOr404)\r\n        .catch<Pair<Response, String?>> {\r\n            throw Error(\"Cannot issue a crumb\", it)\r\n        }.then { (_, crumbWithIdString) ->\r\n            val crumbWithId = if (crumbWithIdString != null) {\r\n                val (id, crumb) = crumbWithIdString.split(':')\r\n                CrumbWithId(id, crumb)\r\n            } else {\r\n                null\r\n            }\r\n            AuthData(usernameAndApiToken, crumbWithId)\r\n        }\r\n}\r\n\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.*\r\nimport org.w3c.fetch.Response\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nclass JenkinsJobExecutor(\r\n    private val usernameTokenRegistry: UsernameTokenRegistry\r\n) : JobExecutor {\r\n\r\n    override fun trigger(\r\n        jobExecutionData: JobExecutionData,\r\n        jobQueuedHook: (queuedItemUrl: String?) -> Promise<*>,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int,\r\n        verbose: Boolean\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        val jobName = jobExecutionData.jobName\r\n        return issueCrumb(jobExecutionData).then { authData: AuthData ->\r\n            triggerJob(authData, jobExecutionData)\r\n                .then(::checkStatusIgnoreOpaqueRedirect)\r\n                .catch<Pair<Response, String>> {\r\n                    throw Error(\r\n                        \"Could not trigger the job $jobName.\" +\r\n                            \"\\nPlease visit ${jobExecutionData.jobBaseUrl} to see if it was triggered nonetheless.\" +\r\n                            \"\\nYou can manually set the command to Succeeded if the job was triggered/executed and ended successfully.\"\r\n                        , it\r\n                    )\r\n                }.then { (response, _) ->\r\n                    jobExecutionData.queuedItemUrlExtractor.extract(authData, response, jobExecutionData)\r\n                }.then { nullableQueuedItemUrl: String? ->\r\n                    showInfoQueuedItemIfVerbose(verbose, nullableQueuedItemUrl, jobName)\r\n                    val queuedItemUrl = getQueuedItemUrlOrNull(nullableQueuedItemUrl)\r\n                    jobQueuedHook(queuedItemUrl).then {\r\n                        startOrResumeFromExtractBuildNumber(\r\n                            jobExecutionData,\r\n                            nullableQueuedItemUrl,\r\n                            jobStartedHook,\r\n                            pollEverySecond,\r\n                            maxWaitingTimeForCompletenessInSeconds,\r\n                            authData,\r\n                            verbose\r\n                        )\r\n                    }\r\n                }\r\n        }.unwrap3Promise()\r\n    }\r\n\r\n    private fun issueCrumb(jobExecutionData: JobExecutionData): Promise<AuthData> {\r\n        val jenkinsBaseUrl = jobExecutionData.getJenkinsBaseUrl()\r\n        val usernameAndApiToken = usernameTokenRegistry.forHostOrThrow(jenkinsBaseUrl)\r\n        return issueCrumb(jenkinsBaseUrl, usernameAndApiToken)\r\n    }\r\n\r\n    private fun startOrResumeFromExtractBuildNumber(\r\n        jobExecutionData: JobExecutionData,\r\n        nullableQueuedItemUrl: String?,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int,\r\n        authData: AuthData,\r\n        verbose: Boolean\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        return extractBuildNumber(nullableQueuedItemUrl, authData, jobExecutionData).then { buildNumber: Int ->\r\n            if (verbose) {\r\n                showInfo(\r\n                    \"${jobExecutionData.jobName} started with build number $buildNumber, wait for completion...\",\r\n                    2000\r\n                )\r\n            }\r\n            jobStartedHook(buildNumber).then {\r\n                pollJobForCompletion(\r\n                    authData,\r\n                    jobExecutionData,\r\n                    buildNumber,\r\n                    pollEverySecond,\r\n                    maxWaitingTimeForCompletenessInSeconds\r\n                )\r\n            }\r\n        }.unwrap2Promise()\r\n    }\r\n\r\n    private fun getQueuedItemUrlOrNull(nullableQueuedItemUrl: String?) =\r\n        if (nullableQueuedItemUrl != null) \"${nullableQueuedItemUrl}api/xml/\" else null\r\n\r\n    private fun triggerJob(authData: AuthData, jobExecutionData: JobExecutionData): Promise<Response> {\r\n        val headers = createHeaderWithAuthAndCrumb(authData)\r\n        headers[\"content-type\"] = \"application/x-www-form-urlencoded; charset=utf-8\"\r\n        val init = createRequestInit(jobExecutionData.body, RequestVerb.POST, headers)\r\n        return window.fetch(jobExecutionData.jobTriggerUrl, init)\r\n    }\r\n\r\n    private fun showInfoQueuedItemIfVerbose(\r\n        verbose: Boolean,\r\n        nullableQueuedItemUrl: String?,\r\n        jobName: String\r\n    ) {\r\n        if (verbose) {\r\n            if (nullableQueuedItemUrl != null) {\r\n                showInfo(\r\n                    \"Queued $jobName successfully, wait for execution...\\nQueued item URL: ${nullableQueuedItemUrl}api/xml\",\r\n                    2000\r\n                )\r\n            } else {\r\n                showInfo(\r\n                    \"$jobName is probably already running (queued item could not be found), trying to fetch execution number from Job history.\",\r\n                    2000\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun extractBuildNumber(\r\n        nullableQueuedItemUrl: String?,\r\n        authData: AuthData,\r\n        jobExecutionData: JobExecutionData\r\n    ): Promise<Int> {\r\n        return if (nullableQueuedItemUrl != null) {\r\n            QueuedItemBasedBuildNumberExtractor(authData, nullableQueuedItemUrl).extract()\r\n        } else {\r\n            BuildHistoryBasedBuildNumberExtractor(authData, jobExecutionData).extract()\r\n        }\r\n    }\r\n\r\n    override fun rePollQueueing(\r\n        jobExecutionData: JobExecutionData,\r\n        queuedItemUrl: String,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        return issueCrumb(jobExecutionData).then { authData ->\r\n            startOrResumeFromExtractBuildNumber(\r\n                jobExecutionData,\r\n                queuedItemUrl,\r\n                jobStartedHook,\r\n                pollEverySecond,\r\n                maxWaitingTimeForCompletenessInSeconds,\r\n                authData,\r\n                verbose = false\r\n            )\r\n        }.unwrapPromise()\r\n    }\r\n\r\n    override fun rePoll(\r\n        jobExecutionData: JobExecutionData,\r\n        buildNumber: Int,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        val jenkinsBaseUrl = jobExecutionData.getJenkinsBaseUrl()\r\n        val usernameAndApiToken = usernameTokenRegistry.forHostOrThrow(jenkinsBaseUrl)\r\n        return issueCrumb(jenkinsBaseUrl, usernameAndApiToken).then { authData ->\r\n            pollJobForCompletion(\r\n                authData,\r\n                jobExecutionData,\r\n                buildNumber,\r\n                pollEverySecond,\r\n                maxWaitingTimeForCompletenessInSeconds\r\n            )\r\n        }.unwrapPromise()\r\n    }\r\n\r\n\r\n    private fun pollJobForCompletion(\r\n        authData: AuthData,\r\n        jobExecutionData: JobExecutionData,\r\n        buildNumber: Int,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        return sleep(pollEverySecond * 500) {\r\n            pollAndExtract(\r\n                authData,\r\n                \"${jobExecutionData.jobBaseUrl}$buildNumber/api/xml\",\r\n                resultRegex,\r\n                pollEverySecond,\r\n                maxWaitingTimeForCompletenessInSeconds,\r\n                errorHandler = { e -> throw e }\r\n            )\r\n                .then { result -> buildNumber to result }\r\n                .then { (buildNumber, result) ->\r\n                    check(result == SUCCESS) {\r\n                        \"${jobExecutionData.jobName} failed, job did not end with status $SUCCESS but $result.\" +\r\n                            \"\\nVisit ${jobExecutionData.jobBaseUrl}$buildNumber/$endOfConsoleUrlSuffix for further information\"\r\n                    }\r\n                    authData to buildNumber\r\n                }\r\n        }.unwrapPromise()\r\n    }\r\n\r\n    override fun pollAndExtract(\r\n        authData: AuthData,\r\n        url: String,\r\n        regex: Regex,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeInSeconds: Int,\r\n        errorHandler: (PollTimeoutException) -> Nothing\r\n    ): Promise<String> {\r\n        return Poller.pollAndExtract(authData, url, regex, pollEverySecond, maxWaitingTimeInSeconds, errorHandler)\r\n    }\r\n\r\n    companion object {\r\n        private val resultRegex = Regex(\"<result>([A-Z]+)</result>\")\r\n        private const val SUCCESS = \"SUCCESS\"\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\n\nimport ch.loewenfels.depgraph.regex.noneOrSomeChars\n\nfun createParameterRegexPattern(parameters: Map<String, String>): String\n    = parameters.entries.joinToString(noneOrSomeChars) { (k, v) ->\n        \"<parameter$noneOrSomeChars\" +\n            \"<name>$k</name>$noneOrSomeChars\" +\n            \"<value>$v</value>$noneOrSomeChars\" +\n            \"</parameter>$noneOrSomeChars\"\n    }\n\nfun toQueryParameters(parameters: Map<String, String>): String\n    = parameters.entries.joinToString(\"&\") { (k, v) -> \"$k=$v\" }\n\nconst val endOfConsoleUrlSuffix = \"console#footer\"\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\n@Suppress(\"DataClassPrivateConstructor\")\r\ndata class JobExecutionData private constructor(\r\n    val jobName: String,\r\n    val jobBaseUrl: String,\r\n    val jobTriggerUrl: String,\r\n    val body: String,\r\n    val identifyingParams: Map<String, String>,\r\n    val queuedItemUrlExtractor: QueuedItemUrlExtractor\r\n) {\r\n    fun getJenkinsBaseUrl(): String = jobBaseUrl.substringBefore(\"/job/\")\r\n\r\n    companion object {\r\n        /**\r\n         * Uses \"[jobBaseUrl]buildWithParameters\" for [jobTriggerUrl].\r\n         */\r\n        fun buildWithParameters(\r\n            jobName: String,\r\n            jobBaseUrl: String,\r\n            body: String,\r\n            identifyingParams: Map<String, String>\r\n        ): JobExecutionData {\r\n            val jobBaseUrlWithSlash = assureEndsWithSlash(jobBaseUrl)\r\n            val jobTriggerUrl = \"${jobBaseUrlWithSlash}buildWithParameters\"\r\n            return create(\r\n                jobName,\r\n                jobBaseUrlWithSlash,\r\n                jobTriggerUrl,\r\n                body,\r\n                identifyingParams,\r\n                LocationBasedQueuedItemUrlExtractor\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Uses \"[jobBaseUrl]m2release/submit\" for [jobTriggerUrl].\r\n         */\r\n        fun m2ReleaseSubmit(\r\n            jobName: String,\r\n            jobBaseUrl: String,\r\n            body: String,\r\n            releaseVersion: String,\r\n            nextDevVersion: String\r\n        ): JobExecutionData {\r\n            val jobBaseUrlWithSlash = assureEndsWithSlash(jobBaseUrl)\r\n            val jobTriggerUrl = \"${jobBaseUrlWithSlash}m2release/submit\"\r\n            val identifyingParams = mapOf(\r\n                \"MVN_RELEASE_VERSION\" to releaseVersion,\r\n                \"MVN_DEV_VERSION\" to nextDevVersion\r\n            )\r\n            val queuedItemUrlExtractor = RestApiBasedQueuedItemUrlExtractor(identifyingParams)\r\n            return create(jobName, jobBaseUrlWithSlash, jobTriggerUrl, body, identifyingParams, queuedItemUrlExtractor)\r\n        }\r\n\r\n        private fun create(\r\n            jobName: String,\r\n            jobBaseUrl: String,\r\n            jobTriggerUrl: String,\r\n            body: String,\r\n            identifyingParams: Map<String, String>,\r\n            queuedItemUrlExtractor: QueuedItemUrlExtractor\r\n        ): JobExecutionData {\r\n            val jobBaseUrlWithSlash = assureEndsWithSlash(jobBaseUrl)\r\n            return JobExecutionData(\r\n                jobName,\r\n                jobBaseUrlWithSlash,\r\n                jobTriggerUrl,\r\n                body,\r\n                identifyingParams,\r\n                queuedItemUrlExtractor\r\n            )\r\n        }\r\n\r\n        private fun assureEndsWithSlash(jobBaseUrl: String) =\r\n            if (jobBaseUrl.endsWith(\"/\")) jobBaseUrl else \"$jobBaseUrl/\"\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport kotlin.js.Promise\r\n\r\ninterface JobExecutor {\r\n\r\n    fun trigger(\r\n        jobExecutionData: JobExecutionData,\r\n        jobQueuedHook: (queuedItemUrl: String?) -> Promise<*>,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int,\r\n        verbose: Boolean = true\r\n    ): Promise<Pair<AuthData, Int>>\r\n\r\n    fun rePollQueueing(\r\n        jobExecutionData: JobExecutionData,\r\n        queuedItemUrl: String,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>>\r\n\r\n    fun rePoll(\r\n        jobExecutionData: JobExecutionData,\r\n        buildNumber: Int,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>>\r\n\r\n    fun pollAndExtract(\r\n        authData: AuthData,\r\n        url: String,\r\n        regex: Regex,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeInSeconds: Int,\r\n        errorHandler: (PollTimeoutException) -> Nothing\r\n    ): Promise<String>\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport org.w3c.fetch.Response\r\nimport kotlin.js.Promise\r\n\r\nobject LocationBasedQueuedItemUrlExtractor : QueuedItemUrlExtractor {\r\n\r\n    /**\r\n     * Takes the QueuedItemUrl from the Location header of the [response].\r\n     */\r\n    override fun extract(authData: AuthData, response: Response, jobExecutionData: JobExecutionData): Promise<String> {\r\n        return Promise.resolve(\r\n            response.headers.get(\"Location\") ?: throw IllegalStateException(\r\n                \"Job ${jobExecutionData.jobName} queued but Location header not found in response of Jenkins.\" +\r\n                    \"\\nHave you exposed Location with Access-Control-Expose-Headers?\"\r\n            )\r\n        )\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.sleep\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nobject Poller {\r\n\r\n    fun pollAndExtract(\r\n        authData: AuthData,\r\n        url: String,\r\n        regex: Regex,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeInSeconds: Int,\r\n        errorHandler: (PollTimeoutException) -> Nothing\r\n    ): Promise<String> {\r\n        return poll(PollData(authData, url, pollEverySecond, maxWaitingTimeInSeconds) { body ->\r\n            val matchResult = regex.find(body)\r\n            if (matchResult != null) {\r\n                true to matchResult.groupValues[1]\r\n            } else {\r\n                false to null\r\n            }\r\n        }).catch { t ->\r\n            if (t is PollTimeoutException) {\r\n                errorHandler(t)\r\n            } else {\r\n                throw t\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun <T : Any> poll(pollData: PollData<T>): Promise<T> {\r\n        val headers = createHeaderWithAuthAndCrumb(pollData.authData)\r\n        val init = createGetRequest(headers)\r\n\r\n        val rePoll: (String) -> T = { body ->\r\n            if (pollData.numberOfTries * pollData.pollEverySecond >= pollData.maxWaitingTimeInSeconds) {\r\n                throw PollTimeoutException(\r\n                    \"Waited at least ${pollData.maxWaitingTimeInSeconds} seconds\",\r\n                    body\r\n                )\r\n            }\r\n            val p = sleep(pollData.pollEverySecond * 1000) {\r\n                poll(pollData.newWithIncreasedNumberOfTimes())\r\n            }\r\n            // unsafeCast is used because javascript resolves the result automatically on return\r\n            // will not result in Promise<Promise<T>> but T\r\n            p.unsafeCast<T>()\r\n        }\r\n\r\n        return window.fetch(pollData.pollUrl, init)\r\n            .then(::checkStatusOk)\r\n            .then { (_, body) ->\r\n                val (success, result) = pollData.action(body)\r\n                if (success) {\r\n                    if (result == null) {\r\n                        throw Error(\"Result was null even though success flag during polling was true.\" +\r\n                            \"\\nPlease report a bug: $GITHUB_NEW_ISSUE\")\r\n                    }\r\n                    result\r\n                } else {\r\n                    rePoll(body)\r\n                }\r\n            }.catch { t ->\r\n                when (t) {\r\n                    is PollTimeoutException -> throw t\r\n                    is Exception -> {\r\n                        console.log(t)\r\n                        rePoll(\"\")\r\n                    }\r\n                    else -> throw t\r\n                }\r\n            }\r\n    }\r\n\r\n    @Suppress(\"DataClassPrivateConstructor\")\r\n    data class PollData<T> private constructor(\r\n        val authData: AuthData,\r\n        val pollUrl: String,\r\n        val pollEverySecond: Int,\r\n        val maxWaitingTimeInSeconds: Int,\r\n        val action: (String) -> Pair<Boolean, T?>,\r\n        val numberOfTries: Int\r\n    ) {\r\n        constructor(\r\n            authData: AuthData,\r\n            pollUrl: String,\r\n            pollEverySecond: Int,\r\n            maxWaitingTimeInSeconds: Int,\r\n            action: (String) -> Pair<Boolean, T?>\r\n        ) : this(\r\n            authData,\r\n            pollUrl,\r\n            pollEverySecond,\r\n            maxWaitingTimeInSeconds,\r\n            action,\r\n            numberOfTries = 0\r\n        )\r\n\r\n        fun newWithIncreasedNumberOfTimes(): PollData<T> = PollData(\r\n            authData,\r\n            pollUrl,\r\n            pollEverySecond,\r\n            maxWaitingTimeInSeconds,\r\n            action,\r\n            numberOfTries + 1\r\n        )\r\n    }\r\n\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nclass PollTimeoutException(message: String, val body: String, cause: Throwable?) : RuntimeException(message, cause) {\r\n    constructor(message: String, body: String): this(message, body, null)\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.jobexecution.BuilderNumberExtractor.Companion.numberRegex\r\nimport ch.loewenfels.depgraph.gui.sleep\r\nimport kotlin.js.Promise\r\n\r\nclass QueuedItemBasedBuildNumberExtractor(\r\n    private val authData: AuthData,\r\n    private val queuedItemUrl: String\r\n) : BuilderNumberExtractor {\r\n\r\n    override fun extract(): Promise<Int> {\r\n        // wait a bit, if we are too fast we run almost certainly into a 404 (job is not even queued)\r\n        return sleep(200) {\r\n            Poller.pollAndExtract(\r\n                authData,\r\n                \"${queuedItemUrl}api/xml\",\r\n                numberRegex,\r\n                pollEverySecond = 2,\r\n                maxWaitingTimeInSeconds = 20,\r\n                errorHandler = { e ->\r\n                    throw PollTimeoutException(\r\n                        \"Extracting the build number via the queued item failed (max waiting time reached). Could not find the build number in the returned body.\" +\r\n                            \"\\nJob URL: $queuedItemUrl\" +\r\n                            \"\\nRegex used: ${numberRegex.pattern}\" +\r\n                            \"\\nContent: ${e.body}\"\r\n                    , e.body, e)\r\n                })\r\n        }.then { it.toInt() }\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.Command\r\nimport ch.loewenfels.depgraph.data.Project\r\nimport ch.loewenfels.depgraph.data.ReleasePlan\r\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsUpdateDependency\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.M2ReleaseCommand\r\nimport ch.loewenfels.depgraph.parseRegexParameters\r\nimport ch.loewenfels.depgraph.parseRemoteRegex\r\nimport ch.tutteli.kbox.appendToStringBuilder\r\n\r\nclass ReleaseJobExecutionDataFactory(\r\n    defaultJenkinsBaseUrl: String,\r\n    releasePlan: ReleasePlan\r\n) : BaseJobExecutionDataFactory(defaultJenkinsBaseUrl, releasePlan) {\r\n\r\n    private val remoteRegex : List<Pair<Regex, String>>\r\n    private val regexParametersList: List<Pair<Regex, String>>\r\n    private val jobMapping: Map<String, String>\r\n\r\n    init {\r\n        checkConfig(releasePlan.config)\r\n        remoteRegex = parseRemoteRegex(releasePlan)\r\n        regexParametersList = parseRegexParameters(releasePlan)\r\n        jobMapping = parseJobMapping()\r\n    }\r\n\r\n    private fun checkConfig(config: Map<ConfigKey, String>) {\r\n        requireConfigEntry(config, ConfigKey.UPDATE_DEPENDENCY_JOB)\r\n        requireConfigEntry(config, ConfigKey.REMOTE_REGEX)\r\n        requireConfigEntry(config, ConfigKey.COMMIT_PREFIX)\r\n    }\r\n\r\n    private fun parseJobMapping(): Map<String, String> {\r\n        val mapping = getConfig(ConfigKey.JOB_MAPPING)\r\n        return mapping.split(\"|\").associate { pair ->\r\n            val index = pair.indexOf('=')\r\n            check(index > 0) {\r\n                \"At least one mapping has no groupId and artifactId defined.\\njobMapping: $mapping\"\r\n            }\r\n            val groupIdAndArtifactId = pair.substring(0, index)\r\n            check(groupIdAndArtifactId.contains(':')) {\r\n                \"At least one groupId and artifactId is erroneous, does not contain a `:`.\\njobMapping: $mapping\"\r\n            }\r\n            val jobName = pair.substring(index + 1)\r\n            check(jobName.isNotBlank()) {\r\n                \"At least one groupId and artifactId is erroneous, has no job name defined.\\njobMapping: $mapping\"\r\n            }\r\n            groupIdAndArtifactId to jobName\r\n        }\r\n    }\r\n\r\n    private fun getJobName(project: Project): String {\r\n        val mavenProjectId = project.id as MavenProjectId\r\n        return jobMapping[mavenProjectId.identifier] ?: mavenProjectId.artifactId\r\n    }\r\n\r\n    override fun create(project: Project, command: Command): JobExecutionData {\r\n        return when (command) {\r\n            is JenkinsUpdateDependency -> triggerUpdateDependency(project, command)\r\n            is M2ReleaseCommand -> triggerRelease(project, command)\r\n            else -> throw UnsupportedOperationException(\"We do not (yet) support the command: $command\")\r\n        }\r\n    }\r\n\r\n    private fun triggerUpdateDependency(project: Project, command: JenkinsUpdateDependency): JobExecutionData {\r\n        val jobUrl = getJobUrl(ConfigKey.UPDATE_DEPENDENCY_JOB)\r\n        val jobName = \"update dependency of ${project.id.identifier}\"\r\n        val params = createUpdateDependencyParams(project, command)\r\n        return JobExecutionData.buildWithParameters(jobName, jobUrl, toQueryParameters(params), params)\r\n    }\r\n\r\n    private fun createUpdateDependencyParams(project: Project, command: JenkinsUpdateDependency): Map<String,String> {\r\n        val dependency = releasePlan.getProject(command.projectId)\r\n        val dependencyMavenProjectId = dependency.id as MavenProjectId\r\n        return mapOf(\r\n            \"pathToProject\" to project.relativePath,\r\n            \"&groupId\" to dependencyMavenProjectId.groupId,\r\n            \"&artifactId\" to dependencyMavenProjectId.artifactId,\r\n            \"&newVersion\" to dependency.releaseVersion,\r\n            \"&commitPrefix\" to getConfig(ConfigKey.COMMIT_PREFIX),\r\n            \"&releaseId\" to releasePlan.releaseId\r\n        )\r\n    }\r\n\r\n    private fun triggerRelease(project: Project, command: M2ReleaseCommand): JobExecutionData {\r\n        val mavenProjectId = project.id as MavenProjectId\r\n        val jobName = getJobName(project)\r\n        val jenkinsBaseUrl = getMatchingEntries(remoteRegex, mavenProjectId).firstOrNull() ?: defaultJenkinsBaseUrl\r\n        val jobUrl = getJobUrl(jenkinsBaseUrl, jobName)\r\n        val relevantParams = getMatchingEntries(regexParametersList, mavenProjectId)\r\n        val parameters = StringBuilder()\r\n        relevantParams.appendToStringBuilder(parameters, \",\") {\r\n            val (name, value) = it.split('=')\r\n            parameters.append(\"{\\\"name\\\":\\\"$name\\\",\\\"value\\\":\\\"$value\\\"}\")\r\n        }\r\n        val params = \"releaseVersion=${project.releaseVersion}\" +\r\n            \"&developmentVersion=${command.nextDevVersion}\" +\r\n            \"&json={parameter=[$parameters]}\"\r\n        return JobExecutionData.m2ReleaseSubmit(\r\n            \"release ${project.id.identifier}\",\r\n            jobUrl,\r\n            params,\r\n            project.releaseVersion,\r\n            command.nextDevVersion\r\n        )\r\n    }\r\n\r\n    private fun getMatchingEntries(\r\n        regex: List<Pair<Regex, String>>,\r\n        mavenProjectId: MavenProjectId\r\n    ) = regex.asSequence().filter { (regex, _) -> regex.matches(mavenProjectId.identifier) }.map { it.second }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\n\npackage kotlin.text\n\nimport kotlin.*\nimport kotlin.comparisons.*\nimport kotlin.internal.contracts.*\n\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex ->\n        indexOfAny(delimiters, startIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex -> findAnyOf(delimitersList, startIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package ch.tutteli.kbox\r\n\r\n/**\r\n * Appends all elements of this list to the given [sb] by calling [append] and separates the elements with the given\r\n * [separator].\r\n */\r\ninline fun <T> Array<T>.appendToStringBuilder(sb: StringBuilder, separator: String, append: (it: T) -> Unit) =\r\n    this.asList().appendToStringBuilder(sb, separator, separator, append)\r\n\r\n/**\r\n * Appends all elements of this list to the given [sb] by calling [append] and separates the elements with the given\r\n * [separator] whereas [lastSeparator] is used to separate the last and the second last element.\r\n */\r\ninline fun <T> Array<T>.appendToStringBuilder(\r\n    sb: StringBuilder,\r\n    separator: String,\r\n    lastSeparator: String,\r\n    append: (it: T) -> Unit\r\n) = this.asList().appendToStringBuilder(sb, separator, lastSeparator, append)\r\n\r\n\r\n/**\r\n * Appends all elements of this [List] to the given [sb] by calling [append] and separates the elements with the given\r\n * [separator].\r\n */\r\ninline fun <T> List<T>.appendToStringBuilder(\r\n    sb: StringBuilder,\r\n    separator: String,\r\n    append: (it: T) -> Unit\r\n) = this.asIterable().appendToStringBuilder(sb, separator, append)\r\n\r\n\r\n/**\r\n * Appends all elements of this [List] to the given [sb] by calling [append] and separates the elements with the given\r\n * [separator] whereas [lastSeparator] is used to separate the last and the second last element.\r\n */\r\ninline fun <T> List<T>.appendToStringBuilder(\r\n    sb: StringBuilder,\r\n    separator: String,\r\n    lastSeparator: String,\r\n    append: (it: T) -> Unit\r\n) {\r\n    val size = this.size\r\n    if (size > 0) {\r\n        append(this[0])\r\n    }\r\n    for (i in 1 until size - 1) {\r\n        sb.append(separator)\r\n        append(this[i])\r\n    }\r\n    if (size > 1) {\r\n        sb.append(lastSeparator)\r\n        append(this[size - 1])\r\n    }\r\n}\r\n\r\n/**\r\n* Appends all elements of this [Iterable] to the given [sb] by calling [append] and separates the elements with\r\n* the given [separator].\r\n*/\r\ninline fun <T> Iterable<T>.appendToStringBuilder(\r\n    sb: StringBuilder,\r\n    separator: String,\r\n    append: (it: T) -> Unit\r\n) {\r\n    val itr = this.iterator()\r\n    if (itr.hasNext()) {\r\n        append(itr.next())\r\n    }\r\n    while (itr.hasNext()) {\r\n        sb.append(separator)\r\n        append(itr.next())\r\n    }\r\n}\r\n\r\n/**\r\n * Appends all elements of this [Sequence] to the given [sb] by calling [append] and separates the elements with\r\n * the given [separator].\r\n */\r\ninline fun <T> Sequence<T>.appendToStringBuilder(\r\n    sb: StringBuilder,\r\n    separator: String,\r\n    append: (it: T) -> Unit\r\n) {\r\n    val itr = this.iterator()\r\n    if (itr.hasNext()) {\r\n        append(itr.next())\r\n    }\r\n    while (itr.hasNext()) {\r\n        sb.append(separator)\r\n        append(itr.next())\r\n    }\r\n}\r\n\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.regex.noneOrSomeChars\r\nimport org.w3c.fetch.Response\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nclass RestApiBasedQueuedItemUrlExtractor(private val identifyingParams: Map<String, String>) : QueuedItemUrlExtractor {\r\n\r\n    override fun extract(\r\n        authData: AuthData,\r\n        response: Response,\r\n        jobExecutionData: JobExecutionData\r\n    ): Promise<String?> {\r\n\r\n        // We somehow have to get the build number. Unfortunately it is not returned by M2Plugin from the POST request\r\n        // (also not in header) that is why we browse the Jenkins queue and search for a match\r\n        // based on the given identifyingParams.\r\n        val jenkinsBaseUrl = jobExecutionData.jobBaseUrl.substringBefore(\"/job/\")\r\n        val t = jobExecutionData.jobBaseUrl.substringAfter(\"/job/\")\r\n        val jobName = if (t.endsWith(\"/\")) t.substringBeforeLast(\"/\") else t\r\n        val headers = createHeaderWithAuthAndCrumb(authData)\r\n        val init = createGetRequest(headers)\r\n        val paramsIdentification = createParameterRegexPattern(identifyingParams)\r\n\r\n        return window.fetch(\"$jenkinsBaseUrl/queue/api/xml\", init)\r\n            .then(::checkStatusOk)\r\n            .then { (_, body) ->\r\n                val queuedItemRegex = Regex(\r\n                    \"<item>$noneOrSomeChars\" +\r\n                        paramsIdentification +\r\n                        \"<task>$noneOrSomeChars<name>$jobName</name>$noneOrSomeChars</task>$noneOrSomeChars\" +\r\n                        \"<url>([^<]+)</url>$noneOrSomeChars\" +\r\n                    \"</item>\"\r\n                )\r\n                val matchResult = queuedItemRegex.find(body)\r\n                if (matchResult != null) {\r\n                    jenkinsBaseUrl + \"/\" + matchResult.groupValues[1]\r\n                } else {\r\n                    null\r\n                }\r\n            }\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.showAlert\r\nimport ch.loewenfels.depgraph.gui.sleep\r\nimport ch.loewenfels.depgraph.gui.unwrapPromise\r\nimport failAfterSteps\r\nimport stepWise\r\nimport waitBetweenSteps\r\nimport kotlin.js.Promise\r\n\r\nclass SimulatingJobExecutor : JobExecutor {\r\n\r\n    private var count = 0\r\n\r\n    override fun pollAndExtract(\r\n        authData: AuthData,\r\n        url: String,\r\n        regex: Regex,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeInSeconds: Int,\r\n        errorHandler: (PollTimeoutException) -> Nothing\r\n    ): Promise<String> {\r\n        return Promise.resolve(\"simulation-only.json\")\r\n    }\r\n\r\n    override fun trigger(\r\n        jobExecutionData: JobExecutionData,\r\n        jobQueuedHook: (queuedItemUrl: String?) -> Promise<*>,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int,\r\n        verbose: Boolean\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        val jobName = jobExecutionData.jobName\r\n        return sleep(100) {\r\n            jobQueuedHook(\"${jobExecutionData.jobBaseUrl}queuingUrl\")\r\n            informIfStepWiseAndNotPublish(\"job $jobName queued\", jobName)\r\n        }.then {\r\n            sleep(waitBetweenSteps) {\r\n                simulateBuildNumberExtracted(jobName, jobStartedHook)\r\n            }\r\n        }.then {\r\n            sleep(waitBetweenSteps) {\r\n                simulateJobFinished(jobExecutionData)\r\n            }\r\n        }.then {\r\n            getFakeAuthDataAndBuildNumber()\r\n        }\r\n    }\r\n\r\n    private fun simulateBuildNumberExtracted(\r\n        jobName: String,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>\r\n    ): Promise<Unit> {\r\n        jobStartedHook(100)\r\n        return informIfStepWiseAndNotPublish(\"job $jobName started\", jobName)\r\n    }\r\n\r\n    private fun informIfStepWiseAndNotPublish(msg: String, jobName: String): Promise<Unit> {\r\n        return if (!jobName.startsWith(\"publish\")) {\r\n            informIfStepWise(msg)\r\n        } else {\r\n            Promise.resolve(Unit)\r\n        }\r\n    }\r\n\r\n    override fun rePollQueueing(\r\n        jobExecutionData: JobExecutionData,\r\n        queuedItemUrl: String,\r\n        jobStartedHook: (buildNumber: Int) -> Promise<*>,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        return sleep(waitBetweenSteps) {\r\n            simulateBuildNumberExtracted(jobExecutionData.jobName, jobStartedHook)\r\n        }.then {\r\n            rePoll(jobExecutionData, 100, pollEverySecond, maxWaitingTimeForCompletenessInSeconds)\r\n        }.unwrapPromise()\r\n    }\r\n\r\n    override fun rePoll(\r\n        jobExecutionData: JobExecutionData,\r\n        buildNumber: Int,\r\n        pollEverySecond: Int,\r\n        maxWaitingTimeForCompletenessInSeconds: Int\r\n    ): Promise<Pair<AuthData, Int>> {\r\n        return sleep(waitBetweenSteps) {\r\n            simulateJobFinished(jobExecutionData)\r\n        }.then {\r\n            getFakeAuthDataAndBuildNumber()\r\n        }\r\n    }\r\n\r\n    private fun simulateJobFinished(jobExecutionData: JobExecutionData): Promise<Boolean> {\r\n        ++count\r\n        if (count > failAfterSteps) check(false) {\r\n            count = -3; \"simulating a failure for ${jobExecutionData.jobName}\"\r\n        }\r\n        return informIfStepWise(\"job ${jobExecutionData.jobName} ended\")\r\n            .then { true }\r\n    }\r\n\r\n    private fun informIfStepWise(msg: String): Promise<Unit> {\r\n        return if (stepWise) {\r\n            showAlert(msg)\r\n        } else {\r\n            Promise.resolve(Unit)\r\n        }\r\n    }\r\n\r\n    private fun getFakeAuthDataAndBuildNumber(): Pair<AuthData, Int> {\r\n        return AuthData(\r\n            UsernameAndApiToken(\"simulating-user\", \"random-api-token\"),\r\n            CrumbWithId(\"Jenkins-Crumb\", \"onlySimulation\")\r\n        ) to 100\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\n@Suppress(\"DataClassPrivateConstructor\")\r\ndata class UrlWithSlashAtTheEnd private constructor(val url: String) {\r\n\r\n    operator fun plus(s: String) = url + s\r\n    override fun toString(): String = url\r\n\r\n    companion object {\r\n        fun create(url: String) = UrlWithSlashAtTheEnd(if (url.endsWith(\"/\")) url else \"$url/\")\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nimport ch.loewenfels.depgraph.gui.showThrowable\r\nimport org.w3c.fetch.Response\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nobject UsernameTokenRegistry {\r\n\r\n    private val fullNameRegex = Regex(\"<input[^>]+name=\\\"_\\\\.fullName\\\"[^>]+value=\\\"([^\\\"]+)\\\"\")\r\n    private val apiTokenRegex = Regex(\"<input[^>]+name=\\\"_\\\\.apiToken\\\"[^>]+value=\\\"([^\\\"]+)\\\"\")\r\n    private val usernameRegex = Regex(\"<a[^>]+href=\\\"[^\\\"]*/user/([^\\\"]+)\\\"\")\r\n\r\n    private val usernameTokens = hashMapOf<String, UsernameAndApiToken>()\r\n\r\n    fun forHostOrThrow(jenkinsBaseUrl: String): UsernameAndApiToken\r\n        = forHost(jenkinsBaseUrl) ?: throw IllegalStateException(\"could not find usernameAndApiToken for $jenkinsBaseUrl\")\r\n\r\n    fun forHost(jenkinsBaseUrl: String): UsernameAndApiToken? = usernameTokens[urlWithoutEndingSlash(jenkinsBaseUrl)]\r\n\r\n    private fun urlWithoutEndingSlash(jenkinsBaseUrl: String): String {\r\n        return if (jenkinsBaseUrl.endsWith(\"/\")) {\r\n            jenkinsBaseUrl.substring(0, jenkinsBaseUrl.length - 1)\r\n        } else {\r\n            jenkinsBaseUrl\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Retrieves the API token of the logged in user at [jenkinsBaseUrl] and registers it, moreover it returns the name\r\n     * of the user in the same request (the name is not stored though)\r\n     *\r\n     * @return A pair consisting of the name and the [UsernameAndApiToken] of the logged in user.\r\n     */\r\n    fun register(jenkinsBaseUrl: String): Promise<Pair<String, UsernameAndApiToken>?>\r\n        = retrieveUserAndApiTokenAndSaveToken(jenkinsBaseUrl)\r\n\r\n    private fun retrieveUserAndApiTokenAndSaveToken(jenkinsBaseUrl: String): Promise<Pair<String, UsernameAndApiToken>?> {\r\n        val urlWithoutSlash = urlWithoutEndingSlash(jenkinsBaseUrl)\r\n        return window.fetch(\"$urlWithoutSlash/me/configure\", createFetchInitWithCredentials())\r\n            .then(::checkStatusOkOr403)\r\n            .catch<Pair<Response, String?>?> { t ->\r\n                showThrowable(Error(\"Could not retrieve user and API token for $urlWithoutSlash\", t))\r\n                null\r\n            }\r\n            .then { pair ->\r\n                val body = pair?.second\r\n                if (body == null) {\r\n                    null\r\n                } else {\r\n                    val (username, name, apiToken) = extractNameAndApiToken(body)\r\n                    val usernameToken = UsernameAndApiToken(username, apiToken)\r\n                    usernameTokens[urlWithoutSlash] = usernameToken\r\n                    name to usernameToken\r\n                }\r\n            }\r\n    }\r\n\r\n\r\n    private fun extractNameAndApiToken(body: String): Triple<String, String, String> {\r\n        val usernameMatch = usernameRegex.find(body) ?: throw IllegalStateException(\"Could not find username\")\r\n        val fullNameMatch = fullNameRegex.find(body) ?: throw IllegalStateException(\"Could not find user's name\")\r\n        val apiTokenMatch = apiTokenRegex.find(body) ?: throw IllegalStateException(\"Could not find API token\")\r\n        return Triple(usernameMatch.groupValues[1], fullNameMatch.groupValues[1], apiTokenMatch.groupValues[1])\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui\r\n\r\nimport kotlinx.html.*\r\nimport kotlinx.html.dom.append\r\nimport kotlinx.html.dom.create\r\nimport kotlinx.html.js.div\r\nimport org.w3c.dom.HTMLElement\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nfun showSuccess(message: String, autoCloseAfterMs: Int? = null) =\r\n    showMessageOfType(\"success\", \"check_circle\", message, autoCloseAfterMs)\r\n\r\nfun showInfo(message: String, autoCloseAfterMs: Int? = null) =\r\n    showMessageOfType(\"info\", \"info_outline\", message, autoCloseAfterMs)\r\n\r\nfun showWarning(message: String, autoCloseAfterMs: Int? = null) =\r\n    showMessageOfType(\"warning\", \"warning\", message, autoCloseAfterMs)\r\n\r\nfun showError(message: String) = showMessageOfType(\"error\", \"error_outline\", message, null)\r\n\r\nprivate var msgCounter = 0\r\nprivate fun showMessageOfType(type: String, icon: String, message: String, autoCloseAfterMs: Int?): HTMLElement {\r\n    val messages = elementById(\"messages\")\r\n    val div = document.create.div(type) {\r\n        val msgId = \"msg${msgCounter++}\"\r\n        this.id = msgId\r\n        span(\"close\") {\r\n            title = \"close this message\"\r\n            val span = getUnderlyingHtmlElement()\r\n            span.addEventListener(\"click\", { closeMessage(msgId) })\r\n        }\r\n        i(\"material-icons\") {\r\n            +icon\r\n        }\r\n        div(\"text\") {\r\n            convertNewLinesToBrTabToTwoSpacesAndParseUrls(message)\r\n        }\r\n        if (autoCloseAfterMs != null) {\r\n            window.setTimeout({ closeMessage(msgId) }, autoCloseAfterMs)\r\n        }\r\n    }\r\n    val hideMessagesButton = elementById(ContentContainer.HIDE_MESSAGES_HTML_ID)\r\n    messages.insertBefore(div, hideMessagesButton.nextSibling)\r\n    return div\r\n}\r\n\r\nprivate fun closeMessage(msgId: String) {\r\n    elementByIdOrNull<HTMLElement>(msgId)?.remove()\r\n}\r\n\r\nfun showThrowableAndThrow(t: Throwable): Nothing {\r\n    showThrowable(t)\r\n    throw t\r\n}\r\n\r\nfun showThrowable(t: Throwable) {\r\n    showError(turnThrowableIntoMessage(t))\r\n}\r\n\r\nfun turnThrowableIntoMessage(t: Throwable): String {\r\n    val sb = StringBuilder()\r\n    sb.appendThrowable(t)\r\n\r\n    var cause = t.cause\r\n    while (cause != null) {\r\n        sb.append(\"\\n\\nCause: \").appendThrowable(cause)\r\n        cause = cause.cause\r\n    }\r\n    return sb.toString()\r\n}\r\n\r\nprivate fun StringBuilder.appendThrowable(t: Throwable): StringBuilder {\r\n    val nullableStack: String? = t.asDynamic().stack as? String\r\n    return if (nullableStack != null) {\r\n        val stackWithMessage: String = getStackWithMessage(t, nullableStack)\r\n        val firstNewLine = stackWithMessage.indexOf(\"   \")\r\n        val stack = if (firstNewLine >= 0) {\r\n            append(stackWithMessage.substring(0, firstNewLine)).append('\\n')\r\n            stackWithMessage.substring(firstNewLine)\r\n        } else {\r\n            stackWithMessage\r\n        }\r\n        append(stack.replace(\"   \", \"\\t\"))\r\n    } else {\r\n        append(\"${t::class.js.name}: ${t.message}\")\r\n    }\r\n}\r\n\r\nprivate fun withoutEndingNewLine(text: String?): String {\r\n    if (text == null) return \"\"\r\n    return if (text.endsWith(\"\\n\")) text.substringBeforeLast(\"\\n\") else text\r\n}\r\n\r\nprivate fun getStackWithMessage(t: Throwable, nullableStack: String): String {\r\n    return when {\r\n        nullableStack.startsWith(\"captureStack\") -> {\r\n            val firstNewLine = nullableStack.indexOf('\\n')\r\n            t::class.simpleName + \": \" + withoutEndingNewLine(t.message) +\r\n                \"\\n   \" + withoutEndingNewLine(nullableStack).substring(firstNewLine + 1).split('\\n').joinToString(\"\\n   \")\r\n        }\r\n        nullableStack.isBlank() -> t.toString()\r\n        else -> nullableStack\r\n    }\r\n}\r\n\r\nprivate fun DIV.convertNewLinesToBrTabToTwoSpacesAndParseUrls(message: String) {\r\n    if (message.isEmpty()) return\r\n\r\n    val messages = message.split(\"\\n\")\r\n    convertTabToTwoSpacesAndUrlToLinks(messages[0])\r\n    for (i in 1 until messages.size) {\r\n        br\r\n        convertTabToTwoSpacesAndUrlToLinks(messages[i])\r\n    }\r\n}\r\n\r\n\r\nprivate val urlRegex = Regex(\"http(?:s)?://[^ ]+\")\r\n\r\nprivate fun DIV.convertTabToTwoSpacesAndUrlToLinks(message: String) {\r\n    var matchResult = urlRegex.find(message)\r\n    if (matchResult != null) {\r\n        var index = 0\r\n        do {\r\n            val match = matchResult!!\r\n            convertTabToTwoSpaces(message.substring(index, match.range.start))\r\n            val (url, nextIndex) = determineUrlAndNextIndex(match)\r\n            a(href = url) {\r\n                +url\r\n            }\r\n            index = nextIndex\r\n            matchResult = match.next()\r\n        } while (matchResult != null)\r\n        convertTabToTwoSpaces(message.substring(index))\r\n    } else {\r\n        convertTabToTwoSpaces(message)\r\n    }\r\n}\r\n\r\nprivate fun DIV.convertTabToTwoSpaces(content: String) {\r\n    var currentIndex = 0\r\n    do {\r\n        val index = content.indexOf('\\t', currentIndex)\r\n        if (index < 0) break\r\n\r\n        +content.substring(currentIndex, index)\r\n        unsafe { +\"&nbsp;&nbsp;\" }\r\n        currentIndex = index + 1\r\n    } while (true)\r\n    +content.substring(currentIndex)\r\n}\r\n\r\n\r\nprivate fun determineUrlAndNextIndex(match: MatchResult): Pair<String, Int> {\r\n    val tmpUrl = match.value\r\n    return if (tmpUrl.endsWith(\".\")) {\r\n        tmpUrl.substring(0, tmpUrl.length - 1) to match.range.endInclusive\r\n    } else {\r\n        tmpUrl to match.range.endInclusive + 1\r\n    }\r\n}\r\n\r\nfun showDialog(msg: String): Promise<Boolean> {\r\n    return Promise { resolve, _ ->\r\n        showModal(msg) { box ->\r\n            modalButton(\"Yes\", box, resolve, true)\r\n            modalButton(\"No\", box, resolve, false)\r\n        }\r\n    }\r\n}\r\n\r\nfun showAlert(msg: String): Promise<Unit> {\r\n    return Promise { resolve, _ ->\r\n        showModal(msg) { box ->\r\n            modalButton(\"OK\", box, resolve, Unit)\r\n        }\r\n    }\r\n}\r\n\r\nfun showOutput(title: String, output: String): Promise<Unit> {\r\n    return Promise { resolve, _ ->\r\n        showModal(\r\n            {\r\n                div(\"output\") {\r\n                    i(\"material-icons\") { +\"list_alt\" }; span { +title }\r\n                    textArea { +output }\r\n                }\r\n            },\r\n            { box -> modalButton(\"OK\", box, resolve, Unit) }\r\n        )\r\n    }\r\n}\r\n\r\nprivate fun <T> DIV.modalButton(buttonText: String, box: HTMLElement, resolve: (T) -> Unit, objectToResolve: T) {\r\n    span {\r\n        +buttonText\r\n        getUnderlyingHtmlElement().addClickEventListener(options = js(\"{once: true}\")) {\r\n            box.remove()\r\n            resolve(objectToResolve)\r\n        }\r\n    }\r\n}\r\n\r\nprivate fun showModal(\r\n    msg: String,\r\n    buttonCreator: DIV.(HTMLElement) -> Unit\r\n) = showModal(\r\n    {\r\n        i(\"material-icons\") { +\"help_outline\" }\r\n        div { convertNewLinesToBrTabToTwoSpacesAndParseUrls(msg) }\r\n    },\r\n    buttonCreator\r\n)\r\n\r\nprivate fun showModal(\r\n    contentCreator: DIV.() -> Unit,\r\n    buttonCreator: DIV.(HTMLElement) -> Unit\r\n) {\r\n    val modals = elementById(\"modals\")\r\n    modals.append {\r\n        div(\"box\") {\r\n            val box = getUnderlyingHtmlElement()\r\n            div(\"text\") {\r\n                contentCreator()\r\n            }\r\n            div(\"buttons\") {\r\n                buttonCreator(box)\r\n            }\r\n            box.style.visibility = \"hidden\"\r\n        }\r\n    }\r\n    val box = modals.lastChild as HTMLElement\r\n    val top = window.innerHeight / 2.5 - box.offsetHeight / 2\r\n    val left = window.innerWidth / 2 - box.offsetWidth / 2\r\n    box.style.top = \"${top}px\"\r\n    box.style.left = \"${left}px\"\r\n    box.style.visibility = \"visible\"\r\n}\r\n","package ch.loewenfels.depgraph.gui.recovery\r\n\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsCommand\r\nimport ch.loewenfels.depgraph.data.serialization.CommandStateJson\r\nimport ch.loewenfels.depgraph.gui.App\r\nimport ch.loewenfels.depgraph.gui.jobexecution.*\r\nimport ch.loewenfels.depgraph.gui.jobexecution.BuilderNumberExtractor.Companion.numberRegex\r\nimport ch.loewenfels.depgraph.gui.serialization.ModifiableState\r\nimport ch.loewenfels.depgraph.gui.serialization.ProjectJson\r\nimport ch.loewenfels.depgraph.gui.serialization.ReleasePlanJson\r\nimport ch.loewenfels.depgraph.gui.serialization.deserializeProjectId\r\nimport ch.loewenfels.depgraph.gui.showDialog\r\nimport ch.loewenfels.depgraph.gui.showInfo\r\nimport ch.loewenfels.depgraph.gui.showThrowable\r\nimport kotlin.browser.window\r\nimport kotlin.js.*\r\n\r\n\r\nfun recover(modifiableState: ModifiableState, defaultJenkinsBaseUrl: String?): Promise<ModifiableState> {\r\n    if (defaultJenkinsBaseUrl == null) {\r\n        showInfo(\r\n            \"You have opened a pipeline which is in state ${ReleaseState.IN_PROGRESS.name}.\\n\" +\r\n                \"Yet, since you have not provided a ${App.PUBLISH_JOB} in the URL we cannot recover the ongoing process.\"\r\n        )\r\n        return Promise.resolve(modifiableState)\r\n    }\r\n\r\n    return showDialog(\r\n        \"\"\"\r\n            |You have opened a pipeline which is in state ${ReleaseState.IN_PROGRESS.name} currently executing '${modifiableState.releasePlan.typeOfRun.toProcessName()}' for root project ${modifiableState.releasePlan.rootProjectId.identifier}.\r\n            |Are you the release manager and would like to recover the ongoing process?\r\n            |\r\n            |Extra information: By clicking 'Yes' the dep-graph-releaser will check if the current state of the individual commands is still appropriate and update if necessary. Furthermore, it will resume the process meaning it will trigger dependent jobs if a job finishes. Or in other words, it will almost look like you have never left the page.\r\n            |\r\n            |Do not click 'Yes' (but 'No') if you (or some else) have started the release process in another tab/browser since otherwise dependent jobs will be triggered multiple times.\r\n            \"\"\".trimMargin()\r\n    ).then { isReleaseManager ->\r\n        if (!isReleaseManager) {\r\n            showInfo(\r\n                \"We do not yet support tracking of a release process at the moment. Which means, what you see above is only a state of the process but the process as such has likely progressed already.\" +\r\n                    \"\\nPlease open a feature request $GITHUB_NEW_ISSUE if you have the need of tracking a release (which runs in another tab/browser).\"\r\n            )\r\n            val releasePlanJson = JSON.parse<ReleasePlanJson>(modifiableState.json)\r\n            releasePlanJson.state = ReleaseState.WATCHING.name.unsafeCast<ReleaseState>()\r\n            return@then Promise.resolve(releasePlanJson)\r\n        }\r\n        recoverCommandStates(modifiableState, defaultJenkinsBaseUrl)\r\n    }.then { ModifiableState(modifiableState, JSON.stringify(it)) }\r\n}\r\n\r\nprivate fun recoverCommandStates(\r\n    modifiableState: ModifiableState,\r\n    jenkinsBaseUrl: String\r\n): Promise<ReleasePlanJson> {\r\n    val releasePlanJson = JSON.parse<ReleasePlanJson>(modifiableState.json)\r\n    val promises = modifiableState.releasePlan.iterator().asSequence().map { project ->\r\n        val lazyProjectJson by lazy {\r\n            releasePlanJson.projects.single { deserializeProjectId(it.id) == project.id }\r\n        }\r\n        val promises = mapCommandStates(project, modifiableState, jenkinsBaseUrl, lazyProjectJson)\r\n        Promise.all(promises.toTypedArray())\r\n    }\r\n    return Promise.all(promises.toList().toTypedArray()).then {\r\n        releasePlanJson\r\n    }\r\n}\r\n\r\nprivate fun mapCommandStates(\r\n    project: Project,\r\n    modifiableState: ModifiableState,\r\n    jenkinsBaseUrl: String,\r\n    lazyProjectJson: ProjectJson\r\n): List<Promise<Any?>> {\r\n    return project.commands.mapIndexed { index, command ->\r\n        when (command.state) {\r\n        //TODO we need also to check if a job is queueing or already finished if the state is Ready.\r\n        // It could be that we trigger a job and then the browser crashed (or the user closed the page)\r\n        // before we had a chance to publish the new state => We could introduce a state Triggered but\r\n        // this would mean we need one more publish per job which is bad. This brings me to another idea,\r\n        // we could get rid of the save after state queueing if we implement recovery from state ready.\r\n        // Nah... then we wouldn't save anything anymore which is bad as well (we have to save from time\r\n        // to time :D). But I think there is potential here to reduce the number of publishes per pipeline.\r\n            is CommandState.Ready -> Promise.resolve(Unit)\r\n            is CommandState.Queueing -> recoverStateQueueing(\r\n                modifiableState, jenkinsBaseUrl, project, command, lazyProjectJson, index\r\n            )\r\n            is CommandState.InProgress -> recoverStateTo(lazyProjectJson, index, CommandStateJson.State.RE_POLLING)\r\n\r\n            is CommandState.Waiting,\r\n            is CommandState.ReadyToReTrigger,\r\n            is CommandState.StillQueueing,\r\n            is CommandState.RePolling,\r\n            is CommandState.Succeeded,\r\n            is CommandState.Failed,\r\n            is CommandState.Deactivated,\r\n            is CommandState.Disabled -> Promise.resolve(Unit)\r\n        }\r\n    }\r\n}\r\n\r\nprivate fun recoverStateTo(lazyProjectJson: ProjectJson, index: Int, state: CommandStateJson.State): Promise<*> {\r\n    lazyProjectJson.commands[index].p.state.asDynamic().state = state.name\r\n    return Promise.resolve(Unit)\r\n}\r\n\r\nprivate fun recoverStateQueueing(\r\n    modifiableState: ModifiableState,\r\n    jenkinsBaseUrl: String,\r\n    project: Project,\r\n    command: Command,\r\n    lazyProjectJson: ProjectJson,\r\n    index: Int\r\n): Promise<*> {\r\n    if (command !is JenkinsCommand) {\r\n        throw UnsupportedOperationException(\r\n            \"We do not know how to recover a command of type ${command::class.simpleName}.\" +\r\n                \"\\nCommand: $command\"\r\n        )\r\n    }\r\n\r\n    val usernameAndApiToken = UsernameTokenRegistry.forHostOrThrow(jenkinsBaseUrl)\r\n    return issueCrumb(jenkinsBaseUrl, usernameAndApiToken).then { authData ->\r\n        val jobExecutionData = recoverJobExecutionData(modifiableState, project, command)\r\n        val nullableQueuedItemUrl = command.buildUrl\r\n        recoverToQueueingOrRePolling(nullableQueuedItemUrl, authData, jobExecutionData, lazyProjectJson, index)\r\n            .catch { t ->\r\n                showThrowable(IllegalStateException(\"job ${jobExecutionData.jobName} could not be recovered\", t))\r\n                recoverStateTo(lazyProjectJson, index, CommandStateJson.State.FAILED)\r\n            }\r\n    }\r\n}\r\n\r\nprivate fun updateBuildUrlAndTransitionToRePolling(\r\n    jobExecutionData: JobExecutionData,\r\n    lazyProjectJson: ProjectJson,\r\n    index: Int,\r\n    buildNumber: Int\r\n): Promise<*> {\r\n    lazyProjectJson.commands[index].p.asDynamic().buildUrl = jobExecutionData.jobBaseUrl + buildNumber\r\n    return recoverStateTo(lazyProjectJson, index, CommandStateJson.State.RE_POLLING)\r\n}\r\n\r\nprivate fun recoverJobExecutionData(\r\n    modifiableState: ModifiableState,\r\n    project: Project,\r\n    command: Command\r\n): JobExecutionData {\r\n    val jobExecutionDataFactory = when (modifiableState.releasePlan.typeOfRun) {\r\n        TypeOfRun.DRY_RUN -> modifiableState.dryRunExecutionDataFactory\r\n        TypeOfRun.RELEASE, TypeOfRun.EXPLORE -> modifiableState.releaseJobExecutionDataFactory\r\n    }\r\n    return jobExecutionDataFactory.create(project, command)\r\n}\r\n\r\nprivate fun recoverToQueueingOrRePolling(\r\n    nullableQueuedItemUrl: String?,\r\n    authData: AuthData,\r\n    jobExecutionData: JobExecutionData,\r\n    lazyProjectJson: ProjectJson,\r\n    index: Int\r\n): Promise<Promise<*>> {\r\n    return recoverBuildNumberFromQueue(nullableQueuedItemUrl, authData).then { recoveredBuildNumber ->\r\n        when (recoveredBuildNumber) {\r\n            is RecoveredBuildNumber.Determined -> updateBuildUrlAndTransitionToRePolling(\r\n                jobExecutionData, lazyProjectJson, index, recoveredBuildNumber.buildNumber\r\n            )\r\n            is RecoveredBuildNumber.StillQueueing -> recoverStateTo(\r\n                lazyProjectJson, index, CommandStateJson.State.STILL_QUEUEING\r\n            )\r\n            is RecoveredBuildNumber.Undetermined -> {\r\n                BuildHistoryBasedBuildNumberExtractor(authData, jobExecutionData)\r\n                    .extract().then { buildNumber ->\r\n                        updateBuildUrlAndTransitionToRePolling(\r\n                            jobExecutionData, lazyProjectJson, index, buildNumber\r\n                        )\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate fun recoverBuildNumberFromQueue(\r\n    nullableQueuedItemUrl: String?,\r\n    authData: AuthData\r\n): Promise<RecoveredBuildNumber> {\r\n    if (nullableQueuedItemUrl == null) return Promise.resolve(RecoveredBuildNumber.Undetermined)\r\n\r\n    val headers = createHeaderWithAuthAndCrumb(authData)\r\n    val init = createGetRequest(headers)\r\n    return window.fetch(nullableQueuedItemUrl, init)\r\n        .then(::checkStatusOkOr404)\r\n        .then { (_, body) ->\r\n            // might well be that we get a 404 (body is null) because the item is no longer in the queue\r\n            // (the job is already being executed) => we return RecoverBuildNumber.Undetermined so that we recover\r\n            // the build number from the job's build history\r\n            if (body == null) return@then RecoveredBuildNumber.Undetermined\r\n\r\n            val match = numberRegex.find(body)\r\n            if (match != null) {\r\n                RecoveredBuildNumber.Determined(match.groupValues[1].toInt())\r\n            } else {\r\n                RecoveredBuildNumber.StillQueueing\r\n            }\r\n        }\r\n}\r\n\r\nprivate sealed class RecoveredBuildNumber {\r\n    data class Determined(val buildNumber: Int) : RecoveredBuildNumber()\r\n    object StillQueueing : RecoveredBuildNumber()\r\n    object Undetermined : RecoveredBuildNumber()\r\n}\r\n\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","package ch.loewenfels.depgraph.gui.serialization\r\n\r\nimport ch.loewenfels.depgraph.ConfigKey\r\nimport ch.loewenfels.depgraph.data.*\r\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsCommand\r\nimport ch.loewenfels.depgraph.data.maven.jenkins.M2ReleaseCommand\r\nimport ch.loewenfels.depgraph.data.serialization.toJson\r\nimport ch.loewenfels.depgraph.gui.ContentContainer\r\nimport ch.loewenfels.depgraph.gui.components.Pipeline\r\nimport ch.loewenfels.depgraph.gui.elementById\r\nimport ch.loewenfels.depgraph.gui.getTextField\r\nimport ch.loewenfels.depgraph.gui.getTextFieldOrNull\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.dom.HTMLTextAreaElement\r\n\r\nobject ChangeApplier {\r\n\r\n    fun createReleasePlanJsonWithChanges(releasePlan: ReleasePlan, json: String): Pair<Boolean, String> {\r\n        val releasePlanJson = JSON.parse<ReleasePlanJson>(json)\r\n        val changed = applyChanges(releasePlan, releasePlanJson)\r\n        val newJson = JSON.stringify(releasePlanJson)\r\n        return changed to newJson\r\n    }\r\n\r\n    private fun applyChanges(releasePlan: ReleasePlan, releasePlanJson: ReleasePlanJson): Boolean {\r\n        var changed = false\r\n\r\n        changed = changed or replacePublishIdIfChanged(releasePlanJson)\r\n        changed = changed or replaceReleaseStateIfChanged(releasePlanJson)\r\n        changed = changed or replaceTypeOfRunIfChanged(releasePlanJson)\r\n\r\n        releasePlanJson.projects.forEach { project ->\r\n            val mavenProjectId = deserializeProjectId(project.id)\r\n            changed = changed or replaceReleaseVersionIfChanged(releasePlan, releasePlanJson, project, mavenProjectId)\r\n\r\n            project.commands.forEachIndexed { index, command ->\r\n                changed = changed or\r\n                    replaceCommandStateIfChanged(command, mavenProjectId, index) or\r\n                    replaceFieldsIfChanged(command, mavenProjectId, index)\r\n            }\r\n        }\r\n\r\n        changed = changed or replaceConfigEntriesIfChanged(releasePlanJson)\r\n        return changed\r\n    }\r\n\r\n    private fun replacePublishIdIfChanged(releasePlanJson: ReleasePlanJson): Boolean {\r\n        var changed = false\r\n        val input = getTextField(ContentContainer.RELEASE_ID_HTML_ID)\r\n        if (releasePlanJson.releaseId != input.value) {\r\n            check(input.value.isNotBlank()) {\r\n                \"An empty or blank ReleaseId is not allowed\"\r\n            }\r\n            releasePlanJson.releaseId = input.value\r\n            changed = true\r\n        }\r\n        return changed\r\n    }\r\n\r\n    private fun replaceReleaseStateIfChanged(releasePlanJson: ReleasePlanJson): Boolean {\r\n        var changed = false\r\n        val newState = Pipeline.getReleaseState()\r\n        val currentState = deserializeReleaseState(releasePlanJson)\r\n        if (currentState != newState) {\r\n            releasePlanJson.state = newState.name.unsafeCast<ReleaseState>()\r\n            changed = true\r\n        }\r\n        return changed\r\n    }\r\n\r\n    private fun replaceTypeOfRunIfChanged(releasePlanJson: ReleasePlanJson): Boolean {\r\n        var changed = false\r\n        val newTypeOfRun = Pipeline.getTypeOfRun()\r\n        val currentTypeOfRun = deserializeTypeOfRun(releasePlanJson)\r\n        if (currentTypeOfRun != newTypeOfRun) {\r\n            releasePlanJson.typeOfRun = newTypeOfRun.name.unsafeCast<TypeOfRun>()\r\n            changed = true\r\n        }\r\n        return changed\r\n    }\r\n\r\n    private fun replaceConfigEntriesIfChanged(releasePlanJson: ReleasePlanJson): Boolean {\r\n        var changed = false\r\n        releasePlanJson.config.forEach { arr ->\r\n            if (arr.size != 2) return@forEach\r\n\r\n            val input = elementById(\"config-${arr[0]}\")\r\n            val value = if (arr[0] == ConfigKey.JOB_MAPPING.asString()) {\r\n                (input as HTMLTextAreaElement).value.replace(\"\\r\", \"\").replace(\"\\n\", \"|\")\r\n            } else {\r\n                (input as HTMLInputElement).value\r\n            }\r\n            if (arr[1] != value) {\r\n                arr[1] = value\r\n                changed = true\r\n            }\r\n        }\r\n        return changed\r\n    }\r\n\r\n\r\n    private fun replaceReleaseVersionIfChanged(\r\n        releasePlan: ReleasePlan,\r\n        releasePlanJson: ReleasePlanJson,\r\n        project: ProjectJson,\r\n        mavenProjectId: ProjectId\r\n    ): Boolean {\r\n        val input = getTextFieldOrNull(\"${mavenProjectId.identifier}:releaseVersion\")\r\n        if (input != null && project.releaseVersion != input.value) {\r\n            check(input.value.isNotBlank()) {\r\n                \"An empty or blank Release Version is not allowed\"\r\n            }\r\n            project.releaseVersion = input.value\r\n            updateReleaseVersionOfSubmodules(releasePlan, releasePlanJson, mavenProjectId, input.value)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    private fun updateReleaseVersionOfSubmodules(\r\n        releasePlan: ReleasePlan,\r\n        releasePlanJson: ReleasePlanJson,\r\n        mavenProjectId: ProjectId,\r\n        releaseVersion: String\r\n    ) {\r\n        releasePlan.getSubmodules(mavenProjectId).forEach { submoduleId ->\r\n            releasePlanJson.projects\r\n                .asSequence()\r\n                .map { it to deserializeProjectId(it.id) }\r\n                .first { it.second == submoduleId }\r\n                .apply {\r\n                    first.releaseVersion = releaseVersion\r\n                    updateReleaseVersionOfSubmodules(releasePlan, releasePlanJson, second, releaseVersion)\r\n                }\r\n        }\r\n    }\r\n\r\n    private fun replaceCommandStateIfChanged(\r\n        genericCommand: GenericType<Command>,\r\n        mavenProjectId: ProjectId,\r\n        index: Int\r\n    ): Boolean {\r\n        val command = genericCommand.p\r\n        val previousState = deserializeCommandState(command)\r\n        val newState = Pipeline.getCommandState(mavenProjectId, index)\r\n\r\n        if (previousState::class != newState::class) {\r\n            val stateObject = js(\"({})\")\r\n            stateObject.state = toJson(newState).state.name\r\n            if (newState is CommandState.Deactivated) {\r\n                stateObject.previous = command.state\r\n            }\r\n            command.asDynamic().state = stateObject\r\n            if (newState is CommandState.Waiting) {\r\n                serializeWaitingDependencies(newState, command)\r\n            }\r\n            return true\r\n        }\r\n        if (previousState is CommandState.Waiting && newState is CommandState.Waiting && previousState.dependencies.size != newState.dependencies.size) {\r\n            serializeWaitingDependencies(newState, command)\r\n        }\r\n        return false\r\n    }\r\n\r\n    private fun serializeWaitingDependencies(newState: CommandState.Waiting, command: Command) {\r\n        /* state has to be put in the following structure\r\n            \"state\": {\r\n                \"state\": \"WAITING\",\r\n                \"dependencies\": [\r\n                    {\r\n                        \"t\": \"ch.loewenfels.depgraph.data.maven.MavenProjectId\",\r\n                        \"p\": {\r\n                            \"groupId\": \"com.example\",\r\n                            \"artifactId\": \"artifact\"\r\n                        }\r\n                    }\r\n                ]\r\n            },\r\n            */\r\n        val newDependencies = newState.dependencies.map {\r\n            when (it) {\r\n                is MavenProjectId -> {\r\n                    val entry = js(\"({})\")\r\n                    entry.t = MAVEN_PROJECT_ID\r\n                    val p = js(\"({})\")\r\n                    p.groupId = it.groupId\r\n                    p.artifactId = it.artifactId\r\n                    entry.p = p\r\n                    entry.unsafeCast<GenericMapEntry<String, ProjectId>>()\r\n                }\r\n                else -> throw UnsupportedOperationException(\"$it is not supported.\")\r\n            }\r\n        }\r\n        command.state.asDynamic().dependencies = newDependencies.toTypedArray()\r\n    }\r\n\r\n    private fun replaceFieldsIfChanged(command: GenericType<Command>, mavenProjectId: ProjectId, index: Int): Boolean {\r\n        return when (command.t) {\r\n            JENKINS_MAVEN_RELEASE_PLUGIN, JENKINS_MULTI_MAVEN_RELEASE_PLUGIN -> {\r\n                replaceNextDevVersionIfChanged(command.p, mavenProjectId, index) or\r\n                    replaceBuildUrlIfChanged(command.p, mavenProjectId, index)\r\n            }\r\n            JENKINS_UPDATE_DEPENDENCY -> replaceBuildUrlIfChanged(command.p, mavenProjectId, index)\r\n            else -> throw UnsupportedOperationException(\"${command.t} is not supported.\")\r\n        }\r\n    }\r\n\r\n    private fun replaceNextDevVersionIfChanged(command: Command, mavenProjectId: ProjectId, index: Int): Boolean {\r\n        val m2Command = command.unsafeCast<M2ReleaseCommand>()\r\n        val input = getTextField(Pipeline.getCommandId(mavenProjectId, index) + Pipeline.NEXT_DEV_VERSION_SUFFIX)\r\n        if (m2Command.nextDevVersion != input.value) {\r\n            check(input.value.isNotBlank()) {\r\n                \"An empty or blank Next Dev Version is not allowed\"\r\n            }\r\n            m2Command.asDynamic().nextDevVersion = input.value\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    private fun replaceBuildUrlIfChanged(command: Command, mavenProjectId: ProjectId, index: Int): Boolean {\r\n        val jenkinsCommand = command.unsafeCast<JenkinsCommand>()\r\n        val guiCommand = Pipeline.getCommand(mavenProjectId, index)\r\n\r\n        val newBuildUrl = guiCommand.asDynamic().buildUrl as? String\r\n        if (newBuildUrl != null && jenkinsCommand.buildUrl != newBuildUrl) {\r\n            jenkinsCommand.asDynamic().buildUrl = newBuildUrl\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui.serialization\n\nimport ch.loewenfels.depgraph.ConfigKey\nimport ch.loewenfels.depgraph.data.*\nimport ch.loewenfels.depgraph.data.maven.MavenProjectId\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMavenReleasePlugin\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMultiMavenReleasePlugin\nimport ch.loewenfels.depgraph.data.maven.jenkins.JenkinsUpdateDependency\nimport ch.loewenfels.depgraph.data.serialization.CommandStateJson\nimport ch.loewenfels.depgraph.data.serialization.fromJson\nimport ch.loewenfels.depgraph.gui.showWarning\n\ninternal const val MAVEN_PROJECT_ID = \"ch.loewenfels.depgraph.data.maven.MavenProjectId\"\ninternal const val JENKINS_MAVEN_RELEASE_PLUGIN = \"ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMavenReleasePlugin\"\ninternal const val JENKINS_MULTI_MAVEN_RELEASE_PLUGIN =\n    \"ch.loewenfels.depgraph.data.maven.jenkins.JenkinsMultiMavenReleasePlugin\"\ninternal const val JENKINS_UPDATE_DEPENDENCY = \"ch.loewenfels.depgraph.data.maven.jenkins.JenkinsUpdateDependency\"\n\nfun deserialize(body: String): ReleasePlan {\n    val releasePlanJson = JSON.parse<ReleasePlanJson>(body)\n    val state = deserializeReleaseState(releasePlanJson)\n    val typeOfRun = deserializeTypeOfRun(releasePlanJson)\n    val rootProjectId = deserializeProjectId(releasePlanJson.id)\n    val projects = deserializeProjects(releasePlanJson)\n    val submodules = deserializeMapOfProjectIdAndSetProjectId(releasePlanJson.submodules)\n    val dependents = deserializeMapOfProjectIdAndSetProjectId(releasePlanJson.dependents)\n    val warnings = releasePlanJson.warnings.toList()\n    val infos = releasePlanJson.infos.toList()\n    val config = deserializeConfig(releasePlanJson.config)\n\n    return ReleasePlan(\n        releasePlanJson.releaseId,\n        state,\n        typeOfRun,\n        rootProjectId,\n        projects,\n        submodules,\n        dependents,\n        warnings,\n        infos,\n        config\n    )\n}\n\nfun deserializeReleaseState(releasePlanJson: ReleasePlanJson): ReleaseState {\n    return ReleaseState.valueOf(releasePlanJson.state.unsafeCast<String>())\n}\n\nfun deserializeTypeOfRun(releasePlanJson: ReleasePlanJson): TypeOfRun {\n    return TypeOfRun.valueOf(releasePlanJson.typeOfRun.unsafeCast<String>())\n}\n\nfun deserializeProjectId(id: GenericType<ProjectId>): ProjectId {\n    return when (id.t) {\n        MAVEN_PROJECT_ID -> createMavenProjectId(\n            id\n        )\n        else -> throw UnsupportedOperationException(\"${id.t} is not supported.\")\n    }\n}\n\nprivate fun createMavenProjectId(genericId: GenericType<ProjectId>): MavenProjectId {\n    val dynamicId = genericId.p.unsafeCast<MavenProjectId>()\n    return MavenProjectId(dynamicId.groupId, dynamicId.artifactId)\n}\n\nfun deserializeProjects(releasePlanJson: ReleasePlanJson): Map<ProjectId, Project> {\n    val map = hashMapOf<ProjectId, Project>()\n    releasePlanJson.projects.forEach {\n        val projectId = deserializeProjectId(it.id)\n        map[projectId] = Project(\n            projectId, it.isSubmodule, it.currentVersion, it.releaseVersion, it.level,\n            it.commands.map { deserializeCommand(it) },\n            it.relativePath\n        )\n    }\n    return map\n}\n\nfun deserializeCommand(it: GenericType<Command>): Command {\n    return when (it.t) {\n        JENKINS_MAVEN_RELEASE_PLUGIN -> createJenkinsMavenReleasePlugin(it.p)\n        JENKINS_MULTI_MAVEN_RELEASE_PLUGIN -> createJenkinsMultiMavenReleasePlugin(it.p)\n        JENKINS_UPDATE_DEPENDENCY -> createJenkinsUpdateDependency(it.p)\n        else -> throw UnsupportedOperationException(\"${it.t} is not supported.\")\n    }\n}\n\nfun createJenkinsMavenReleasePlugin(command: Command): JenkinsMavenReleasePlugin {\n    val it = command.unsafeCast<JenkinsMavenReleasePlugin>()\n    return JenkinsMavenReleasePlugin(deserializeCommandState(it), it.nextDevVersion, it.buildUrl)\n}\n\nfun createJenkinsMultiMavenReleasePlugin(command: Command): Command {\n    val it = command.unsafeCast<JenkinsMultiMavenReleasePlugin>()\n    return JenkinsMultiMavenReleasePlugin(deserializeCommandState(it), it.nextDevVersion, it.buildUrl)\n}\n\nfun createJenkinsUpdateDependency(command: Command): JenkinsUpdateDependency {\n    val it = command.unsafeCast<JenkinsUpdateDependency>()\n    val projectId = MavenProjectId(it.projectId.groupId, it.projectId.artifactId)\n    return JenkinsUpdateDependency(deserializeCommandState(it), projectId, it.buildUrl)\n}\n\nfun deserializeCommandState(it: Command): CommandState {\n    val json = it.state.unsafeCast<CommandStateJson>()\n    val fixedState = fakeEnumsName(json)\n    val state = fromJson(fixedState)\n    val tmpState = (state as? CommandState.Deactivated)?.previous ?: state\n    if (tmpState is CommandState.Waiting) {\n        @Suppress(\"UNCHECKED_CAST\")\n        val realDependencies = tmpState.dependencies as Array<GenericType<ProjectId>>\n        val deserializedDependencies = realDependencies.map {\n            deserializeProjectId(it)\n        }.toHashSet()\n        tmpState.asDynamic().dependencies = deserializedDependencies\n    }\n    return state\n}\n\nprivate fun fakeEnumsName(json: CommandStateJson): CommandStateJson {\n    val state = JSON.parse<CommandStateJson>(JSON.stringify(json))\n    var tmp: CommandStateJson? = state\n    while (tmp != null) {\n        //necessary to fake an enum's name attribute (state is actually a json object and not really a CommandStateJson)\n        js(\"tmp.state = {name: tmp.state}\")\n        tmp = if (tmp.state.name == CommandStateJson.State.DEACTIVATED.name) {\n            tmp.previous\n        } else {\n            null\n        }\n    }\n    return state\n}\n\nfun deserializeMapOfProjectIdAndSetProjectId(mapJson: Array<GenericMapEntry<ProjectId, Array<GenericType<ProjectId>>>>): Map<ProjectId, Set<ProjectId>> {\n    return mapJson.associateBy(\n        { deserializeProjectId(it.k) },\n        { it.v.map { deserializeProjectId(it) }.toHashSet() }\n    )\n}\n\n\nfun deserializeConfig(config: Array<Array<String>>): Map<ConfigKey, String> {\n    return config.associate {\n        if (it.size != 2) {\n            showWarning(\"corrupt config found, size != 2: $it\")\n        }\n        ConfigKey.fromString(it[0]) to it[1]\n    }\n}\n\n\nexternal interface ReleasePlanJson {\n    var releaseId: String\n    var state: ReleaseState\n    var typeOfRun: TypeOfRun\n    val id: GenericType<ProjectId>\n    val projects: Array<ProjectJson>\n    val submodules: Array<GenericMapEntry<ProjectId, Array<GenericType<ProjectId>>>>\n    val dependents: Array<GenericMapEntry<ProjectId, Array<GenericType<ProjectId>>>>\n    val warnings: Array<String>\n    val infos: Array<String>\n    val config: Array<Array<String>>\n}\n\nexternal interface ProjectJson {\n    val id: GenericType<ProjectId>\n    val isSubmodule: Boolean\n    val currentVersion: String\n    var releaseVersion: String\n    val level: Int\n    val commands: Array<GenericType<Command>>\n    val relativePath: String\n}\n\nexternal interface GenericType<out T> {\n    val t: String\n    val p: T\n}\n\nexternal interface GenericMapEntry<out K, out V> {\n    val k: GenericType<K>\n    val v: V\n}\n","package ch.loewenfels.depgraph.gui.serialization\r\n\r\nimport ch.loewenfels.depgraph.data.ReleasePlan\r\nimport ch.loewenfels.depgraph.gui.jobexecution.DryRunJobExecutionDataFactory\r\nimport ch.loewenfels.depgraph.gui.jobexecution.JobExecutionDataFactory\r\nimport ch.loewenfels.depgraph.gui.jobexecution.ReleaseJobExecutionDataFactory\r\n\r\nclass ModifiableState(defaultJenkinsBaseUrl: String?, json: String) {\r\n    private val defaultJenkinsBaseUrl: String\r\n\r\n    private var _json: String\r\n    var json: String\r\n        get() = _json\r\n        private set(value) {\r\n            _json = value\r\n        }\r\n\r\n    private lateinit var _releaseJobExecutionDataFactory: JobExecutionDataFactory\r\n    var releaseJobExecutionDataFactory: JobExecutionDataFactory\r\n        get() = _releaseJobExecutionDataFactory\r\n        private set(value) {\r\n            _releaseJobExecutionDataFactory = value\r\n        }\r\n\r\n    private lateinit var _dryRunExecutionDataFactory: JobExecutionDataFactory\r\n    var dryRunExecutionDataFactory: JobExecutionDataFactory\r\n        get() = _dryRunExecutionDataFactory\r\n        private set(value) {\r\n            _dryRunExecutionDataFactory = value\r\n        }\r\n\r\n    private lateinit var _releasePlan: ReleasePlan\r\n    var releasePlan: ReleasePlan\r\n        get() = _releasePlan\r\n        private set(value) {\r\n            _releasePlan = value\r\n        }\r\n\r\n    /**\r\n     * Copy constructor, takes over the [defaultJenkinsBaseUrl] from the given [modifiableState]\r\n     */\r\n    constructor(modifiableState: ModifiableState, json: String): this(modifiableState.defaultJenkinsBaseUrl, json)\r\n\r\n    init {\r\n        val fakeJenkinsBaseUrl = \"https://github.com/loewenfels/\"\r\n        this.defaultJenkinsBaseUrl = defaultJenkinsBaseUrl ?: fakeJenkinsBaseUrl\r\n        _json = json\r\n        initJsonDependentFields()\r\n    }\r\n\r\n    private fun initJsonDependentFields() {\r\n        _releasePlan = deserialize(_json)\r\n        _releaseJobExecutionDataFactory = ReleaseJobExecutionDataFactory(defaultJenkinsBaseUrl, releasePlan)\r\n        _dryRunExecutionDataFactory = DryRunJobExecutionDataFactory(defaultJenkinsBaseUrl, releasePlan)\r\n    }\r\n\r\n    /**\r\n     * Applies the changes made in the GUI to [json] and indicates whether changes where made or not.\r\n     *\r\n     * @return `true` in case changes were made; `false` otherwise.\r\n     */\r\n    fun applyChanges(): Boolean {\r\n        val (changed, newJson) = ChangeApplier.createReleasePlanJsonWithChanges(releasePlan, json)\r\n        this.json = newJson\r\n        initJsonDependentFields()\r\n        return changed\r\n    }\r\n\r\n    /**\r\n     * Applies the changes made in the GUI to a **copy** of [json] and returns it.\r\n     */\r\n    fun getJsonWithAppliedChanges(): String {\r\n        val (_, newJson) = ChangeApplier.createReleasePlanJsonWithChanges(releasePlan, json)\r\n        return newJson\r\n    }\r\n}\r\n","package ch.loewenfels.depgraph.gui\r\n\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\nimport kotlin.js.Promise\r\n\r\nfun <T> sleep(ms: Int, action: () -> T): Promise<T> {\r\n    val p: Promise<Any> = Promise { resolve, _ -> window.setTimeout(resolve, ms) }\r\n    return p.then { action() }\r\n}\r\n\r\n// It's workaround for KT-19672 since we can fix it properly until KT-11265 isn't fixed.\r\ninline fun <T> Promise<Promise<T>>.unwrapPromise(): Promise<T> {\r\n    return this.unsafeCast<Promise<T>>()\r\n}\r\ninline fun <T> Promise<Promise<Promise<T>>>.unwrap2Promise(): Promise<T> {\r\n    return this.unsafeCast<Promise<T>>()\r\n}\r\ninline fun <T> Promise<Promise<Promise<Promise<T>>>>.unwrap3Promise(): Promise<T> {\r\n    return this.unsafeCast<Promise<T>>()\r\n}\r\ninline fun <T> Promise<Promise<Promise<Promise<Promise<T>>>>>.unwrap4Promise(): Promise<T> {\r\n    return this.unsafeCast<Promise<T>>()\r\n}\r\n\r\nfun changeCursorToProgress() {\r\n    document.body!!.style.cursor = \"progress\"\r\n}\r\n\r\nfun changeCursorBackToNormal() {\r\n    document.body!!.style.cursor = \"default\"\r\n}\r\n\r\nfun <T, S> Promise<T>.finally(action: (T?) -> S): Promise<S> {\r\n    return this\r\n        .then { action(it) }\r\n        .catch { t -> action(null); throw t }\r\n}\r\n\r\nfun randomPublishId(): String {\r\n    return uuidv4().replace(\"-\", \"\").take(15)\r\n}\r\n\r\n//copied from https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\r\nprivate fun uuidv4(): String {\r\n    val uuid = js(\r\n        \"\"\"'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n        return v.toString(16);\r\n    });\"\"\"\r\n    )\r\n    return uuid as String\r\n}\r\n","import ch.loewenfels.depgraph.gui.App\r\nimport kotlin.browser.window\r\n\r\n@JsName(\"main\")\r\nfun main() {\r\n    window.onload = { App() }\r\n}\r\n\r\n@Suppress(\"unused\")\r\nval onlyUsedToCallMain = main()\r\n\r\n@JsName(\"failAfterSteps\")\r\nvar failAfterSteps = 10000\r\n@JsName(\"waitBetweenSteps\")\r\nvar waitBetweenSteps = 500\r\n@JsName(\"stepWise\")\r\nvar stepWise = false\r\n\r\n@JsName(\"options\")\r\nfun options() {\r\n    console.log(\r\n        mapOf(\r\n            \"failAfterSteps\" to failAfterSteps,\r\n            \"waitBetweenSteps\" to waitBetweenSteps,\r\n            \"stepWise\" to stepWise\r\n        ).entries.joinToString(\"\\n\") { (k, v) -> \"$k: $v\" }\r\n    )\r\n}\r\n","package ch.loewenfels.depgraph.gui.jobexecution\r\n\r\nconst val GITHUB_REPO = \"https://github.com/loewenfels/dep-graph-releaser/\"\r\nconst val GITHUB_NEW_ISSUE = \"https://github.com/loewenfels/dep-graph-releaser/issues/new\"\r\nconst val LOEWENFELS_URL = \"https://www.loewenfels.ch\"\r\n"],"names":[],"mappings":"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"}